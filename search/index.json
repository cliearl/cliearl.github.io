[{"content":"이번 영상에서는 안드로이드의 테스트 자동화 기초에 대한 이론을 다루어 보도록 하겠습니다.\n들어가기 테스트는 소프트웨어 개발과 함께 시작된 행위니만큼 긴 역사를 가지고 있습니다. The History of Software Testing에서는 소프트웨어 테스팅이 1822년 찰스 베비지의 차분 엔진 제작과 함께 시작되었다고 하고, 버그라는 단어는 토마스 에디슨이 1878년 동료에게 보내는 편지에서 처음 사용된 것으로 알려져 있습니다. 따라서 테스트 방법론에서는 서로 대립하는 수많은 주장이 긴 시간동안 개발되어져 왔습니다. 테스트 유형이 피라미드 구조를 가져야 한다는 사람도 있고 아이스크림 콘 형태를 가져야 한다는 사람도 있습니다. 테스트 커버리지는 100%를 목표해야 한다는 사람도 있고 혹은 100%를 목표하는 것은 무의미한 일이라고 하는 사람도 있습니다. 테스트를 먼저 만들고 프로덕션 코드를 만들어야 한다는 주장도 있고, 실무중에 그러한 방식으로 일을 할 여유가 없다는 사람도 있습니다.\n모든 주장은 나름의 논리가 있기 때문에 무엇이 옳고 그른지는 알 수 없습니다. 그래서 이 파트에서는 방법론보다는 기술적으로 안드로이드에서 코드 테스트를 어떻게 수행하는지에 대해 중점을 두고 설명하도록 하겠습니다.\n테스트 자동화의 필요성 안드로이드 앱의 기능을 작성하면 필연적으로 기능의 테스트를 수행하게 됩니다. 코드를 수정하고 앱을 빌드한 뒤 에뮬레이터로 앱을 실행하고 화면을 터치해 보면서 내가 만든 기능이 기대한대로 작동하는지 확인하게 되지요. 이 때 다음과 같이 다양한 유형의 테스트를 수행해야 합니다.\n기능 테스트 : 내 앱이 기능을 수행합니까? 성능 테스트 : 빠르고 효율적으로 수행합니까? 접근성 테스트 : 접근성 서비스와 잘 작동합니까? 호환성 테스트 : 모든 기기와 API 수준에서 잘 작동합니까? 하지만 앱의 기능이 많아지고 구조가 복잡해지게 되면 점점 빌드 시간도 증가하게 되므로 코드를 수정할 때마다 개발자가 수동으로 앱의 모든 기능을 테스트하는 것은 물리적으로 불가능하게 됩니다. 앱의 기능을 수동으로 테스트하는 전문 QA팀을 운용할 수도 있겠지만 개발 비용이 많이 증가하게 되겠지요.\n컴퓨터가 테스트를 자동으로 수행하게 하는 것을 테스트 자동화라고 하는데요, 개발에 테스트 자동화를 적용하면 기능을 개발할 때마다 일일이 빌드를 수행할 필요가 없어 개발 시간을 줄여주고, 버그를 빠른 시점에 파악할 수 있어 개발 비용을 줄일 수 있습니다. 또한 기능을 개발할 때 자동 테스트가 가능한 구조가 되도록 고려하게 되기 때문에 자연스럽게 프로그램이 더욱 견고한 구조를 갖게 되는 많은 장점이 있습니다.\n자동 테스트의 분류 소프트웨어를 테스트하는 방법은 크게 블랙박스 테스트와 화이트박스 테스트로 나눌 수 있습니다. 블랙박스 테스트는 소프트웨어의 내부 구조나 작동 원리를 모르는 상태에서 소프트웨어의 동작이 요구사항을 만족하는지 검사하는 방법으로 개발자가 아닌 사용자 입장에서의 테스팅입니다. 화이트박스 테스트는 블랙박스 테스트와는 반대로 소프트웨어의 내부 구조와 제어 흐름을 직접 관찰하는 테스트 방식으로 개발자 입장에서의 테스팅이 되겠습니다. 안드로이드의 테스트 자동화에는 이 두 방식이 모두 사용됩니다.\n구글은 안드로이드의 자동 테스트를 다음 그림과 같이 단위 테스트 (Unit Test), 통합 테스트 (Intergration Test), 종단간 테스트 (End-to-end Test)로 분류하고 있습니다. 단위 테스트에서 종단간 테스트로 갈수록 각 테스트의 충실도는 증가하지만 실행 시간과 유지보수 및 디버깅에 드는 노력도 증가하게 됩니다. 따라서 일반적으로는 단위 테스트를 통합 테스트보다 많이 작성하고 통합 테스트를 종단간 테스트보다 더 많이 작성하게 됩니다.\n단위 테스트 (Unit Test) 단위 테스트는 앱의 메서드 또는 클래스와 같은 작은 단위의 기능을 검증합니다. 테스트 범위가 작기 때문에 작성이 수월하고 테스트 속도가 빠릅니다.\n로컬 단위 테스트 (Local Unit Test) Android Framework에 의존하지 않고 로컬 JVM에서 실행되는 테스트입니다. 실제 기기나 에뮬레이터를 사용하지 않으므로 테스트 속도가 빠르다는 특징이 있습니다.\n계측 단위 테스트 (Instrumented Unit Test) Android Framework에 의존하는 기능을 검증하는 단위 테스트입니다. 실제 기기 또는 에뮬레이터에서 실행해야 하기 때문에 실행시간이 오래 걸린다는 특징이 있습니다.\n통합 테스트 (Intergration Test) 통합 테스트는 서로 다른 모듈 또는 클래스 간의 상호작용이 정상적으로 기능하는지를 검증합니다. 단위 테스트로 각 모듈의 기능을 검증했을지라도, 동시에 여러 모듈을 동작시켰을 때는 정상작동을 하지 않을 수도 있기 때문입니다.\n종단간 테스트 (End-to-end Test) 종단간 테스트는 앱의 전체 화면 또는 여러 모듈에 걸친 사용자 흐름과 같은 큰 부분에 대한 기능 검증을 수행합니다. User Interface를 사용할 때 화면이 올바르게 응답하는지 확인하는 테스트이기 때문에 UI 테스트라 부르기도 합니다.\n테스트 사이즈 단위, 통합, 종단간이라는 분류는 얼핏 듣기에 모호하게 들릴 수 있습니다. 그래서 구글은 사이즈 기준으로 단위 테스트는 소형 테스트, 통합 테스트는 중형 테스트, 그리고 종단간 테스트는 대형 테스트로 분류하기도 합니다. 크기에 따른 각 테스트의 특징은 다음 표와 같습니다.\nFeature Small Medium Large Network access No localhost only Yes Database No Yes Yes File system access No Yes Yes Use external systems No Discouraged Yes Multiple threads No Yes Yes Sleep statements No Yes Yes System properties No Yes Yes Time limit (seconds) 60 300 900+ 테스트 기본 원칙 이번에는 프로그램을 테스트할 때 지켜야 하는 몇가지 원칙을 소개하겠습니다.\nSeven Testing Principles Seven Testing Principles은 ISTQB (International Software Testing Qualifications Board)에서 제안한 7가지 테스트 원칙입니다.\nTesting shows the presence of defects, not their absence : 테스팅은 결함의 존재를 보여주는 것이다. Exhaustive testing is impossible : 완벽한 테스트는 불가능하다. Early testing saves time and money : 테스트 구성은 가능한 빠르게 시작한다. Defects cluster together : 결함은 군집되어 있다. Beware of the pesticide paradox : 살충제 역설 - 비슷한 테스트가 반복되면 새로운 결함을 발견할 수 없다. Testing is context dependent : 테스팅은 문맥에 의존적이다. Absence-of-errors is a fallacy : 오류 부재의 궤변 - 사용되지 않는 시스템이나 사용자의 기대에 부응하지 않는 기능의 결함을 찾고 수정하는 것은 의미가 없다. F.I.R.S.T Principles F.I.R.S.T Principles이란 로버트 마틴 선생의 Clean Code에서 소개한 단위 테스트에 관한 원칙들을 Brett Schuchert과 Tim Ottinger가 F.I.R.S.T라는 이름으로 정리한 것입니다.\nFast: 단위 테스트는 빨라야 한다. Isolated: 테스트가 다른 테스트 케이스에 의존하지 않아야 한다. Repeatable: 테스트는 실행할 때마다 같은 결과를 만들어야 한다. Self-validating: 테스트 결과는 성공이거나 실패여야 한다. 결과에 대한 해석이 필요해서는 안된다. Timely: 단위 테스트는 기능이 출시된 후에도 언제든 작성할 수 있지만 적절한 시점은 프로덕션 코드를 구현하고 있는 와중에 테스트 코드를 작성하는 것이다. 테스트 코드 작성 스타일 테스트의 원칙은 알겠습니다. 그럼 테스트 코드는 어떤 스타일로 작성해야 할까요? 넓은 공감대를 얻고 있는 스타일 중의 하나는 마틴 파울러 선생이 제안한 Given-When-Then 스타일입니다. GWT는 테스트 코드 구조를 다음 세 부분으로 분리해서 생각합니다.\nGiven: 어떠한 상태하에서 When: 어떠한 기능을 실행하면 Then: 어떠한 결과가 나와야 한다. 예를들어 x = 1일 때(Given), 2를 곱하면(When), 2가 나와야 하는(Then) 테스트 메소드는 다음과 같은 구조를 갖게 되는 것입니다.\n1 2 3 4 5 6 7 8 9 10 11 @Test fun x1_multiplyBy2_2() { // GIVEN val x = 1 // WHEN val result = Utils.multipleBy2(x) // THEN assertEquals(2, result) } Test Double 영화 촬영에서 우리가 흔히 아는 스턴트맨의 정확한 용어는 스턴트 더블이라고 하는데요, 테스트 더블은 말그대로 실제 구성요소 대신 테스트를 수행하는 객체입니다. xUnit Test Patterns의 저자인 제라드 메스자로스(Gerard Meszaros)가 만든 용어라고 하네요.\nF.I.R.S.T Principles중 Isolated에 따르면 테스트는 다른 테스트에 의존하지 않고 격리되어서 어떤 순서로든, 어떤 개별 테스트이든 실행할 수 있어야 합니다. 격리한다는 것은 테스트 대상이 의존하는 것을 실제가 아닌 다른 것으로 대체하는 것인데 이 때 사용하는 것이 테스트 더블인 것입니다. 테스트 더블에는 다음과 같이 Dummy, Stub, Spy, Mock, Fake 가 있는데요, 각각의 정의와 사용법에 대해 설명하도록 하겠습니다.\nDummy 가장 기본적인 테스트 더블로 기능을 전혀 구현하지 않은 객체입니다. 인스턴스는 필요하지만 기능까지는 필요하지 않은 경우에 사용합니다. DummyAccountDao는 AccountDao를 상속하고 있지만 기능을 구현하지 않았죠.\n1 2 3 4 5 6 7 8 9 interface AccountDao { fun showMember() } class DummyAccountDao : AccountDao { override fun showMember() : List\u0026lt;String\u0026gt; { // No implementation } } Stub Dummy가 실제로 동작하는 것처럼 보이게 만들어 놓은 객체입니다. 인터페이스 혹은 클래스를 최소한으로 구현하고, 결과는 특정 상태를 가정해서 하드코딩된 값을 제공합니다. 따라서 로직에 따른 값의 변경은 테스트 할 수 없습니다. 객체에 특정한 메소드를 적용하기 전과 후의 상태를 확인하는 상태 기반 테스트(State-based testing)에 사용되는 테스트 더블입니다. StubAccountDao는 AccountDao를 상속하지만 showMember 처리까지 완전히 구현하는게 아니라 단순히 고정된 상수값을 반환하도록 하고 있습니다.\n1 2 3 4 5 6 7 8 9 10 interface AccountDao { fun showMember() } class StubAccountDao : AccountDao { override fun showMember() : List\u0026lt;String\u0026gt; { val memberList = listOf(\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;) return memberList } } Spy Stub과 비슷한 객체인데 추가적인 정보를 더 기록할 수 있게 구성되어 있습니다. 예를 들어 예상된 메소드가 잘 호출되었는지 몇 번이나 호출되었는지 등을 파악할 수 있습니다. 어떤 메소드 A가 호출 되었을 때 또 다른 메소드 B가 실행이 되었는지 확인하는 등의 행위 기반 테스트 (Interaction-based testing)에 사용되는 테스트 더블입니다. SpyAccountDao의 showMember 메소드를 보면 내부에서 callMemberCount를 증가시키는 스파이 동작을 하는 것을 알 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 interface AccountDao { fun showMember() } class SpyAccountDao : AccountDao { private var callMemberCount = 0 override fun showMember() : List\u0026lt;String\u0026gt; { val memberList = listOf(\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;) callMemberCount++ return memberList } } Fake 동작하는 구현이 있기에 테스트에는 사용할 수 있지만 프로덕션 구현과 동일하지는 않은 객체입니다. 상태 기반 테스트(State-based testing)에 사용되는 테스트 더블인데, Mocking을 필요로 하지 않고 가볍기 때문에 구글에서 추천하는 더블입니다. FakeAccountDb는 AccountDb를 가짜로 구현하는데, Stub과 차이점이라면 Stub의 경우 메소드 로직은 구현하지 않고 단지 고정값을 반환하지만, Fake는 메소드 로직까지 구현한다는 점이 다릅니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 interface AccountDb { fun saveItem(userId: Int, name: String) fun getItem(userId: Int) : String? } class FakeAccountDb : AccountDb { private var accounts = HashMap\u0026lt;Int, String\u0026gt;() init { accounts[0] = \u0026#34;Alice\u0026#34; accounts[1] = \u0026#34;Bob\u0026#34; } override fun saveItem(userId: Int, name: String) { accounts[userId] = name } override fun getItem(userId: Int) : String? { return accounts[userId] } } Mock Mock은 Spy처럼 행위 기반 테스트에 사용되는 테스트 더블입니다. 차이점은 Spy가 메소드 A와 B의 실제 동작을 추적하는 더블인데 반해, Mock은 A가 실행되면 그냥 B의 정상 작동값을 반환하도록 구성된 더블이라고 생각하시면 됩니다. 행위 기반 테스트는 작성이 복잡하고 까다로운 부분이 많기 때문에 Mocking에 사용하는 전용 라이브러리들이 만들어져 있습니다. 코드를 보시면 Car는 엔진과 대시보드 의존성을 주입받도록 되어 있고 CarTest에서 Car를 테스트 합니다. 이때 엔진과 대시보드의 Mock을 만들어서 주입한 뒤 Mock이 정상적으로 작동하는지를 verify로 검증하는 방식입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Car( private val engine: Engine, private val dashboard: Dashboard ) { fun start() { engine.ignite() dashboard.display() } } class CarTest { var engineMock: Engine = mock(Engine::class.java) var dashboardMock: Dashboard = mock(Dashboard::class.java) @Test fun start_the_car() { val car = Car(engineMock, dashboradMock) car.start() verify(engineMock).ignite() verify(dashboardMock).display() } } 테스트 더블은 기능을 구현한 정도에 따라 다음과 같이 구분할 수도 있습니다.\n테스트 대상 항목 구글에서 제안하는 앱의 주된 테스트 대상 항목은 다음과 같습니다.\n단위 테스트 대상 ViewModels 또는 Presenter 데이터 레이어 유즈 케이스 값을 계산하는 유틸리티 클래스 엣지 케이스 음수, 0 및 경계 조건 을 사용하는 수학 연산 가능한 모든 네트워크 연결 오류 형식이 잘못된 JSON과 같은 손상된 데이터 파일 저장시 스토리지가 가득 찬 상황 프로세스 중간에 다시 생성된 개체(예: 장치가 회전할 때의 액티비티) UI 테스트 스크린 UI 유저 플로우 내비게이션 테스트 제외 대상 프레임워크 자체의 동작 activities, fragments, 혹은 services에는 테스트가 필요한 로직을 가능한 배치하지 않음 테스트 라이브러리 안드로이드에서 사용할 수 있는 테스트용 라이브러리에 대해 알아보도록 하겠습니다.\nTesting Framework JUnit4 : Java의 단위 테스트 코드를 작성하기 위해 만들어진 프레임워크로 Jetpack Test 라이브러리는 JUnit4를 기준으로 만들어져 있음. 현재 최신 버전은 JUnit5이나, 안드로이드를 완벽히 지원하지 않음. Kotest : Kotlin의 단위테스트 코드를 작성하기 위해 만들어진 프레임워크. Roboletric : JVM 만으로 안드로이드 프레임워크를 테스팅하기 위해 만들어진 프레임워크. Assertion Assertion의 표현력이 부족한 JUnit의 단점을 메워주는 여러가지 라이브러리들이 있습니다. AssertJ와 Truth는 사용법이 비슷한데 라이브러리를 관리하는 구글에 따르면 Truth가 AssertJ보다 먼저 만들어졌다고 하네요.\nAssertJ Truth Hamcrest 1 2 3 4 5 6 7 8 // JUnit assertTrue(notificationText.contains(\u0026#34;testuser@google.com\u0026#34;)); // AssertJ, Truth assertThat(notificationText).contains(\u0026#34;testuser@google.com\u0026#34;); // Hamcrest assertThat(notificationText, containsString(\u0026#34;testuser@google.com\u0026#34;)); Mocking Mockito : Java 테스트를 위한 Mocking 라이브러리 MockK : Kotlin 테스트를 위한 Mocking 라이브러리 UI Testing Espresso : 단일 안드로이드 앱의 UI를 테스트하는 프레임워크 Kaspresso : KasperskyLab에서 제작한 안드로이드 앱 UI 테스트 프레임워크 Appium : iOS와 Android를 모두 테스트 할 수 있는 UI 테스트 프레임워크 UI Automator : 복수 앱 간의 UI 기능을 테스트하는 프레임워크 구글의 안드로이드 테스팅 환경 Testing Related Video from Android Developers 구글은 테스팅의 중요성을 지속적으로 강조해왔고 테스팅 전략이나 새로운 테스팅 라이브러리를 꾸준히 발표해 왔습니다.\nAndroid Testing (Android Dev Summit 2015) Test-driven development on Android with the Android Testing Support Library (Google I/O \u0026lsquo;17) Frictionless Android testing: Write once, run everywhere (Google I/O \u0026lsquo;18) Testing rebooted (with AndroidX Test) (Android Dev Summit \u0026lsquo;18) Testing Android apps at scale with Nitrogen (Android Dev Summit \u0026lsquo;18) Build testable apps for Android (Google I/O'19) What\u0026rsquo;s new in Android testing tools | Session Jetpack Test Library 안드로이드 모듈의 테스트를 위한 핵심 라이브러리가 바로 Jetpack Test 라이브러리 입니다. 저장소는 Github에도 공개되어 적극적인 피드백을 받고 있는데, 다음과 같은 아티팩트들로 구성되어 있습니다.\nArtifact Stable Release annotation 1.0.0 core 1.4.0 espresso 3.4.0 ext.junit 1.1.3 ext.truth 1.4.0 monitor 1.5.0 orchestrator 1.4.1 runner 1.4.0 rules 1.4.0 services 1.4.1 UI/Application Exerciser Monkey 안드로이드 앱은 UI/Application Exerciser Monkey를 통해 몽키 테스트를 수행할 수 있습니다. 사람이 아닌 원숭이는 앱에 대해 아는게 없으니까 아무거나 막 눌러보겠죠. 그런 임의 동작을 통해 이슈를 찾아내는 테스트 방법을 몽키 테스트라고 합니다.\nMonkey는 에뮬레이터 또는 장치에서 실행되고 클릭, 터치 또는 제스처와 같은 사용자 이벤트의 의사 무작위 스트림과 여러 시스템 수준 이벤트를 생성합니다. ADB를 통해 다음과 같이 실행하며 여러가지 옵션을 지정할 수 있습니다.\n1 adb shell monkey [options] \u0026lt;event-count\u0026gt; Unified Test Platform Android Studio와 Android Gradle Plugin에서 Android Instrument Test Runner 버전이 다를 경우 Android Studio와 CI서버의 테스트 결과가 다르게 보고될 수 있습니다.\n이런 문제를 해결하기 위해 AGP 7.1.0 및 Android Studio Bumblebee 이상의 버전에서는 모든 계측 테스트가 통합된 Gradle Test Runner에서 실행되도록 변경되었습니다.\n구글은 여기에서 한걸음 더 나아가 Unified Test Platform이라는 것을 발표했습니다. 처음에는 Nitrogen이라는 이름으로 2018년에 발표된 프로젝트인데 2021년 Google I/O에서 처음으로 실물이 공개되었습니다. Jetpack의 연료라는 의미에서 Nitrogen이라는 이름을 붙였다고 하네요. UTP를 이용하면 서로 다른 OS의 테스트를 모듈 방식으로 추가할 수 있고 병렬로 테스트를 수행할 수 있어서 테스트를 대규모화할 수 있게 된다고 합니다.\nCode Coverage 내 코드가 얼마만큼 테스트 되고 있는지 평가할 수 있는 지표를 Code Coverage라고 합니다. Java 코드를 평가하는 데에는 Java Code Coverage Library(JaCoCo)가 사용되는데요, 안드로이드 스튜디오에는 이 기능이 기본적으로 포함되어 있기 때문에 코드 테스트를 실행할 때 Run 대신 Run test-name with coverage 메뉴로 실행하면 다음과 같이 Code Coverage 결과를 얻을 수 있습니다.\n앱의 모든 코드가 테스트 되고 있다면 Code Coverage는 100%가 될 텐데요, Code Coverage 100%를 달성하는 것은 물리적으로도 매우 어려운 일일 뿐더러, 실제로는 테스트를 하지 말아야 하는 종류의 코드도 있기 때문에 100%라는 숫자를 달성하는 것에 매달릴 필요는 없습니다. Test Driven Development의 저자인 Kent Beck 선생은 코드 커버리지 100%를 뽐내는 사람은 신문의 글자 하나 하나를 읽었다고 자랑하는 것과 같다고 비판하기도 했습니다.\n어떤 코드가 테스트 하기 좋은 코드인가? 어쨌든 Code Coverage를 높이기 위해서는 더 많은 기능에 대한 테스트를 만들어야 합니다. 그럴려면 각 기능이 테스트를 하기 좋은 구조로 되어 있어야 하겠죠. 그렇다면 테스트를 하기 좋은 코드라는 건 어떤 것일까요?\n이 부분은 간단히 설명할 수 있는 주제가 아니기 때문에 대신 인사이트를 얻을 수 있는 훌륭한 세미나 발표를 하나 소개드리도록 하겠습니다. OKKY가 TDD를 주제로 2018년에 주최한 OKKYCON: 2018 - The Real TDD라는 세미나가 있는데요, 당시 발표자료가 유튜브에 공개 되어 있기 때문에 참고하시면 좋을 것 같습니다.\nCI/CD 마지막으로 CI/CD에 대해 알아보도록 하겠습니다. Build tool과 Android Gradle Plugin 강의에서 설명한대로 프로덕트의 빌드는 다음과 같은 과정을 거치게 됩니다.\n연관된 의존성 다운로드 소스 코드를 바이너리 코드로 컴파일 바이너리 코드 링크하여 실행가능 파일로 패키징 테스트 수행 프로덕션 시스템에 배포 다시 말해 개발자는 코드를 작성할 때마다 컴파일을 하고 테스트를 수행한 뒤 서버에 업로드해야 합니다. 코드 변경이 별로 없는 프로덕션이라면 빌드를 개발자가 직접 수행해도 문제 없겠지만, 코드 변경이 10분마다 한 번씩 일어난다면 빌드를 수행하다가 하루가 끝나버릴 것 같네요. 만약 수십명의 개발자가 기능을 개발하는데 연관되어 있다면 이젠 어떤 순서로 빌드를 수행해야 할 지도 알 수 없게 되어 버릴 것입니다.\n지속적 통합(Continuous Integration, CI)은 개발자가 코드를 작성하고 저장소에 커밋하면 자동으로 컴파일과 테스트를 수행하고, 여러 개발자의 커밋에 대한 빌드 순서도 관리해 주는 솔루션을 의미합니다. 실무에서 많이 사용되는 솔루션으로는 Github Actions, CircleCI, Bitrise, Jenkins, TeamCity 등이 있습니다.\n지속적 제공(Continuous delivery, CD)은 CI가 완료되어 배포할 수 있는 상태의 빌드 결과물을 저장소에 업로드 하는 것이고, 지속적 배포(Continuous Deployment, CD)는 지속적 제공 과정이 완료된 결과물을 최종 사용자가 사용할 수 있는 환경까지 자동으로 배포하는 솔루션을 의미합니다. 실무에서 많이 사용되는 솔루션으로는 Fastlane, Firebase App Distribution, DeployGate, Bitrise Ship 등이 있습니다.\nCI와 CD의 진행구성은 다음 그림과 같습니다. CI/CD를 도입하면 개발자는 빌드와 배포에 대해서는 신경쓰지 않고 코드를 작성하는데에만 집중할 수 있습니다. 테스트 자동화는 CI/CD 솔루션과 결합될 때 진정한 위력을 발휘할 수 있게 되는 것입니다.\n이렇게 해서 안드로이드의 테스트 자동화 기초에 대해 알아보았습니다.\n","date":"2023-02-05T16:47:26+09:00","permalink":"https://cliearl.github.io/posts/android/android-test-basic/","title":"안드로이드 테스트 자동화 기초"},{"content":"Airsonic-Advanced Subsonic에서 오픈소스로 갈라져 나온 음원 스트리밍 서버. 웹으로도 스트리밍 할 수 있고, Subsonic을 이용할 수 있는 앱에서 스트리밍을 할 수도 있다. https://github.com/airsonic-advanced/airsonic-advanced https://registry.hub.docker.com/r/linuxserver/airsonic-advanced 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # docker-compose version: \u0026#34;2.1\u0026#34; services: airsonic-advanced: image: lscr.io/linuxserver/airsonic-advanced:latest container_name: airsonic-advanced environment: - PUID=0 - PGID=0 - TZ=Asia/Seoul - CONTEXT_PATH=\u0026lt;URL_BASE\u0026gt; #optional - JAVA_OPTS=-Dserver.use-forward-headers=true #optional volumes: - \u0026lt;/path/to/config\u0026gt;:/config - \u0026lt;/path/to/music\u0026gt;:/music - \u0026lt;/path/to/playlists\u0026gt;:/playlists - \u0026lt;/path/to/podcasts\u0026gt;:/podcasts - \u0026lt;/path/to/other media\u0026gt;:/media #optional ports: - 4040:4040 devices: - /dev/snd:/dev/snd #optional restart: unless-stopped Aircomix Server Aircomix의 만화책 서버. http://www.server102.net/granma/aircomix_ko.html https://registry.hub.docker.com/r/drss/aircomix-server/ 1 2 3 4 5 6 7 docker run -itd \\ -e PASSWORD=[패스워드] \\ -v [만화경로]:/data/manga \\ -p [포트]:31257 \\ --name=aircomix-server \\ drss/aircomix-server Homer 브라우저 홈 화면을 만들어주는 앱. 아이템을 카테고리화 할 수도 있고 검색바를 추가할 수도 있다. https://github.com/bastienwirtz/homer https://registry.hub.docker.com/r/b4bz/homer/ 1 2 3 4 5 6 # docker-compose volumes: - /your/local/assets/:/www/assets ports: - 8080:8080 Notea 사용이 편리한 노트 앱. https://github.com/notea-org/notea https://registry.hub.docker.com/r/cinwell/notea/ 1 2 3 4 5 6 7 8 9 10 11 12 # docker docker run -d \\ --name notea \\ -p 3000:3000 \\ -e STORE_ACCESS_KEY=Q3AM3UQ867SPQQA43P2F \\ -e STORE_SECRET_KEY=zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG \\ -e STORE_BUCKET=notea \\ -e STORE_END_POINT=http://play.minio.io \\ -e STORE_FORCE_PATH_STYLE=true \\ -e PASSWORD=notea \\ cinwell/notea MinIO Notea의 DB. Amazon S3 규약에 따르는 API를 제공한다. https://github.com/minio/minio https://registry.hub.docker.com/r/minio/minio/ 1 2 3 # docker docker run -p 9000:9000 -p 9001:9001 \\ quay.io/minio/minio server /data --console-address \u0026#34;:9001\u0026#34; Gitea 코드 형상관리. Gitlab이 무겁다고 느낀다면 괜찮은 선택. https://github.com/go-gitea/gitea https://registry.hub.docker.com/r/gitea/gitea/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # docker-compose version: \u0026#34;3\u0026#34; networks: gitea: external: false services: server: image: gitea/gitea:1.17.4 container_name: gitea environment: - USER_UID=1000 - USER_GID=1000 restart: always networks: - gitea volumes: - ./gitea:/data - /etc/timezone:/etc/timezone:ro - /etc/localtime:/etc/localtime:ro ports: - \u0026#34;3000:3000\u0026#34; - \u0026#34;222:22\u0026#34; PostgreSQL Gitea용 DB. https://github.com/postgres/postgres https://registry.hub.docker.com/_/postgres/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 # docker-compose version: \u0026#34;3\u0026#34; networks: gitea: external: false services: server: image: gitea/gitea:1.17.4 container_name: gitea environment: - USER_UID=1000 - USER_GID=1000 + - GITEA__database__DB_TYPE=postgres + - GITEA__database__HOST=db:5432 + - GITEA__database__NAME=gitea + - GITEA__database__USER=gitea + - GITEA__database__PASSWD=gitea restart: always networks: - gitea volumes: - ./gitea:/data - /etc/timezone:/etc/timezone:ro - /etc/localtime:/etc/localtime:ro ports: - \u0026#34;3000:3000\u0026#34; - \u0026#34;222:22\u0026#34; + depends_on: + - db + + db: + image: postgres:14 + restart: always + environment: + - POSTGRES_USER=gitea + - POSTGRES_PASSWORD=gitea + - POSTGRES_DB=gitea + networks: + - gitea + volumes: + - ./postgres:/var/lib/postgresql/data Calibre-Web 서적 관리 https://github.com/janeczku/calibre-web https://registry.hub.docker.com/r/linuxserver/calibre-web/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # docker-compose version: \u0026#34;2.1\u0026#34; services: calibre-web: image: lscr.io/linuxserver/calibre-web:latest container_name: calibre-web environment: - PUID=1000 - PGID=1000 - TZ=Europe/London - DOCKER_MODS=linuxserver/mods:universal-calibre #optional - OAUTHLIB_RELAX_TOKEN_SCOPE=1 #optional volumes: - /path/to/data:/config - /path/to/calibre/library:/books ports: - 8083:8083 restart: unless-stopped code-server 온라인으로 사용가능한 VS Code https://github.com/coder/code-server https://registry.hub.docker.com/r/linuxserver/code-server/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # docker-compose version: \u0026#34;2.1\u0026#34; services: code-server: image: lscr.io/linuxserver/code-server:latest container_name: code-server environment: - PUID=1000 - PGID=1000 - TZ=Europe/London - PASSWORD=password #optional - HASHED_PASSWORD= #optional - SUDO_PASSWORD=password #optional - SUDO_PASSWORD_HASH= #optional - PROXY_DOMAIN=code-server.my.domain #optional - DEFAULT_WORKSPACE=/config/workspace #optional volumes: - /path/to/appdata/config:/config ports: - 8443:8443 restart: unless-stopped Wiki.js 위키 https://github.com/Requarks/wiki https://registry.hub.docker.com/r/linuxserver/wikijs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # docker-compose version: \u0026#34;2.1\u0026#34; services: wikijs: image: lscr.io/linuxserver/wikijs:latest container_name: wikijs environment: - PUID=1000 - PGID=1000 - TZ=Europe/London volumes: - \u0026lt;path to config\u0026gt;:/config - \u0026lt;path to data\u0026gt;:/data ports: - 3000:3000 restart: unless-stopped Textcube 블로그 툴. https://github.com/Needlworks/Textcube https://registry.hub.docker.com/r/nacyot/textcube/ 1 2 3 4 5 6 # docker docker run -itd \\ -p 80:80 \\ nacyot/textcube ","date":"2022-12-18T17:27:04+09:00","permalink":"https://cliearl.github.io/posts/linux/favorite-docker-containers/","title":"내가 사용하는 도커 컨테이너 리스트"},{"content":"★: 읽을가치 있음 ★★: 소장가치 있음\n응용소프트웨어 개론 컴퓨팅 사고 :소프트웨어를 통한 문제해결 / Riley, David D / 고양 :Infinitybooks,2017.\n개발자가 되고 싶으세요? =Developer :IT 입문 지식을 말하다 / 고종범 / 서울 :로드북,2015.\n프로그래밍이 보이는 그림책 / ANK / 서울 :성안당,2017.\n프로그래머가 알아야 할 1%의 핵심원리 | 조민호, 이명섭 지음 | 성안당 | 2009 |\n프로그래밍 가이드북 :프로그래머가 되기 전에 꼭 읽어야 할 필독서 / 쇼다, 쓰야노 / 서울 :정보문화사,2016.\n★★프로그래밍 언어도감 :가장 인기있는 프로그래밍 언어 67개 수록, 마스이, 도시카츠, 서울 :영진닷컴,2018\n하드웨어, 운영체제 컴퓨터 사이언스 =Computer science / 이동명 / 서울 :한빛아카데미,2014.\n★★(머신러닝과 블록체인을 떠받치는) GPU의 모든 기술 / Ando, Hisa / 인천 :남가람북스,2018.\n★성공과 실패를 결정하는 1%의 Windows 구조와 원리 =How Windows works / 아마노, 스카사 / 서울 :성안당.com,2003.\nOS가 보이는 그림책 :국내 최초 그림으로 배우는 OS 입문서, ANK, 파주 :성안당,2012\n자료구조, 알고리즘 (그림으로 배우는) 알고리즘 =Algorithm :basic / 스기우라, 겐 / 서울 :영진닷컴,2016.\n★★(C로 배우는) 쉬운 자료구조 / 이지영 / 서울 :한빛아카데미,2016.\nC ★★(熱血講義) C 프로그래밍 / 윤성우 / 부천 :프리렉,2003.(2006 1판4쇄).\n(실용적 사례 570 제로 풀어보는) 알고리즘과 함께하는 C의 아름다움 / 김정훈 / 서울 :사이텍미디어,2003.\n(김태용의)C 언어 프로그래밍 입문 =Beginning C programming / 김태용 / 파주 :제이펍,2012.\n★★C를 배우기 전에 반드시 알아야 할 것들 / 무라야마, 유키오 / 부천 :루비페이퍼,2015.\n★★C언어 코딩 도장 / 남재윤 / 서울 :길벗,2016.\n(쉽게 배우는) C 프로그래밍 테크닉 :gcc 컴파일러 기반 / 사까이,히로아끼 / 서울 :정보문화사,2004.\nC포인터의 이해와 활용 / Reese, Richard / 파주 :제이펍,2013.\nC가 보이는 그림책 =C programming / ANK Co., Ltd / 서울 :성안당.com,2003.\nC++ ★★(Programming)C++가 보이는 그림책 :국내 최초 C++프로그래밍 그림 입문서 / ANK Co., Ltd / 파주 :성안당,2006.\n윤성우의 열혈 C++ 프로그래밍, 윤성우, 서울 :오렌지미디어,2010.\n★★이것이 C++이다 :강의 현장을 그대로 옮긴 C++ 입문서, 최호성, 서울 :한빛미디어,2016.\n(Thinking about) C/C++ :프로그래머가 몰랐던 프로그램의 동작 원리 :프로그램 실행 환경편 / 박수현 / 서울 :한빛미디어,2014.\n(Thinking about) C/C++ :프로그래머가 몰랐던 프로그램의 동작 원리 :프로그램 개발편, 박수현, 서울 :한빛미디어,2014\n(Thinking about) C/C++ :프로그램 생성편 박수현, 서울 :한빛미디어,2014.\nPython 코딩 부트캠프 with 파이썬 / 유모토, 미치타카 / 서울 :길벗,2017.\n점프 투 파이썬 / 박응용 / 서울 :이지스퍼블리싱,2016.\n★(비전공자가 궁금해하는) 프로그래머 첫걸음 / Althoff, Cory / 서울 :한빛미디어,2018.\n(처음 만나는) 파이썬 / 가마다, 마사히로 / 파주 :제이펍,2017.\n★★개발자를 위한 파이썬 :현장에서 일하는 개발자 맞춤 입문서 / 윤웅식 / 서울 :한빛미디어,2017.\n파이썬을 여행하는 히치하이커를 위한 안내서 :모범 사례와 실용 라이브러리로 더 파이썬답게! / Reitz, Kenneth / 서울 :인사이트,2017.\n★(깐깐하게 배우는) 파이썬 / Shaw, Zed A / 서울 :인사이트,2014.\n파이썬 핵심 레퍼런스 :빠르게 찾아서 바로 적용하는 실무 가이드 / Lutz, Mark / 서울 :인사이트,2016.\n★★파이썬 라이브러리 레시피 :표준 라이브러리부터 서드파티 패키지까지 / 이케우치, 다카히로 / 부천 :프리렉,2016.\n★★엔지니어를 위한 파이썬 : 개발 기초, 필수 라이브러리, 그리고 고속화 | 나카쿠키 켄지 지음;심효섭 옮김 | 제이펍 | 2017 |\n★★파이썬 코딩 도장 / 남재윤 / 서울 :길벗,2018\nSwift ★(Do it!) 스위프트로 아이폰 앱 만들기 :입문, 이범근, 서울 :이지스퍼블리싱,2017\n★★(The 친절한) Swift v4.0 프로그래밍 :zero, 정재곤, 서울 :책장,2018\n★★스위프트 프로그래밍 :Swift 4 :객체지향, 함수형, 프로토콜 지향 패러다임까지 한 번에!, 야곰, 서울 :한빛미디어,2017.\n★이것이 iOS다 :Swift로 시작하는 iOS 10 앱 개발 입문, 송종근, 서울 :한빛미디어,2016\n★(스위프트로 시작하는) 아이폰 앱 개발 교과서 / 모리, 요시나오 / 파주 :위키북스,2016\n(예제가 가득한) iOS 프로그래밍 :iOS SDK 7.X, 8.X / Xcode 6.X / 김은철 / 서울 :정보문화사,2015\n★★(꼼꼼한 재은씨의) Swift :문법편 / 이재은 / 부천 :루비페이퍼,2017\nKotlin (핵심 문법과 예제로 배우는) 코틀린 / 이난주 / 서울 :로드북,2017\n★(오준석의) 안드로이드 생존코딩 :코틀린 편 / 오준석 / 서울 :한빛미디어,2018\n안드로이드 with Kotlin 앱 프로그래밍 가이드 | 안귀정 지음 | 아이콕스 | 2019 |\n(자바 개발자를 위한) KOTLIN / 박중수 / 서울 :DIGITAL BOOKS,2017\n(핵심만 골라 배우는) 코틀린 프로그래밍 =Kotlin programming / 심재철 / 파주 :제이펍,2018\n코드작성 방법론 프로그래머가 알아야 할 97가지 / Henney, Kevlin / 고양 :지앤선,2012.\n★클린 코더 :단순 기술자에서 진정한 소프트웨어 장인이 되기까지 / Martin, Robert C / 서울 :에이콘,2016.\n읽기 좋은 코드가 좋은 코드다 / Boswell, Dustin / 서울 :한빛미디어,2012.\n★★좋은 코딩 나쁜 코딩 =Good coding bad coding :읽기 쉬운 코드가 좋은 코드다 / 박진수 / 서울 :한빛미디어,2004.\n훌륭한 프로그래머 되는 법 :프로젝트와 팀을 성공으로 이끄는 선배 개발자의 노하우 / Goodliffe, Pete / 서울 :한빛미디어,2015.\n(다시 시작하는) 프로그래밍 / Foote, Steven / 서울 :인사이트,2015.\n★★(더 나은 코딩을 위한,) 코딩을 지탱하는 기술 :원리로 깨우치는 프로그래밍 기법 / 니시오, 히로카즈 / 서울 :비제이퍼블릭,2013.\n좋은 코드를 작성하는 기술 :읽기 쉽고 유지보수가 쉬운 프로그래밍 작성법 / 아가타,도시타카 / 파주 :제이펍,2011.\n★유지보수하기 어렵게 코딩하는 방법: 평생 개발자로 먹고 살 수 있다, 로에디 그린, 한빛출판사, 2012\n성공하는 프로그래밍 공부법, 박재성, 파주 :로드북,2018.\n객체지향 일반 객체지향의 사실과 오해 :역할, 책임, 협력 관점에서 본 객체지향 =The essence of object-orientation : roles, responsibilities, and collaborations / 조영호 / 파주 :위키북스,2015.\n★성공과 실패를 결정하는 1％의 객체 지향 원리 =How objects work / 아끼라,히라사와 / 고양 :성안당,2005.\n(전병선의)객체지향 이야기 / 전병선 / 서울 :와우북스,2008.\n버전관리 ★★(만들면서 배우는) Git GitHub 입문 | 윤웅식 지음 | 한빛미디어 | 2015 |\n프로 Git :그림으로 이해하는 Git의 작동 원리와 사용법 / Chacon, Scott / 서울 :인사이트,2016\n게임 일반 게이미피케이션 :웹과 모바일 앱에 게임 기법 불어넣기 / Zichermann, Gabe / 서울 :한빛미디어,2012.\n그래도 우리는 게임을 만든다 :게임 업계 입문을 꿈꾸는 젊은이들의 필독서! / 유영욱 / 서울 :보리별,2010.\n게임회사 이야기 :게임보다 더 재미있는, 게임 만드는 이야기 / 이수인 / 의왕 :에이콘출판주식회사,2005.\n(게임 만드는 사람들의) 리얼 수다 :개발 경력 도합 150년, 게임 개발자 17인을 만나다 / 박민영 / 서울 :한빛미디어,2014.\n세계 최고의 게임 크리에이터 9인의 이야기 | 김정남 ; 김정현 공저 | 대림 | 2006 |\n게임왕국 일본을 건설한 거인들 | 타키타 세이이치로 저 ; 김상호 역 | 게임문화 | 2001 |\n그래도 우리는 스마트폰게임을 만든다 | 유영욱 지음 | 보리별 | 2012 |\n게임 크리에이터가 알아야 할 97가지:크리에이티브한 게임 만들기 | 요시오카 나오토 엮음;정대영 옮김 | 지앤선 | 2014 |\n초패미컴 :게임은 아직도 패미컴을 뛰어넘지 못했다!! | 저자: 타네 키요시,야마모토 신이치 | 에이케이 커뮤니케이션즈 | 2014 |\n왜 게임에 빠질까 :사람을 유혹하는 게임의 심리학 / 와타나베, 슈우지 / 서울 :길벗,2014.\n위대한 게임의 탄생. 3 / 좋은 게임을 넘어 위대한 게임으로 | 박일 | 지앤선 | 2013 |\n위대한 게임 위대한 기획자 | 박찬일,최기운 [공]지음 | 한빛미디어 | 2014 |\n라프 코스터의 재미이론, Koster, Raph, 서울 :길벗,2017.\n게임 프로그래머로 산다는 것 | 김성완 [외]지음 | 로드북 | 2016 |\n게임 디자인 ★★(조립×분해)게임 디자인 : 룰을 통해 익히는 게임 디자인 | 와타나베 쿠니아키 지음;야마이 그림 | 비즈앤비즈 | 2016 |\n★터치스크린 모바일 게임 디자인:아이디어 구상부터 스토리텔링, 마케팅까지 | 스콧 로저스 지음;권혜정 옮김 | 에이콘출판 | 2014 |\n게임 개발 (마인크래프트로 배우는) 파이썬 프로그래밍 / Richardson, Craig / 파주 :제이펍,2016.\n★나만의 Python game 만들기 / Sweigart, Al / 서울 :정보문화사,2014.\n★Python과 Pygame으로 게임 만들기 / Sweigart, Al / 서울 :정보문화사,2014.\n★스위프트로 배우는 맨 처음 아이폰 앱 코딩 | 글로리아 윈퀴스트;매트 매카시 [공]지음 | 동아엠앤비 | 2018 |\n★스위프트로 만드는 게임 개발 :스위프트를 활용한 게임 개발부터 출시까지 / Haney, Stephen / 서울 :에이콘,2017\n★(Unity)왕초보 따라하여 게임 만들기 / 박중수 / 서울 :무지개터,2012.\n유니티 5로 만드는 3D/2D 스마트폰 게임 개발 / 요시야, 미키토 / 파주 :제이펍,2016\n마이크로 컨트롤러 아두이노 101 :아두이노 입문자에게 필요한 모든 것 / 서영배 / 서울 :한빛미디어,2016.\n인공지능 ★(처음 만나는) 머신러닝과 딥러닝 :C언어로 구현하며 익히는 기본 개념 / 오다카, 도모히로 / 부천 :프리렉,2017\n★(재미있게 알아보는) 인공지능 70 :AI 키워드 / 미야케, 요이치로 / 파주 :제이펍,2017\n소프트웨어 공학 (우리가 미처 알지 못한)소프트웨어 공학의 사실과 오해 / Glass, Robert L / 서울 :인사이트,2004.\n★피플웨어, DeMarco, Tom, 서울 :인사이트,2014.\n★프로그래밍 심리학 | 제럴드 와인버그 지음;조상민 옮김 | 인사이트 | 2013 |\n에세이 (팟캐스트) 나는 프로그래머다 2 / 임백준 / 서울 :한빛미디어,2016.\n(임백준의) 대살개문 :대한민국을 살리는 개발자 문화 / 임백준 / 서울 :한빛미디어,2016.\n(세상을 뒤흔든)프로그래머들의 비밀 :이 시대 최고의 프로그래머 14인 직격 인터뷰 / Burns, Ed / 서울 :정보문화사,2010.\n소프트웨어, 누가 이렇게 개떡 같이 만든 거야 :사용성을 제대로 이해하는 유쾌한 통찰 / Platt, David S / 서울 :인사이트 :insight,2008.\n(코딩 호러의) 이펙티브 프로그래밍 :스택 오버플로우 공동 창립자가 알려주는 소프트웨어 개발의 비밀 / Atwood, Jeff / 파주 :위키북스,2013.\n벤츠 타는 프로그래머 :행복한 프로그래밍을 위한 어느 선배 개발자의 조언 / 정금호 / 서울 :제이펍,2013.\n(코딩 호러가 들려주는) 진짜 소프트웨어 개발 이야기 / Atwood, Jeff / 파주 :위키북스,2013.\n(조엘이 엄선한)소프트웨어 블로그 베스트 29선 / Spolsky, Joel / 의왕 :에이콘,2006.\n★사랑하지 않으면 떠나라! / Fowler, Chad / 서울 :인사이트,2008.\n★프로그래머의 길, 멘토에게 묻다 / Hoover, Dave H / 서울 :인사이트,2010.\n소프트 스킬 :평범한 개발자의 비범한 인생 전략 71가지 / Sonmez, John Z / 서울 :길벗,2015.\n소프트웨어 장인 :프로페셔널리즘/실용주의/자부심 / Mancuso, Sandro / 서울 :길벗,2015.\n★프로그래머가 되기 전에 알았더라면 좋았을 것들 | 지은이: 고마타 미쓰유키 ;옮긴이: 김훈 | 스포트라잇북 | 2015.\n(팟캐스트)나는 프로그래머다 | 임백준,정도현 | 한빛미디어 | 2016 |\n(개발자를 위한) 하룻밤에 읽는 Go 언어 이야기, 신제용, 서울 :한빛미디어,2015.\n프로그래머, 열정을 말하다, Fowler, Chad, 서울 :인사이트,2012.\n역사 속의 소프트웨어 오류 :부실한 소프트웨어가 초래한 위험천만한 사건 사고들, 김종하, 의왕 :에이콘,2014.\n꾸준히, 자유롭게, 즐겁게: 한국 오픈 소스 개발자들 이야기 | 송우일 인터뷰어 | 인사이트 | 2013 |\n★프로그래머로 사는 법 :프로그래머의 길을 걸어가는 당신을 위한 안내서, Lightstone, Sam, 서울 :한빛미디어,2012.\n★(The) nature of software development / Jeffries, Ron / 서울 :한빛미디어,2017\n★파이썬 핵심 개발자들과의 인터뷰 / Driscoll, Michael / 서울 :터닝포인트,2019\n★커리어 스킬 =Career skills :완벽한 개발자 인생 로드맵 / Sonmez, John / 서울 :길벗,2019\n비즈니스 인사이트 앱스토어 골드러시 :앱스토어에서 누구나 하루에 3천만 원 벌 수 있다! / 정태훈 / 서울 :이지북,2010.\n소프트웨어 전쟁 =The software war, 백일승, 성남 :더하기북스,2015\n미래를 바꿀 IT 과학이야기 - 비트코인, 웨어러블, 사물인터넷, 3D프린팅, 가상현실, 드론, 무선통신 l 누구나 읽을 수 있는 IT 과학이야기 1 | 이재영 (지은이) | 로드북 | 2014\n내 아이디어가 앱 이 되는법 : 앱 기획 가이드 | 김경홍 지음 | 길벗 | 2012 |\n돈버는 아이폰 앱은 따로 있다 | 이정소프트 지음 | 정보문화사 | 2010 |\n앱만장자 | 크리스 스티븐스 지음;김지량 옮김 | 제이펍 | 2012 |\n1등 아이폰 애플리케이션의 비밀 | 김용민 外 저 | 영진닷컴 | 2010 |\n","date":"2022-11-09T16:15:53+09:00","permalink":"https://cliearl.github.io/posts/etc/programming-books/","title":"프로그래밍 관련서적"},{"content":"기존 시놀로지 webstation에서 돌리고 있는 텍스트큐브 블로그가 있었는데 DSM이 7.0으로 업그레이드하면서 PHP 5를 사용할 수 없게 되었다. 텍스트큐브는 PHP 5.6에서 잘 돌아가지만 7.0으로 올리면 여러가지 문제가 생겼기에 그냥 쓰고 있었다.\n그런데 이번에 DSM을 7.0으로 올릴 수 밖에 없는 상황이 되었고 여러가지로 찾아본 결과 역시 DSM 7.0에서 PHP 5를 사용하는 방법은 없었기에 텍스트큐브 블로그를 도커에 띄워서 쓰기로 했다. 다음은 내가 수행한 작업내역.\ntextcube 도커 띄우기 https://registry.hub.docker.com/r/nacyot/textcube/ 위 이미지를 사용해 컨테이너 띄우고 리버스 프록시 설정. 컨테이너 옵션은 따로 건들 것이 없음\n터미널에서 시놀로지에 ssh로 접속 1 2 $ ssh ID@IP $ sudo -i DB 연결 기존 mariadb 정보를 사용해 연결\n도커 컨테이너 ID 확인 1 $ docker ps -a 도커 컨테이너에 이미지 파일 복사 1 $ docker cp /volume1/USER/attach/1 [CONTAINER ID]:/var/www/html/attach 도커 컨테이너 접속 1 $ docker exec -it [CONTAINER ID] /bin/bash 이미지 파일 폴더의 권한 변경 1 $ chmod -R 777 1 ","date":"2022-11-09T15:53:08+09:00","permalink":"https://cliearl.github.io/posts/linux/migrate-textcube-to-docker/","title":"텍스트큐브를 도커로 마이그레이션하기"},{"content":"이번 포스팅에서는 buildSrc가 적용된 Gradle에서 디펜던시 버전을 체크하는 방법에 대해 알아보도록 하겠습니다.\n안드로이드 스튜디오는 프로젝트의 디펜던시에 대해 다음 린트를 실행시키기 때문에 새 버전이 있을 경우 자동으로 알림을 받을 수 있지만, dependency 추가에 buildSrc를 적용하면 이 린트 기능을 활용할 수 없게 됩니다.\n1 Editor \u0026gt; Inspections \u0026gt; Android \u0026gt; Lint \u0026gt; Correctness \u0026gt; Newer Library Versions Available 이런 문제를 해결하기 위해서 여기서는 IDE의 기능에 관계없이 디펜던시 버전을 체크해주는 Gradle Versions Plugin을 사용하는 방법에 대해 알아보도록 하겠습니다.\n여기서는 저의 Modern Android Development 인프런 강의에서 만들어 본 BookSearchApp에 기능을 적용해 보도록 하겠습니다. 우선은 프로젝트 레벨의 build.gradle에 플러그인을 추가합니다.\n1 2 3 plugins { id(\u0026#34;com.github.ben-manes.versions\u0026#34;) version \u0026#34;0.43.0\u0026#34; } 다음은 네트워크에서 아티팩트 정보를 받아온 뒤 안정버전인지 여부를 판정하는 함수를 추가합니다.\n1 2 3 4 5 6 fun isNonStable(version: String): Boolean { val stableKeyword = listOf(\u0026#34;RELEASE\u0026#34;, \u0026#34;FINAL\u0026#34;, \u0026#34;GA\u0026#34;).any { version.toUpperCase().contains(it) } val regex = \u0026#34;^[0-9,.v-]+(-r)?$\u0026#34;.toRegex() val isStable = stableKeyword || regex.matches(version) return isStable.not() } 다음은 디펜던시 버전을 체크하는 태스크를 정의합니다. 제한사항을 rejectVersionIf로 간편하게 정의할 수도 있고 full syntax를 써서 정의할 수도 있습니다. 또한 옵션을 정의할 수도 있는데요, 각 프로퍼티의 기능은 이름을 보면 잘 알 수 있게 되어 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import com.github.benmanes.gradle.versions.updates.DependencyUpdatesTask tasks.named\u0026lt;DependencyUpdatesTask\u0026gt;(\u0026#34;dependencyUpdates\u0026#34;) .configure { // isStable에 해당되지 않는 모든 버전을 거부 rejectVersionIf { isNonStable(candidate.version) } // optional parameters checkForGradleUpdate = true outputFormatter = \u0026#34;json\u0026#34; outputDir = \u0026#34;build/dependencyUpdates\u0026#34; reportfileName = \u0026#34;report\u0026#34; } } 그리고나서 dependencyUpdate를 실행시키면 콘솔 화면에 체크 결과가 출력되고, 옵션에 설정된 json 파일도 생성되는 것을 확인할 수 있습니다.\n1 ./gradlew dependencyUpdate 인프런 강의에서 만들어 본 BookSearchApp의 디펜던시를 체크한 결과는 다음과 같습니다. 프로젝트가 마무리 된 2022년 4월 이후로 많은 업데이트가 있었던 것을 확인할 수 있네요. 나머지는 업데이트가 필요한 디펜던시를 찾아 버전을 올리면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 ------------------------------------------------------------ : Project Dependency Updates (report to plain text file) ------------------------------------------------------------ The following dependencies are using the latest milestone version: - androidx.datastore:datastore-preferences:1.0.0 - androidx.hilt:hilt-compiler:1.0.0 - androidx.hilt:hilt-work:1.0.0 - androidx.paging:paging-runtime-ktx:3.1.1 - androidx.recyclerview:recyclerview:1.2.1 - androidx.test:core:1.4.0 - androidx.test:runner:1.4.0 - androidx.test.espresso:espresso-contrib:3.4.0 - androidx.test.espresso:espresso-core:3.4.0 - androidx.test.ext:junit:1.1.3 - androidx.test.ext:truth:1.4.0 - androidx.work:work-runtime-ktx:2.7.1 - com.google.android.libraries.mapsplatform.secrets-gradle-plugin:com.google.android.libraries.mapsplatform.secrets-gradle-plugin.gradle.plugin:2.0.1 - com.squareup.retrofit2:converter-moshi:2.9.0 - com.squareup.retrofit2:retrofit:2.9.0 - junit:junit:4.13.2 - org.hamcrest:hamcrest:2.2 The following dependencies have later milestone versions: - androidx.activity:activity-ktx [1.4.0 -\u0026gt; 1.6.1] https://developer.android.com/jetpack/androidx/releases/activity#1.6.1 - androidx.appcompat:appcompat [1.4.1 -\u0026gt; 1.5.1] https://developer.android.com/jetpack/androidx/releases/appcompat#1.5.1 - androidx.constraintlayout:constraintlayout [2.1.3 -\u0026gt; 2.1.4] http://tools.android.com - androidx.core:core-ktx [1.7.0 -\u0026gt; 1.9.0] https://developer.android.com/jetpack/androidx/releases/core#1.9.0 - androidx.databinding:viewbinding [7.1.3 -\u0026gt; 7.3.1] - androidx.fragment:fragment-ktx [1.4.1 -\u0026gt; 1.5.4] https://developer.android.com/jetpack/androidx/releases/fragment#1.5.4 - androidx.lifecycle:lifecycle-runtime-ktx [2.4.1 -\u0026gt; 2.5.1] https://developer.android.com/jetpack/androidx/releases/lifecycle#2.5.1 - androidx.lifecycle:lifecycle-viewmodel-ktx [2.4.1 -\u0026gt; 2.5.1] https://developer.android.com/jetpack/androidx/releases/lifecycle#2.5.1 - androidx.lifecycle:lifecycle-viewmodel-savedstate [2.4.1 -\u0026gt; 2.5.1] https://developer.android.com/jetpack/androidx/releases/lifecycle#2.5.1 - androidx.navigation:navigation-fragment-ktx [2.4.1 -\u0026gt; 2.5.3] https://developer.android.com/jetpack/androidx/releases/navigation#2.5.3 - androidx.navigation:navigation-ui-ktx [2.4.1 -\u0026gt; 2.5.3] https://developer.android.com/jetpack/androidx/releases/navigation#2.5.3 - androidx.navigation.safeargs.kotlin:androidx.navigation.safeargs.kotlin.gradle.plugin [2.4.1 -\u0026gt; 2.5.3] https://developer.android.com/jetpack/androidx/releases/navigation#2.5.3 - androidx.room:room-compiler [2.4.2 -\u0026gt; 2.4.3] https://developer.android.com/jetpack/androidx/releases/room#2.4.3 - androidx.room:room-ktx [2.4.2 -\u0026gt; 2.4.3] https://developer.android.com/jetpack/androidx/releases/room#2.4.3 - androidx.room:room-paging [2.4.2 -\u0026gt; 2.4.3] https://developer.android.com/jetpack/androidx/releases/room#2.4.3 - androidx.room:room-runtime [2.4.2 -\u0026gt; 2.4.3] https://developer.android.com/jetpack/androidx/releases/room#2.4.3 - com.android.application:com.android.application.gradle.plugin [7.1.3 -\u0026gt; 7.3.1] https://developer.android.com/studio/build - com.android.library:com.android.library.gradle.plugin [7.1.3 -\u0026gt; 7.3.1] https://developer.android.com/studio/build - com.google.android.material:material [1.5.0 -\u0026gt; 1.7.0] https://github.com/material-components/material-components-android - com.google.dagger:hilt-android [2.41 -\u0026gt; 2.44] https://github.com/google/dagger - com.google.dagger:hilt-android-compiler [2.41 -\u0026gt; 2.44] https://github.com/google/dagger - com.google.dagger:hilt-android-testing [2.41 -\u0026gt; 2.44] https://github.com/google/dagger - com.google.dagger:hilt-compiler [2.41 -\u0026gt; 2.44] https://github.com/google/dagger - com.google.dagger.hilt.android:com.google.dagger.hilt.android.gradle.plugin [2.41 -\u0026gt; 2.44] https://github.com/google/dagger - com.squareup.moshi:moshi [1.13.0 -\u0026gt; 1.14.0] https://github.com/square/moshi/ - com.squareup.moshi:moshi-kotlin-codegen [1.13.0 -\u0026gt; 1.14.0] https://github.com/square/moshi/ - com.squareup.okhttp3:logging-interceptor [4.9.3 -\u0026gt; 4.10.0] https://square.github.io/okhttp/ - com.squareup.okhttp3:okhttp [4.9.3 -\u0026gt; 4.10.0] https://square.github.io/okhttp/ - io.coil-kt:coil [1.4.0 -\u0026gt; 2.2.2] https://github.com/coil-kt/coil - org.jacoco:org.jacoco.ant [0.8.3 -\u0026gt; 0.8.8] http://jacoco.org - org.jetbrains.kotlin:kotlin-annotation-processing-gradle [1.6.10 -\u0026gt; 1.7.20] https://kotlinlang.org/ - org.jetbrains.kotlin:kotlin-parcelize-compiler [1.6.10 -\u0026gt; 1.7.20] https://kotlinlang.org/ - org.jetbrains.kotlin:kotlin-parcelize-runtime [1.6.10 -\u0026gt; 1.7.20] https://kotlinlang.org/ - org.jetbrains.kotlin:kotlin-stdlib [1.6.10 -\u0026gt; 1.7.20] https://kotlinlang.org/ - org.jetbrains.kotlin.plugin.serialization:org.jetbrains.kotlin.plugin.serialization.gradle.plugin [1.6.10 -\u0026gt; 1.7.20] https://kotlinlang.org/ - org.jetbrains.kotlinx:kotlinx-coroutines-android [1.6.0 -\u0026gt; 1.6.4] https://github.com/Kotlin/kotlinx.coroutines - org.jetbrains.kotlinx:kotlinx-coroutines-core [1.6.0 -\u0026gt; 1.6.4] https://github.com/Kotlin/kotlinx.coroutines - org.jetbrains.kotlinx:kotlinx-coroutines-test [1.6.2 -\u0026gt; 1.6.4] https://github.com/Kotlin/kotlinx.coroutines - org.jetbrains.kotlinx:kotlinx-serialization-json [1.3.2 -\u0026gt; 1.4.1] https://github.com/Kotlin/kotlinx.serialization - org.robolectric:robolectric [4.8.1 -\u0026gt; 4.9] http://robolectric.org Failed to determine the latest version for the following dependencies (use --info for details): - com.github.ben-manes.versions:com.github.ben-manes.versions.gradle.plugin - org.jetbrains.kotlin.android:org.jetbrains.kotlin.android.gradle.plugin Gradle release-candidate updates: - Gradle: [7.2 -\u0026gt; 7.5.1 -\u0026gt; 7.6-rc-1] Generated report file build/dependencyUpdates/report.json 이렇게 해서 Gradle에서 사용된 디펜던시의 버전을 체크하는 법에 대해 알아보았습니다.\n","date":"2022-11-05T22:06:34+09:00","permalink":"https://cliearl.github.io/posts/android/buildsrc-gradle-dependency-update/","title":"buildSrc를 적용한 Gradle의 Dependency Update하기"},{"content":"이번 포스팅에서는 내 장비의 안드로이드 스튜디오 빌드능력을 벤치마킹 해 보겠습니다.\n2020년 Apple에서 M시리즈 칩셋을 탑재한 맥북이 발표된 이후 밝혀진 엄청난 전성비와 성능은 세상을 놀라게 했습니다. 물론 저도 마찬가지였구요.\n저는 2018년형 15인치 MacBook Pro를 사용하고 있는데요 2.2GHz 인텔 코어 i7과 16GB 메모리를 탑재하였고 외장 그래픽으로 Radeon Pro 555X 4 GB가 추가되어 있는 사양입니다. 당시에는 거금을 주고 구입한 머신이지만 에뮬레이터를 하나 띄우고 영상을 녹화하면서 안드로이드 프로젝트를 하나 빌드하면 처리가 느려져서 녹화영상의 프레임이 뚝뚝 떨어지는 문제가 있습니다.\nM1은 성능 향상에 힘입어 프로젝트 빌드 속도가 빨라진다는 소문이 있었지만 출시 당시에는 인텔용 안드로이드 스튜디오를 ARM에서 강제로 돌려야했기 때문에 한계가 있었지만 Apple Silicon 전용 안드로이드 스튜디오가 발표되고 나서는 퍼포먼스를 정확히 비교할 수 있게 되었습니다.\nModern MacBook benchmarks for Android development 블로그에서 실험한 결과를 보면 M1 Max는 기존 i7에 비해 150~200%까지 성능 향상이 있는 것 같네요.\n자 그럼 제 컴퓨터의 빌드성능을 알아보도록 하겠습니다. 여기서는 AndroidStudioBenchmark (Firefox Focus for Android) 저장소를 사용해서 테스트 해 볼 겁니다.\n이 저장소는 안드로이드용 Firefox Focus를 빌드하는데 걸리는 시간을 서로 비교해 봄으로써 내 머신의 빌드성능을 가늠할 수 있게 해 줍니다. 다른 사람들이 실행한 벤치마크 결과는 다음 엑셀 파일에서 확인할 수 있습니다.\nhttps://docs.google.com/spreadsheets/d/1AeeT_54b2VnovN4ikIsglh2Sc7U0bWxAarDKmGAJFtg/\n그럼 저장소를 다운받고 빌드를 3회 실행시켜서 걸리는 시간을 체크해 보도록 하겠습니다.\n1회 클린 빌드 : 1분 42초 2회째 : 36초 3회째 : 32초 생각보다 빌드시간이 짧게 나왔네요. 안드로이드 스튜디오 버전이 올라가면서 빌드과정을 많이 최적화 한 것 같습니다. M2도 나온 시점이라 저는 내년에 나올 것으로 예상되는 M2 Pro를 기다리고 있습니다만, 과연 어느정도 성능으로 출시될지 기대가 되네요. 요즘 올라가는 환율은 걱정이 되지만요..\n","date":"2022-09-25T11:15:54+09:00","permalink":"https://cliearl.github.io/posts/android/build-performance-benchmark/","title":"내 장비의 안드로이드 스튜디오 빌드능력 벤치마킹하기"},{"content":"이번 포스팅에서는 Dokka로 프로젝트를 문서화하는 법에 대해 알아보도록 하겠습니다.\nDokka는 코틀린과 자바로 작성된 프로젝트의 코드를 분석해서 문서화해주는 플러그인인데요 Java의 Javadoc과 Kotlin의 Kdoc 구조를 분석할 수 있습니다. 문서는 Javadoc, HTML 형식으로 출력할 수 있습니다.\n그러면 안드로이드 스튜디오의 예제 프로젝트에 Dokka를 적용해 보도록 하겠습니다. 우선 New project \u0026gt; Login Activity를 선택합니다. 이 프로젝트는 약간의 구조화가 되어 있고 클래스마다 주석이 달려있기 때문에 Dokka의 예제로 사용하기 좋아보인다는 이유로 당첨되었습니다.\n다음은 build.gradle에 플러그인을 추가합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Top-level build.gradle plugins { id \u0026#34;org.jetbrains.dokka\u0026#34; version \u0026#34;1.7.10\u0026#34; } // App-level build.gradle plugins { id \u0026#34;org.jetbrains.dokka\u0026#34; } android { ... dokkaHtml.configure { dokkaSourceSets { named(\u0026#34;main\u0026#34;) { noAndroidSdkLink.set(false) } } } } 플러그인을 설치한 뒤 다음 커맨드를 실행시키면 문서가 생성됩니다.\n1 ./gradlew dokka${format} Html 문서를 만들고 싶은 경우 ./gradlew dokkaHtml, Javadoc 문서를 작성하고 싶은 경우 ./gradlew dokkaJavadoc을 실행시키면 됩니다. 여기서는 두 타입의 문서를 모두 작성해 보겠습니다. 커맨드를 실행하면 app \u0026gt; build \u0026gt; dokka 폴더에 파일이 생성되기 때문에 index.html을 브라우저에서 실행시키면 됩니다. 그러면 안드로이드 프로젝트 구조에 따라 Html이 보이며 클래스에 달아준 주석의 내용이 같이 표시되게 됩니다.\n여기서는 noAndroidSdkLink.set(false) 옵션을 적용해서 Dokka 문서가 Android developers의 문서와 연결되지 않도록 했는데 이 외에도 다음과 같이 많은 옵션이 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 import org.jetbrains.dokka.gradle.DokkaTask val dokkaHtml by getting(DokkaTask::class) { outputDirectory.set(buildDir.resolve(\u0026#34;dokka\u0026#34;)) // Set module name displayed in the final output moduleName.set(\u0026#34;moduleName\u0026#34;) // Use default or set to custom path to cache directory // to enable package-list caching // When this is set to default, caches are stored in $USER_HOME/.cache/dokka cacheRoot.set(file(\u0026#34;default\u0026#34;)) // Suppress obvious functions like default toString or equals. Defaults to true suppressObviousFunctions.set(false) // Suppress all inherited members that were not overriden in a given class. // Eg. using it you can suppress toString or equals functions but you can\u0026#39;t suppress componentN or copy on data class. To do that use with suppressObviousFunctions // Defaults to false suppressInheritedMembers.set(true) // Used to prevent resolving package-lists online. When this option is set to true, only local files are resolved offlineMode.set(false) dokkaSourceSets { configureEach { // Or source set name, for single-platform the default source sets are `main` and `test` // Used when configuring source sets manually for declaring which source sets this one depends on dependsOn(\u0026#34;otherSourceSetName\u0026#34;) // Used to remove a source set from documentation, test source sets are suppressed by default suppress.set(false) // Use to include or exclude non public members includeNonPublic.set(false) // Do not output deprecated members. Applies globally, can be overridden by packageOptions skipDeprecated.set(false) // Emit warnings about not documented members. Applies globally, also can be overridden by packageOptions reportUndocumented.set(true) // Do not create index pages for empty packages skipEmptyPackages.set(true) // This name will be shown in the final output displayName.set(\u0026#34;JVM\u0026#34;) // Platform used for code analysis. See the \u0026#34;Platforms\u0026#34; section of this readme platform.set(org.jetbrains.dokka.Platform.jvm) // Property used for manual addition of files to the classpath // This property does not override the classpath collected automatically but appends to it classpath.from(file(\u0026#34;libs/dependency.jar\u0026#34;)) // List of files with module and package documentation // https://kotlinlang.org/docs/reference/kotlin-doc.html#module-and-package-documentation includes.from(\u0026#34;packages.md\u0026#34;, \u0026#34;extra.md\u0026#34;) // List of files or directories containing sample code (referenced with @sample tags) samples.from(\u0026#34;samples/basic.kt\u0026#34;, \u0026#34;samples/advanced.kt\u0026#34;) // By default, sourceRoots are taken from Kotlin Plugin and kotlinTasks, following roots will be appended to them // Repeat for multiple sourceRoots sourceRoots.from(file(\u0026#34;src\u0026#34;)) // Specifies the location of the project source code on the Web. // If provided, Dokka generates \u0026#34;source\u0026#34; links for each declaration. // Repeat for multiple mappings sourceLink { // Unix based directory relative path to the root of the project (where you execute gradle respectively). localDirectory.set(file(\u0026#34;src/main/kotlin\u0026#34;)) // URL showing where the source code can be accessed through the web browser remoteUrl.set(java.net.URL( \u0026#34;https://github.com/cy6erGn0m/vertx3-lang-kotlin/blob/master/src/main/kotlin\u0026#34;)) // Suffix which is used to append the line number to the URL. Use #L for GitHub remoteLineSuffix.set(\u0026#34;#L\u0026#34;) } // Used for linking to JDK documentation jdkVersion.set(8) // Disable linking to online kotlin-stdlib documentation noStdlibLink.set(false) // Disable linking to online JDK documentation noJdkLink.set(false) // Disable linking to online Android documentation (only applicable for Android projects) noAndroidSdkLink.set(false) // Allows linking to documentation of the project\u0026#34;s dependencies (generated with Javadoc or Dokka) // Repeat for multiple links externalDocumentationLink { // Root URL of the generated documentation to link with. The trailing slash is required! url.set(URL(\u0026#34;https://example.com/docs/\u0026#34;)) // If package-list file is located in non-standard location // packageListUrl = URL(\u0026#34;file:///home/user/localdocs/package-list\u0026#34;) } // Allows to customize documentation generation options on a per-package basis // Repeat for multiple packageOptions // If multiple packages match the same matchingRegex, the longuest matchingRegex will be used perPackageOption { // will match kotlin and all sub-packages of it matchingRegex.set(\u0026#34;kotlin($|\\\\.).*\u0026#34;) // All options are optional skipDeprecated.set(false) reportUndocumented.set(true) // Emit warnings about not documented members includeNonPublic.set(false) } // Suppress a package perPackageOption { matchingRegex.set(\u0026#34;\u0026#34;\u0026#34;.*\\.internal.*\u0026#34;\u0026#34;\u0026#34;) // will match all .internal packages and sub-packages suppress.set(true) } // Include generated files in documentation // By default Dokka will omit all files in folder named generated that is a child of buildDir suppressGeneratedFiles.set(false) } // Configures a plugin separately from the global configuration pluginConfiguration\u0026lt;PluginClass, ConfigurationClass\u0026gt;{ // values } } } 이렇게 해서 Dokka로 프로젝트를 문서화하는 법에 대해 알아보았습니다.\n","date":"2022-09-11T09:44:29+09:00","permalink":"https://cliearl.github.io/posts/android/dokka-example/","title":"Dokka로 프로젝트 문서화하기"},{"content":"이번 포스팅에서는 자바의 리플렉션에 대해 알아보도록 하겠습니다.\n1 val bookSearchViewModel = ViewModelProvider(this, factory)[BookSearchViewModel::class.java] 위 코드의 의미는 런타임에 뷰모델을 만들기 위해 BookSearchViewModel 클래스를 ViewModelProvider에게 전달해준다는 의미입니다. 이 때 ViewModelProvider의 get 메소드는 다음과 같이 Class를 전달받아서 ViewModelStoreOwner에게 ViewModel을 반환하게 됩니다.\n1 2 @MainThread open operator fun \u0026lt;T : ViewModel\u0026gt; get(modelClass: Class\u0026lt;T\u0026gt;): T ViewModelProvider는 컴파일 타임이 아니라 런타임에 실행되어 BookSearchViewModel을 만들어야 하는데 런타임에는 BookSearchViewModel의 클래스 정보를 알 수가 없습니다.\n여기서 ::은 자바의 리플렉션 문법인데, 리플렉션은 클래스 타입을 몰라도 그 클래스의 속성에 접근할 수 있게 해주는 API입니다. 그러니까 위의 코드에서는 리플렉션을 통해 ViewModelProvider에게 BookSearchViewModel 클래스 정보를 전달해 준 것이고 따라서 런타임에 BookSearchViewModel 인스턴스가 만들어지게 된 것입니다.\n리플렉션 작업은 java.lang.reflect라는 패키지에 의해 수행되는데 다음과 같은 프로퍼티에 대해 접근할 수 있습니다.\n출처 : https://docstore.mik.ua/orelly/java/fclass/ch13_01.htm\n리플렉션을 이용하면 이렇게 런타임에 클래스 정보를 다룰 수 있지만 다음과 같은 단점도 있기 때문에 제한적으로만 사용하는 것이 좋습니다.\n컴파일 불가 : 컴파일시 타입 검사나 예외 검사를 할 수 없어 런타임에 문제를 야기할 수 있습니다. 성능 저하 : 리플렉션을 통한 작업은 일반 작업보다 훨씬 느립니다. 내부 노출 : 리플렉션을 사용하면 접근 지시자를 무시할 수 있기 때문에 추상화가 깨지고 플랫폼 업그레이드 시 동작이 변경될 수 있습니다. ","date":"2022-08-06T12:14:15+09:00","permalink":"https://cliearl.github.io/posts/android/java-reflection/","title":"자바의 리플렉션이란"},{"content":"이번 영상에서는 의존성 주입에 대해 알아보도록 하겠습니다.\nSOLID 원칙 의존성 주입은 객체지향 프로그래밍의 개념중 하나인데요, 이것을 이해하기 위해 우선은 객체지향 설계의 5대원칙으로 일컬어지는 SOLID 원칙에 대해 알아볼 필요가 있습니다. SOLID 원칙이란 로버트 마틴 선생이 2000년에 Design Principles and Design Patterns에서 주창한 객체 지향 프로그래밍 및 설계의 기본 원칙을, Michael Feathers가 두문자어 기억법을 써서 다섯가지로 정리한 것입니다.\n단일 책임 원칙 (Single responsibility principle, SRP) \u0026ldquo;There should never be more than one reason for a class to change.\u0026rdquo;\n단일 책임 원칙이란 클래스가 여러개의 책임을 갖게 되면, 각 책임마다 클래스를 변경할 수 있는 이유가 생기므로 책임을 단 한 개만 가지도록 설계하라는 뜻입니다.\n예를 들면 네트워크에 접속해서, 암호화된 데이터를 다운로드하고, 데이터를 복호화한 뒤, 파일로 저장하는 Work 클래스가 있다고 하겠습니다. 네 개의 책임 중 하나만 변경이 되어도 이 클래스는 수정되어야 합니다. 또 이 클래스에 연결된 클래스가 있다면 책임 하나의 기능 변경이 일어나도 연결된 모든 클래스가 그에 맞춰 수정되어야 하지요.\nclassDiagram class Work{ -accessToNetwork() -downloadData() -decryptData() -saveAsFile() } 객체가 갖는 책임이 많아질수록 기능 변경은 점점 어려워지게 되므로, 이를테면 Work의 책임을 네 개의 클래스로 나누어 기능을 유연하게 변경할 수 있도록 하라는 것이 단일 책임 원칙입니다.\nclassDiagram Work --|\u003e AccessToNetwork Work --|\u003e DownloadData Work --|\u003e DecryptData Work --|\u003e SaveAsFile class Work{ -accessToNetwork() -downloadData() -decryptData() -saveAsFile() } class AccessToNetwork class DownloadData class DecryptData class SaveAsFile 개방-폐쇄 원칙 (Open-closed principle, OCP) \u0026ldquo;Software entities \u0026hellip; should be open for extension, but closed for modification.\u0026rdquo;\n개방-폐쇄 원칙은 객체를 수정하지 않고도 기능을 확장할 수 있게 설계해야 한다는 뜻입니다. 이게 어떻게 가능할까요?\n예를 들어 네트워크에서 데이터를 읽어오는 DataReader 클래스가 있다고 하겠습니다. 이 때 네트워크에서 데이터를 다운로드하는 기능은 NetworkAccess 클래스로 분리시킵니다. 그리고 DataSource 인터페이스를 만들어서 NetworkAccess가 DataSource를 상속하게 합니다.\nclassDiagram class DataSource{ } DataSource\u003c..DataReader DataSource\u003c|..NetworkAccess 이제 DataReader에 네트워크가 아닌 로컬파일에서 데이터를 읽어오는 기능을 추가하고 싶다고 합시다. 그러면 우리는 로컬 파일에서 데이터를 읽어오는 기능을 가진 FileAccess 클래스를 만들고 FileAccess가 DataSource 인터페이스를 상속하게 하면 됩니다. 그러면 DataReader는 DataSource를 참조하고 있기 때문에 기능을 변경하지 않고도 파일에서 데이터를 읽어오는 기능을 추가할 수 있게 됩니다.\nclassDiagram class DataSource{ } DataSource\u003c..DataReader DataSource\u003c|..NetworkAccess DataSource\u003c|..FileAccess 기능을 확장하는 부분은 인터페이스를 사용해 추상화하고, 새로운 기능의 추가에는 상속(다형성)을 적용함으로써 클래스를 유연하게 변경할 수 있게 되는 것입니다.\n리스코프 치환 원칙 (Liskov substitution principle, LSP) \u0026ldquo;Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.\u0026rdquo;\n리스코프 치환 원칙에 따르면 상위타입 객체가 하위타입 객체로 변환되어도 상위타입을 사용하는 프로그램은 정상적으로 동작해야 합니다.\n잘 알려진 직사각형-정사각형 문제를 예로들어 설명을 해 보겠습니다. 직사각형의 정의는 네 각이 직각인 사각형이고, 정사각형은 네 각이 직각이면서 네 변의 길이가 모두 같은 사각형입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 open class Rectangle { open var width = 0 open var height = 0 val area: Int get() = this.width * this.height } class Square : Rectangle() { override var width: Int get() = super.width set(width) { super.width = width super.height = width } override var height: Int get() = super.height set(height) { super.width = height super.height = height } } 다음은 사각형의 면적을 구하는 코드인데요 Rectangle을 전달하면 문제없이 Assertion이 성공합니다. 그런데 LSP에 따르면 Rectangle의 하위타입인 Square를 전달해도 면적이 정상적으로 구해져야 하는데 그렇지 않으므로 LSP를 위반하게 됩니다.\n1 2 3 4 5 6 7 8 9 10 fun calculateArea(r: Rectangle) { r.width = 2 r.height = 3 assert(r.area == 6) } fun main() { calculateArea(Rectangle()) calculateArea(Square()) } 이것은 개념적으로는 직사각형과 정사각형이 상속관계처럼 보이더라도 실제 구현은 상속관계가 아니기 때문입니다. 그러므로 여기서는 더 추상화된 Shape 객체를 추가로 만들어서 Rectangle과 Square가 모두 Shape를 상속하게 하고 Shape의 면적을 계산하는 함수를 만드는 것이 더 적절합니다.\nclassDiagram Shape \u003c|-- Rectangle Shape \u003c|-- Square class Shape class Rectangle class Square LSP를 위반한다는 것은 하위타입이 상위타입의 명세를 제대로 지키지 않고 있다는 뜻입니다. 만약 상위타입의 코드에서 하위타입을 구분해야 하는 경우, 상위타입으로 치환할 수 없기 때문에 코드 내부에서 instanceOf 를 써야 합니다. 그런데 이렇게 하면 하위타입을 새로 만들때마다 상위타입의 코드를 수정해야 하니 결과적으로 OCP도 깨지기 쉬워져서 기능확장이 어려워지게 됩니다.\n인터페이스 분리 원칙 (Interface segregation principle, ISP) \u0026ldquo;Many client-specific interfaces are better than one general-purpose interface.\u0026rdquo;\n이 문장의 뜻은 구현할 필요가 없는 메소드를 가진 인터페이스를 객체에 사용하지 말라는 뜻입니다. 예를 들어 동물을 표현하는 Animal 인터페이스가 있다고 하겠습니다.\n1 2 3 4 5 interface Animal { fun eat() fun run(from: Where, to: Where) fun fly(from: Where, to: Where) } 그리고 Animal을 구현하는 Eagle과 Lion 클래스를 작성합니다.\n1 2 3 4 5 6 7 8 9 10 11 class Eagle : Animal { override fun eat() = println(\u0026#34;### walk ###\u0026#34;) override fun run(from: Where, to: Where) = println(\u0026#34;### run ###\u0026#34;) override fun fly(from: Where, to: Where) = println(\u0026#34;### fly ###\u0026#34;) } class Lion : Animal { override fun eat() = println(\u0026#34;### walk ###\u0026#34;) override fun run(from: Where, to: Where) = println(\u0026#34;### run ###\u0026#34;) override fun fly(from: Where, to: Where) // 구현 필요 없음 } Eagle은 Animal의 모든 기능을 구현해야하므로 사용에 아무런 문제가 없지만, Lion은 날지도 못하는데 Animal을 상속했기 때문에 의무적으로 fly를 구현해야 합니다. 게다가 만약 fly의 파라메터나 리턴타입같은 사양이 변경될 경우 Lion 클래스는 사용하지도 않는 fly를 그에 따라 수정해야 하는 문제가 발생합니다.\n클라이언트의 입장에서 사용하는 기능만 제공하도록 인터페이스를 분리하라는 것이 ISP의 의도이므로, 여기서는 Animal 인터페이스를 Bird와 Mammal로 분리하여 사용하는 것이 적절하겠죠.\n1 2 3 4 5 6 7 8 9 10 interface Bird { fun eat() fun run(from: Where, to: Where) fun fly(from: Where, to: Where) } interface Mammal { fun eat() fun run(from: Where, to: Where) } 의존성 역전 원칙 (Dependency inversion principle, DIP) \u0026ldquo;Depend upon abstractions, [not] concretions.\u0026rdquo;\nDependency, 의존이란 무엇일까요. 객체 A가 객체 B를 생성하거나 객체 B의 메서드를 호출할 때 A는 B에 의존한다, 혹은 A가 의존성 B를 갖는다고 표현합니다. 다음 그림에서는 Car 클래스가 Engine 클래스에 의존하고 있습니다.\nclassDiagram Car ..\u003e Engine Car : +Engine engine class Engine{ +int fuel +work() } 의존성 역전 원칙에 따르면 상위 레벨 모듈이 하위 레벨 모듈에 의존해서는 안 되고 추상화에 의존해야 한다고 정의합니다. 이게 무슨 말일까요?\n자동차를 예를 들어 설명해 보겠습니다. 자동차는 상위레벨 모듈이고 자동차를 구성하는 엔진, 타이어, 핸들은 하위레벨 모듈이 됩니다. 이제 가솔린 엔진을 탑재한 Car 클래스가 있다고 하겠습니다.\n1 2 3 4 5 6 7 class GasolineEngine { val fuel = \u0026#34;gasoline\u0026#34; } class Car { val engine = GasolineEngine() } 이제 가솔린 엔진을 경유 엔진으로 변경해 보겠습니다. 엔진을 변경하였기 때문에 Car 내부의 코드를 다음과 같이 변경하면 되겠죠.\n1 2 3 4 5 6 7 8 class DieselEngine { val fuel = \u0026#34;diesel\u0026#34; } class Car { // val engine = GasolineEngine() val engine = DieselEngine() } 하지만 의존성 역전 원칙의 핵심은 의존하는 하위레벨 모듈이 변하더라도 상위레벨 모듈은 변하지 않아야 한다는 것입니다. 다시말해 엔진이 GasolineEngine에서 DieselEngine으로 바뀌더라도 Car의 코드는 변하면 안된다는 것이죠. 그럼 어떻게 해야 할까요. 현재 Car는 GasolineEngine에 의존하고 있지만, GasolineEngine은 어디에도 의존하지 않습니다.\nflowchart RL Car --\u003e GasolineEngine; 이 흐름 중간에 다음과 같이 Engine 인터페이스를 도입하겠습니다. 그러면 의존이 없었던 하위레벨 모듈인 GasolineEngine이 역으로 상위레벨 모듈인 Engine에 의존하게 되는 의존관계 역전이 일어나게 됩니다. Car는 Engine에 의존하고 있기 때문에 엔진을 어떻게 갈아끼우더라도 Car의 코드에는 더 이상 변경이 발생하지 않게 되지요. 잘 생각해 보시면 DIP란 결국 OCP의 실현을 돕는 원칙이란 것을 알 수 있습니다.\nclassDiagram class Engine{ } Engine\u003c..Car Engine\u003c|..GasolineEngine Engine\u003c|..DieselEngine 의존성 주입(Dependency Injection, DI) 이제 의존성 주입에 대해 알아보도록 하겠습니다.\n순환의존 의존의 영향은 꼬리에 꼬리를 문 것처럼 전파되는 특징이 있습니다. 그래서 다음과 같은 의존관계가 있을 때 Piston이 변경되면 Engine도 변경되어야 하고 결국 Car도 따라서 변경되게 됩니다.\nflowchart RL Engine --\u003e Piston; Car --\u003e Engine; 그런데 프로그램을 짜다 보면 다음과 같이 의존이 순환되는 경우가 생기기도 합니다. 이런 경우엔 Piston이 변경된 영향으로 다시 Piston 자신이 변경되는 문제가 발생합니다. 이것을 순환참조(Circular reference)라고 하며, 유지보수를 어렵게 만들기 때문에 반드시 피해야 하는 문제입니다.\nflowchart RL Engine --\u003e Piston; Car --\u003e Engine; Piston --\u003e Car; 이 순환 의존을 깨는 원칙중 하나가 앞에서 설명한 의존역전 원칙이고, 의존역전 원칙을 코드로 실현하는 방법 중 하나가 의존성 주입입니다. 그래서 프로그램에 의존성 주입을 적용하면 구조적으로 더 좋아진다고 할 수 있는 것입니다.\n또한 의존성 주입을 사용하게 되면 테스트를 용이하게 수행할 수 있게 되는 장점도 생깁니다. 예를 들면 DieselEngine 의존성을 사용하던 Car 클래스의 엔진을 쉽게 TestEngine으로 갈아낄 수 있게 되는 것이죠.\n다만 개발자가 의존성 주입을 개별적으로 구현하는 것은 번거롭고 까다롭기 때문에 안드로이드에는 DI를 더 용이하게 수행할 수 있는 Dagger, Hilt, Koin, Kodein, Anvil 등의 라이브러리들이 개발되어 있습니다.\n의존성 주입 방식별 구분 의존성 역전 원칙에서 다루었던 예에서는 Car가 DieselEngine 의존을 내부에서 직접 생성했었습니다. 이렇게 되면 의존성 역전 원칙을 위배하게 되고 결과적으로 확장-폐쇄 원칙까지 위반하게 됩니다.\n1 2 3 4 5 6 7 class DieselEngine { val fuel = \u0026#34;diesel\u0026#34; } class Car { val engine = DieselEngine() } 이 구조에 의존성을 주입해 보도록 하겠습니다. 의존성 주입을 실현하는 방식은 생성자 주입 방식과, 메소드 주입 방식 그리고 인터페이스를 통한 주입 방식이 있습니다.\n생성자 주입 방식 생성자 주입 방식은 다음과 같이 클래스를 초기화 하는 시점에서 외부에서 작성한 DieselEngine 객체를 생성자로 주입하는 방식입니다.\n1 2 3 4 5 6 7 8 9 10 11 class DieselEngine { val fuel = \u0026#34;diesel\u0026#34; } class Car(val engine: DieselEngine) { } fun main() { val dieselEngine = DieselEngine() val car = Car(dieselEngine) } 메소드 주입 방식 메소드 주입 방식은 클래스 초기화가 끝난 뒤 어떤 시점에서 setEngine을 실행시켜서 객체를 주입하는 방식입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class DieselEngine { val fuel = \u0026#34;diesel\u0026#34; } class Car { val engine = null private fun setEngine(engine: Engine) { this.engine = engine } } fun main() { val dieselEngine = DieselEngine() val car = Car() car.setEngine(dieselEngine) } 인터페이스를 통한 주입 방식 인터페이스를 통한 주입 방식은 메소드 주입 방식과 유사하나 인터페이스를 통해 의존성을 주입합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 interface DieselEngineInjector { fun inject(dieselEngine: DieselEngine) } class DieselEngine { val fuel = \u0026#34;diesel\u0026#34; } class Car implements DieselEngineInjector { val engine = null override fun inject(dieselEngine: DieselEngine) { this.engine = engine } } fun main() { val dieselEngine = DieselEngine() val car = Car() car.inject(dieselEngine) } 생성자 주입 방식은 필요한 모든 의존객체를 객체를 생성하는 시점에 준비할 수 있고, 또한 생성 시점에 의존객체가 정상인지 아닌지 판정할 수 있습니다. 반면에 메소드와 인터페이스를 통한 주입 방식은 의존객체가 나중에 생성되는 경우에 사용할 수 있으며, 메소드의 이름을 통해 어떤 의존객체를 주입하는지 더 알기 쉽다는 특징이 있습니다.\n서비스 로케이터 방식 서비스 로케이터 방식은 우선 로케이터 클래스에 의존객체를 모은 뒤, 로케이터가 각 클래스에 의존객체를 전달하는 구조로 되어 있습니다. DI와 동일하게 생성자 주입 방식과 메소드 주입 방식으로 구현할 수 있는데 여기서는 생성자 주입 방식으로 사용하는 법만 보여드리도록 하겠습니다.\n코드를 보시죠. 우선 메인루틴에서 모든 의존객체를 초기화한 뒤 그것들을 Locator에 생성자로 전달합니다. Locator는 모든 의존객체를 가지고 있도록 설계되어 있습니다. 그리고 Car에서 DieselEngine 객체가 필요하면 Locator를 통해 의존객체를 주입받게 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class GasolineEngine { val fuel = \u0026#34;gasoline\u0026#34; } class DieselEngine { val fuel = \u0026#34;diesel\u0026#34; } class Locator( private val dieselEngine: DieselEngine, private val gasolineEngine: GasolineEngine) { fun getGasolineEngine(): GasolineEngine { return gasolineEngine } fun getDieselEngine(): DieselEngine { return dieselEngine } companion object { private var instance: Locator? = null fun getInstance(locator: Locator) = instance ?: Locator(dieselEngine, gasolineEngine).also { instance = it } } } class Car { val engine = Locator.getInstance().getDieselEngine } fun main() { val dieselEngine = DieselEngine() val gasolineEngine = GasolineEngine() val locator = Locator(dieselEngine, gasolineEngine) val car = Car() } 문제는 서비스 로케이터를 사용하면 앞에서 설명한 인터페이스 분리원칙을 위반하게 된다는 점입니다. Car는 dieselEngine만 있으면 되는데 서비스 로케이터가 가진 gasolineEngine 객체에도 접근할 수 있게 되지요. 그리고 동일한 의존객체를 여러 클래스에서 사용해야 할 경우, 제공 메소드를 각 객체 수만큼 준비해야 합니다. 또한 의존성에 문제가 있어도 그걸 컴파일 타임에 확인할 수 없다는 한계도 있습니다.\n이렇게 해서 의존성 주입을 위한 기초이론과 실 사용예들에 대해 알아보았습니다. 생성자 주입방식만이 가장 좋은것처럼 설명된 면이 있지만, 의존성 주입을 구현하는데에 정해진 답이 있는 것은 아니니 각자 용도에 맞춰서 사용하면 됩니다.\n","date":"2022-07-31T21:19:03+09:00","permalink":"https://cliearl.github.io/posts/android/dependency-injection-basic/","title":"Dependency Injection 기초"},{"content":"이번 포스팅에서는 기기의 수평도를 확인하는 법에 대해 알아보도록 하겠습니다.\n좌표계와 기울기에 대한 이해 안드로이드 시스템의 좌표계는 다음과 같이 구성됩니다.\n출처 : https://developer.android.com/guide/topics/sensors/sensors_motion#sensors-motion-rotate\n기기가 세워진 상태로 정지하고 있을 때 가속도 센서로 각 축에 걸리는 가속도를 측정하면 x, z 축에서는 0, 그리고 y 축에는 9.8 m/s^2 값이 확인됩니다. y축의 -방향으로 9.8 m/s^2의 중력이 걸리고 있으므로 기기는 +방향으로 9.8 m/s^2 만큼 가속되는 것이기 때문입니다. 같은 이유로 기기를 책상에 눕혀놓으면 축이 바뀌면서 x, y 축에는 0, 그리고 z 축에는 +9.8 m/s^2의 가속도가 걸리게 됩니다.\n그런데 다음과 같은 3D 좌표계에서 벡터 R과 Rx, Ry, Rz 사이의 각도는 수학적으로 다음과 같이 구할 수 있습니다.\n출처 : https://electronics.stackexchange.com/q/21902\n$$ \\begin{align} cos(A_{xr})=\\frac{R_{x}}{R} \\ cos(A_{yr})=\\frac{R_{y}}{R} \\ cos(A_{zr})=\\frac{R_{z}}{R} \\end{align} $$\nRx, Ry, Rz 벡터의 총 크기는 피타고라스 정리에 의해 다음과 같이 정의됩니다.\n$$ \\begin{align} R=\\sqrt{R_{x}^2+R_{y}^2+R_{z}^2} \\end{align} $$\n기기가 벡터 R처럼 기울었을 때 기기에 걸리는 가속도값은 Rx, Ry, Rz입니다. 그러면 각 축에 대한 벡터R의 기울기는 다음과 같이 계산할 수 있습니다.\n$$ \\begin{align} A_{xr}=arccos\\left(\\frac{R_{x}}{R}\\right) \\ A_{yr}=arccos\\left(\\frac{R_{y}}{R}\\right) \\ A_{zr}=arccos\\left(\\frac{R_{z}}{R}\\right) \\end{align} $$\n수평계는 기기가 화면을 +z 방향으로 하고 누워있을 때의 x축과 y축에 대한 기울기를 구하는 것이니까 Axr과 Ayr을 구하면 됩니다.\n그런데 가속도 센서는 노이즈에 민감하고, 또 기기가 사용자에 의해 움직이고 있을 때는 중력가속도에 외력이 더해지기 때문에 각도를 정확하게 측정할 수 없습니다. 그래서 여기서는 가속도 센서 대신 중력 센서를 사용할 겁니다. 중력센서는 가속도센서와 자이로스코프 보정을 통해 각 축의 중력강도만을 반환하기 때문에 외력의 영향을 무시할 수 있습니다.\n수평계 구현 기기가 회전하면 좌표축이 바뀌게 되므로 우선은 기기가 회전하지 않도록 합니다. onCreate를 초기화하기 전에 setRequestedOrientation을 SCREEN_ORIENTATION_PORTRAIT로 설정해주면 됩니다.\n1 2 3 4 5 6 7 @SuppressLint(\u0026#34;SourceLockedOrientationActivity\u0026#34;) override fun onCreate(savedInstanceState: Bundle?) { // 세로모드 고정 requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT super.onCreate(savedInstanceState) setContentView(binding.root) } 다음은 센서를 인식시켜 줍니다. SensorManager 전역변수를 만들어주고 액티비티에서 SensorEventListener 를 상속받아 센서값의 변화를 통지받을 수 있게 합니다. onResume에서는 registerListener로 센서를 등록합니다. 그리고 앱이 백그라운드로 전환되면 자원낭비를 막기 위해 unregisterListener로 사용을 해제하게 하면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class MainActivity : AppCompatActivity(), SensorEventListener { ... private val sensorManager by lazy { getSystemService(Context.SENSOR_SERVICE) as SensorManager } override fun onResume() { super.onResume() sensorManager.registerListener(this, sensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY), SensorManager.SENSOR_DELAY_FASTEST) } override fun onPause() { super.onPause() sensorManager.unregisterListener(this) } } 센서값이 변화되면 onSensorChanged 콜백으로 값을 확인할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 override fun onSensorChanged(event: SensorEvent?) { event?.let { val x = event.values[0] val y = event.values[1] val z = event.values[2] val r = sqrt(x.pow(2) + y.pow(2) + z.pow(2)) Log.d(\u0026#34;MainActivity\u0026#34;, \u0026#34;onSensorChanged: x: $x, y: $y, z: $z, R: $r\u0026#34;) val xrAngle = (90 - acos(x / r) * 180 / PI).toFloat() val yrAngle = (90 - acos(y / r) * 180 / PI).toFloat() binding.textview.text = String.format( \u0026#34;x-rotation: %.1f\\u00B0 \\n y-rotation: %.1f\\u00B0\u0026#34;, xrAngle, yrAngle) } } override fun onAccuracyChanged(p0: Sensor?, p1: Int) { } 중력센서의 값은 SensorEvent의 value 속성으로 가져올 수 있습니다. 공식에 따라 r 값을 계산하고 Axr과 Ayr을 계산하면 됩니다. 계산값은 라디안으로 반환되기 때문에 (180/PI)를 곱해서 각도로 변환합니다. 그리고 안드로이드 시스템의 좌표계에서 기기가 누워있는 상태는 x, y축으로 90도 회전한 상태이기 때문에 이 값을 0으로 만들기 위해 90을 빼주면 됩니다.\n이렇게 해서 센서를 이용해 기기의 수평도를 계산하는 방법에 대해 알아보았습니다.\n","date":"2022-06-07T21:55:44+09:00","permalink":"https://cliearl.github.io/posts/android/find-tilt-angle-with-gravity-sensor/","title":"중력센서를 사용해 기기의 기울기 각도 확인하기"},{"content":"App Store로 설치하는 앱 AdBlock Pro for Safari DaVinch Resolve 카카오톡 LINE iMovie Microsoft Remote Desktop Microsoft Excel Microsoft PowerPoint Microsoft Word Pine Player RunCat Unsplash Wallpapers Xcode 한컴오피스 한글 2014 VP 뷰어 Logi Options+ brew로 설치하는 앱 aldente audacity android-studio ccleaner commander-one cyberduck firefox font-fira-code foxitreader iina inkscape iterm2 itsycal joplin netspot openemu pycharm-ce rectangle shottr stats sublime-text teamviewer the-unarchiver visual-studio-code vnc-viewer xnviewmp yacreader vrew zoom zotero ","date":"2022-06-05T16:30:42+09:00","permalink":"https://cliearl.github.io/posts/etc/my-favorite-mac-apps/","title":"내가 사용하는 macOS 앱"},{"content":" 안녕하세요 냉동코더입니다. 작년부터 준비해 온 안드로이드 개발 강의를 드디어 공개하게 되었습니다. 강의 이름은 \u0026lsquo;냉동코더의 알기 쉬운 Modern Android Development 입문\u0026rsquo; 입니다.\n안드로이드 제트팩을 중심으로 한 안드로이드 라이브러리의 동작 원리를 이해하고 앱에 적용하는 법을 가능한 알기 쉽게 전달하는 것을 목표로 강의를 만들었습니다. MVVM 아키텍처를 도입해야 하는 이유, 제트팩 라이브러리의 사용법, 의존성 주입을 해야하는 이유, 코틀린으로 그래들을 작성하는 법 등 최신 기술을 꾹꾹 눌러담은 강의가 되도록 했습니다. 많은 시간과 노력을 들여 만든 만큼 많은 분들께 도움이 될 수 있으면 좋겠습니다.\n이 강의는 인프런에서 공개합니다. URL 주소는 다음과 같습니다.\nhttps://www.inflearn.com/course/%EC%95%8C%EA%B8%B0%EC%89%AC%EC%9A%B4-modern-android?inst=c3cee510\n많이 수강해주셨으면 해서 2022년 5월 31일까지 오픈 기념으로 30 퍼센트 할인을 적용하였으니 이번 기회를 이용해주시면 좋을 것 같습니다. 그럼 강의에서 뵙겠습니다. 감사합니다.\n","date":"2022-05-21T08:06:02+09:00","permalink":"https://cliearl.github.io/posts/etc/inflearn-mad-lecture/","title":"'냉동코더의 알기 쉬운 Modern Android Development 입문' 강좌 소개"},{"content":"이번 포스팅에서는 구글맵 마커를 커스텀하고 클러스터링하는 법에 대해 알아보도록 하겠습니다.\n다음과 같이 좁은 공간에 마커가 모여있을 경우 마커를 뭉쳐서 숫자로 변환하는 것을 클러스터링이라고 합니다. 지도를 확대하면 클러스터가 개별 마커로 펼쳐지기 때문에 많은 마커를 표시해야 하는 경우에 공간을 효율적으로 사용할 수 있습니다.\n출처 : https://developers.google.com/maps/documentation/android-sdk/utility/marker-clustering\n여기서는 기존에 작성했던 구글맵 프로젝트에 코로나 선별진료소를 표시하면서 클러스터링을 구현해보도록 하겠습니다.\nDependency 추가 build.gradle에 클러스터링에 사용할 클래스를 담은 android-maps-utils 를 추가합니다.\n1 2 3 dependencies { implementation \u0026#39;com.google.maps.android:android-maps-utils:2.3.0\u0026#39; } 선별진료소 데이터 준비 마커에 사용할 선별진료소 데이터는 경기데이터드림에서 제공하는 코로나바이러스 감염증 선별진료소 운영 의료기관 현황데이터를 사용하겠습니다. 이 데이터에는 마커에 바로 사용할 수 있는 경도와 위도정보가 포함되어 있기 때문에 이번 강의의 제물로 선택되었습니다.\nsheet 탭에서 JSON 을 클릭하여 데이터를 json 형식으로 다운받습니다. 다운받아보면 내용이 한줄에 모여있어 보기 불편합니다. 사용하는데는 관계 없지만 값들을 정렬하는게 보기에 좋을 것 같으니 Json Formatter 에서 파일을 정렬하고 data.json이라는 이름으로 assets 폴더에 저장합니다.\n앱에서 json 파일을 편하게 다루기 위해 gson 라이브러리를 추가하고, 데이터를 오브젝트로 변환하기 위한 DAO를 작성합니다. JSON To Kotlin Class 플러그인을 사용하면 DAO를 편하게 만들 수 있습니다.\n1 2 3 dependencies { implementation \u0026#39;com.google.code.gson:gson:2.8.6\u0026#39; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class CoronaMed : ArrayList\u0026lt;CoronaMedItem\u0026gt;() data class CoronaMedItem( val AGRGT_DE: String, // 2021-04-01 val DISTRCT_DIV_DTLS: String, // 호흡기전담클리닉 val EMGC_CENTER_TELNO: String, // 031-8003-8275 val MEDINST_NM: String, // 상쾌한이비인후과의원 val REFINE_LOTNO_ADDR: String, // 경기도 화성시 반송동 216-1번지 val REFINE_ROADNM_ADDR: String, // 경기도 화성시 동탄솔빛로 44 val REFINE_WGS84_LAT: String, // 37.1928811270 val REFINE_WGS84_LOGT: String, // 127.0729965789 val REPRSNT_TELNO: String, val SIGUN_NM: String // 화성시 ) 마지막으로 asset 폴더에서 불러온 데이터를 DAO로 변환하는 함수를 작성합니다. 함수의 자세한 설명은 Assets 폴더에서 로딩한 json 파일 Recyclerview에 표시하기 강의를 참조하시기 바랍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private fun getJsonData(filename: String): CoronaMed { var result = CoronaMed() try { val assetManager = resources.assets val inputStream = assetManager.open(filename) val reader = inputStream.bufferedReader() val gson = Gson() result = gson.fromJson(reader, CoronaMed::class.java) } catch (e: Exception) { e.printStackTrace() } return result } 마커 준비 데이터 준비가 끝났으니 이젠 마커를 준비하겠습니다. 우선은 마커로 사용할 아이콘을 설정해줍니다. 코로나 선별진료소를 표시할 것이므로 적십자 마크를 사용하도록 하겠습니다. 다음 png 파일을 drawable 폴더에 복사하여 넣어줍니다.\n출처 : https://commons.wikimedia.org/wiki/File:Red_Cross_icon.svg\n이 이미지파일은 createScaledBitmap 을 통해 다음과 같이 비트맵으로 변환해서 마커를 렌더링할때 사용합니다.\n1 2 3 4 5 private val mapIcon by lazy { val drawable = ResourcesCompat.getDrawable(resources, R.drawable.mapicon, null) as BitmapDrawable Bitmap.createScaledBitmap(drawable.bitmap, 64, 64, false) } 클러스터 아이템 구현 클러스터링을 구현하기 위해서는 ClusterItem 을 상속받게 해서 생성한 마커를 ClusterManager에 전달해주면 됩니다.\n우선 ClusterItem을 상속받는 CoronaMedClusterItem 클래스를 작성합니다. 마커 모양은 기본값이 아닌 적십자 이미지를 적용하기 위해 _icon 속성을 정의하고, BitmapDescriptor 를 반환하는 getIcon 메소드를 추가합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 data class CoronaMedClusterItem( private val _position: LatLng, private val _title: String, private val _snippet: String, private val _icon: BitmapDescriptor, ) : ClusterItem { override fun getSnippet(): String { return _snippet } override fun getTitle(): String { return _title } override fun getPosition(): LatLng { return _position } fun getIcon(): BitmapDescriptor { return _icon } } 클러스터 렌더러 구현 마커는 DefaultClusterRenderer 에 의해 렌더링되는데요, 이 때 렌더러가 비트맵 이미지를 반영해서 렌더링하도록 onBeforeClusterItemRendered에서 markerOptions.icon에 이미지를 지정하도록 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class CoronaMedClusterRenderer( context: Context, map: GoogleMap, clusterManager: ClusterManager\u0026lt;CoronaMedClusterItem\u0026gt;, ) : DefaultClusterRenderer\u0026lt;CoronaMedClusterItem\u0026gt;(context, map, clusterManager) { init { clusterManager.renderer = this } override fun onBeforeClusterItemRendered(item: CoronaMedClusterItem, markerOptions: MarkerOptions) { markerOptions.icon(item.getIcon()) markerOptions.visible(true) } } 커스텀 마커 생성 및 클러스터매니저 구현 그럼 클러스터매니저를 이용해서 마커를 추가하는 메소드를 작성합니다. getJsonData 로 json 파일을 읽어와 오브젝트화 합니다. 그리고나서 요소를 하나씩 꺼내와 위치좌표, 타입, 아이콘을 가지는 CoronaMedClusterItem 마커를 만들어 클러스터매니저에 전달해주도록 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 private fun addMarkers() { val items = getJsonData(\u0026#34;data.json\u0026#34;) for (item in items) { val medClusterItem = CoronaMedClusterItem( LatLng(item.REFINE_WGS84_LAT.toDouble(), item.REFINE_WGS84_LOGT.toDouble()), item.MEDINST_NM, \u0026#34;타입: ${item.DISTRCT_DIV_DTLS}\u0026#34;, BitmapDescriptorFactory.fromBitmap(mapIcon) ) clusterManager.addItem(medClusterItem) } } 나머지는 OnMapReady()에서 클러스터매니저를 초기화하고 addMarkers를 실행시켜주면 되겠죠.\n1 2 3 4 5 6 7 8 9 10 11 12 + private lateinit var clusterManager: ClusterManager\u0026lt;CoronaMedClusterItem\u0026gt; @SuppressLint(\u0026#34;MissingPermission\u0026#34;) override fun onMapReady(googleMap: GoogleMap) { ... + clusterManager = ClusterManager(requireContext(), map) + CoronaMedClusterRenderer(requireContext(), map, clusterManager) + map.setOnCameraIdleListener(clusterManager) + addMarkers() } 이렇게해서 구글맵에 커스텀 마커와 클러스터아이템을 적용하는 법에 대해 알아보았습니다.\n","date":"2022-05-02T20:18:53+09:00","permalink":"https://cliearl.github.io/posts/android/google-maps-cluster/","title":"구글맵에 커스텀 마커와 클러스터아이템 적용하기"},{"content":"이번 포스팅에서는 프래그먼트에서 구글맵을 구현하는 방법에 대해 알아보도록 하겠습니다.\n구글 맵 구현법 안드로이드에서 구글맵을 구현하는 법은 두가지가 있는데요, 우선은 액티비티에서 OnMapReadyCallback을 구현하고 SupportMapFragment를 통해 다음과 같이 화면에 표시하는 방법이 있습니다.\n1 2 3 4 \u0026lt;fragment class=\u0026#34;com.google.android.gms.maps.SupportMapFragment\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;/\u0026gt; 두번째는 독립된 프래그먼트에서 OnMapReadyCallback을 구현한 뒤 MapView 컴포넌트에 표시하는 방법이 있습니다.\n1 2 3 4 \u0026lt;com.google.android.gms.maps.MapView android:id=\u0026#34;@+id/mapview\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; /\u0026gt; 액티비티로 구글맵을 구현하는 방법은 구글 디벨로퍼 사이트에서 자세하게 설명하고 있기 때문에, 여기서는 독립된 프래그먼트를 만들어 구글맵을 구현하는 방법을 알아보도록 하겠습니다.\nBottom navigation 구현 프래그먼트에 맵을 표시하기 위해 Bottom navigation을 구성해 주겠습니다. 우선은 액티비티 레이아웃에 Bottom navigation 컴포넌트와 프래그먼트를 표시할 FrameLayout을 추가해 줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;FrameLayout android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:id=\u0026#34;@+id/frame_layout\u0026#34; app:layout_constraintBottom_toTopOf=\u0026#34;@+id/bottom_navigation\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;com.google.android.material.bottomnavigation.BottomNavigationView android:id=\u0026#34;@+id/bottom_navigation\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;56dp\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintLeft_toLeftOf=\u0026#34;parent\u0026#34; app:layout_constraintRight_toRightOf=\u0026#34;parent\u0026#34; app:menu=\u0026#34;@menu/bottom_navigation_menu\u0026#34; /\u0026gt; 그리고 res \u0026gt; menu 폴더를 만들어 컴포넌트에 표시할 메뉴파일을 작성합니다. 항목은 텍스트뷰를 하나 보여주는 InfoFragment와 맵을 표시하는 MapFragment 두개만 만들겠습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;menu xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/navigation_info\u0026#34; android:icon=\u0026#34;@drawable/ic_baseline_info_24\u0026#34; android:title=\u0026#34;Info\u0026#34; /\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/navigation_map\u0026#34; android:icon=\u0026#34;@drawable/ic_baseline_map_24\u0026#34; android:title=\u0026#34;Map\u0026#34; /\u0026gt; \u0026lt;/menu\u0026gt; InfoFragment와 MapFragment는 다음과 같이 기본 View Binding 구성에 텍스트뷰 하나만 표시하도록 하겠습니다. 프래그먼트에서 View Binding을 사용하는 방법에 대해서는 findViewById 대신 View Binding 사용하기를 참조하시기 바랍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class InfoFragment : Fragment() { private var _binding: FragmentInfoBinding? = null private val binding get() = _binding!! override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { _binding = FragmentInfoBinding.inflate(inflater, container, false) return binding.root } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) binding.tvText.text = \u0026#34;Info Fragment\u0026#34; } override fun onDestroyView() { _binding = null super.onDestroyView() } } 그리고 네비게이션 클릭시 동작을 구현하는 setupBottomNavigationBar 함수를 만들어서 메인액티비티의 onCreate에서 실행시킵니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private fun setupBottomNavigation() { binding.bottomNavigation.setOnItemSelectedListener { item -\u0026gt; when(item.itemId) { R.id.navigation_info -\u0026gt; { supportFragmentManager.beginTransaction() .replace(R.id.frame_layout, InfoFragment()) .commit() true } R.id.navigation_map -\u0026gt; { supportFragmentManager.beginTransaction() .replace(R.id.frame_layout, MapFragment()) .commit() true } else -\u0026gt; false } } binding.bottomNavigation.selectedItemId = R.id.navigation_info } 구글맵 API 키 설정 구글맵을 사용하기 위해서는 구글 클라우드에서 API 키를 취득해야 합니다. Google Cloud Console에서 설정 페이지를 참조하여 구글 클라우드에 새 프로젝트를 작성하고 API 사용설정을 해 줍니다. 그리고 API 키 만들기 페이지를 참조해서 만들어진 API 키를 확인합니다. 웹페이지의 설명이 어려우시면 Google 지도 플랫폼에서 API 키를 생성하고 제한하기 영상을 참고하세요.\nAPI 키가 얻어졌으면 AndroidManifest.xml에 다음과 같이 키를 추가합니다.\n1 2 3 \u0026lt;meta-data android:name=\u0026#34;com.google.android.geo.API_KEY\u0026#34; android:value=\u0026#34;API KEY\u0026#34; /\u0026gt; Dependency 추가 이제 맵을 구현하는 MapFragment를 작성하겠습니다. 우선은 build.gradle 에 구글맵과 디바이스의 위치를 사용하기 위한 dependency를 추가합니다.\n1 2 3 // Google maps implementation \u0026#39;com.google.android.gms:play-services-maps:18.0.2\u0026#39; implementation \u0026#39;com.google.android.gms:play-services-location:19.0.1\u0026#39; 레이아웃 구성 이제 프래그먼트 레이아웃에 지도를 표시할 MapView를 추가합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; \u0026gt; \u0026lt;com.google.android.gms.maps.MapView android:id=\u0026#34;@+id/mapView\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; MapFragment 작성 프래그먼트 클래스는 액티비티에서 구현할 때처럼 OnMapReadyCallback 을 구현하게 합니다. 우선은 onViewCreated에서 getMapAsync를 이용해 MapView를 초기화합니다. 그리고 OnMapReady에서 나머지 처리를 수행하면 됩니다. 여기서는 맵이 시작되면 카메라의 초기위치로 서울시청을 보여주도록 하였습니다. 그리고 onSaveInstanceState 설정을 하여 맵이 위치를 기억할 수 있도록 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class MapFragment : Fragment(), OnMapReadyCallback { private var _binding: FragmentMapBinding? = null private val binding get() = _binding!! + private lateinit var map: GoogleMap override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { _binding = FragmentMapBinding.inflate(inflater, container, false) return binding.root } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) + binding.mapView.onCreate(savedInstanceState) + binding.mapView.getMapAsync(this) } + override fun onMapReady(googleMap: GoogleMap) { + map = googleMap + + val initialPosition = LatLng(37.5638698,126.9791104) + val cameraUpdate = CameraUpdateFactory.newLatLngZoom(initialPosition, 14f) + map.animateCamera(cameraUpdate) + + map.addMarker( + MarkerOptions() + .position(initialPosition) + .title(\u0026#34;서울시청\u0026#34;) + ) + } + override fun onSaveInstanceState(outState: Bundle) { + super.onSaveInstanceState(outState) + binding.mapView.onSaveInstanceState(outState) + } override fun onDestroyView() { _binding = null super.onDestroyView() } } 위치권한 획득하기 맵에 나의 위치를 표시하기 위해서는 위치권한이 필요합니다. Android 6.0(API 레벨 23) 이상에서는 위치권한 등의 위험한 권한들이 필요할 경우 앱이 실행중에 권한을 요청할 수 있도록 시스템이 변경되었습니다.\n우선은 AndroidManifest.xml에서 앱에 필요한 권한을 정의합니다. 맵 데이터를 인터넷에서 받아오기 위한 INTERNET권한과, 위치정보를 가져오기 위한 LOCATION 권한이 필요합니다.\n1 2 3 \u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_COARSE_LOCATION\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_FINE_LOCATION\u0026#34; /\u0026gt; LOCATION 관련 권한이 2개이므로 한번에 요청하도록 하겠습니다. 요청할 모든 권한을 REQUIRED_PERMISSIONS에서 배열형태로 준비합니다. 그리고 checkSelfPermission을 이용해 현재 앱이 REQUIRED_PERMISSIONS에서 정의한 모든 권한을 가지고 있는지 순회하면서 체크하고 만약 false가 반환되었다면 requestMultiplePermissions를 실행해 권한을 획득하도록 합니다. 권한 요청은 맵 프래그먼트가 시작되기 전에 이루어져야하기 때문에 메인액티비티에서 수행하도록 하겠습니다. 권한 요청에 대한 더 구체적인 설명은 Runtime Permission 이해하고 요청 구현하기를 참고하시기 바랍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 companion object { private val REQUIRED_PERMISSIONS = arrayOf( Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_FINE_LOCATION, ) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(binding.root) setBottomNavigation() if (!isAllPermissionsGranted()) { requestPermissionLauncher.launch(REQUIRED_PERMISSIONS) } } private fun isAllPermissionsGranted(): Boolean = REQUIRED_PERMISSIONS.all { permission -\u0026gt; ContextCompat.checkSelfPermission(this, permission) == PackageManager.PERMISSION_GRANTED } private val requestPermissionLauncher = registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) { permissions -\u0026gt; permissions.entries.forEach { permission -\u0026gt; when { permission.value -\u0026gt; { Snackbar.make(binding.root, \u0026#34;Permission granted\u0026#34;, Snackbar.LENGTH_SHORT).show() } shouldShowRequestPermissionRationale(permission.key) -\u0026gt; { Snackbar.make(binding.root, \u0026#34;Permission required to use app!\u0026#34;, Snackbar.LENGTH_SHORT).show() } else -\u0026gt; Snackbar.make(binding.root, \u0026#34;Permission denied\u0026#34;, Snackbar.LENGTH_SHORT).show() } } } 맵에 내 위치 표시하기 getUiSetting 이용하기 GoogleMap에 내장된 getUiSetting 을 이용하면 다음과 같은 위치표시 버튼을 맵에 표시할 수 있습니다. 옵션을 추가함으로써 Zoom control이나 Level picker도 표시하게 할 수 있습니다.\n출처 : https://developers.google.com/maps/documentation/android-sdk/controls\n맵 상에 위치표시 버튼을 보여주게 하려면 onMapReady에서 map 객체를 획득한 후 다음 작업을 수행하면 됩니다. 위치권한을 사용해야 하는 작업인데 프래그먼트에서 권한을 획득하는 로직이 없으므로 Missing permissions 경고가 발생합니다. 하지만 권한은 액티비티에서 이미 취득했으므로 경고를 무시하기 위해 @SuppressLint(\u0026quot;MissingPermission\u0026quot;) 어노테이션을 붙여줍니다.\n1 2 3 4 5 6 7 8 9 10 11 + @SuppressLint(\u0026#34;MissingPermission\u0026#34;) override fun onMapReady(googleMap: GoogleMap) { map = googleMap + try { + map.isMyLocationEnabled = true + map.uiSettings.isMyLocationButtonEnabled = true + } catch (e: Exception) { + e.printStackTrace() + } } FusedLocationProviderClient 이용하기 기본으로 제공된 버튼을 사용하지 않고 내 위치를 받아오는 기능을 직접 구현할 수도 있는데요, 그 경우엔 FusedLocationProviderClient를 사용하면 됩니다.\n우선은 맵프래그먼트의 레이아웃에 현재 위치를 확인할 플로팅 버튼을 추가합니다.\n1 2 3 4 5 6 7 8 \u0026lt;com.google.android.material.floatingactionbutton.FloatingActionButton android:id=\u0026#34;@+id/btn_fab\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_margin=\u0026#34;20dp\u0026#34; android:src=\u0026#34;@drawable/ic_baseline_location_searching_24\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; /\u0026gt; fusedLocationProviderClient 전역변수를 만들고 onViewCreated에서 초기화합니다.\n1 2 3 4 5 6 7 + private lateinit var fusedLocationClient: FusedLocationProviderClient override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) ... + fusedLocationClient = LocationServices.getFusedLocationProviderClient(requireActivity()) } 그리고 플로팅 버튼을 클릭했을 때 fusedLocationProviderClient의 lastLocation으로 위치정보를 얻고 그걸 지도에 표시하면 됩니다.\n1 2 3 4 5 6 7 8 9 binding.btnFab.setOnClickListener { fusedLocationClient.lastLocation.addOnSuccessListener { location : Location? -\u0026gt; if (location != null) { val mylocation = LatLng(location.latitude, location.longitude) val cameraUpdate = CameraUpdateFactory.newLatLngZoom(mylocation, 14f) map.animateCamera(cameraUpdate) } } } 이 때 lastLocation은 다음과 같은 경우에 null이 될 수 있기 때문에 null 체크를 해 주어야 합니다.\nLocation is turned off in the device settings. The result could be null even if the last location was previously retrieved because disabling location also clears the cache. The device never recorded its location, which could be the case of a new device or a device that has been restored to factory settings. Google Play services on the device has restarted, and there is no active Fused Location Provider client that has requested location after the services restarted. To avoid this situation you can create a new client and request location updates yourself. For more information, see Receiving Location Updates. 생명주기 관리 프래그먼트의 생명주기에 따라 구글맵을 관리하기 위한 처리를 해 줍니다. 맵을 액티비티에서 SupportMapFragment로 구현할 경우에는 신경쓰지 않아도 되는 부분입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class MapFragment : Fragment(), OnMapReadyCallback { ... override fun onStart() { super.onStart() binding.mapView.onStart() } override fun onStop() { binding.mapView.onStop() super.onStop() } override fun onResume() { super.onResume() binding.mapView.onResume() } override fun onPause() { binding.mapView.onPause() super.onPause() } override fun onLowMemory() { super.onLowMemory() binding.mapView.onLowMemory() } } 이렇게 해서 프래그먼트에서 구글맵을 구현하고 기본적인 동작을 수행하는 법에 대해 알아보았습니다.\n","date":"2022-05-02T20:16:12+09:00","permalink":"https://cliearl.github.io/posts/android/google-maps-basic/","title":"프래그먼트에서 구글맵 구현하고 내 위치 표시하기"},{"content":"이번 포스팅에서는 안드로이드 기기에 설치된 센서 종류를 확인하는 법에 대해 알아보도록 하겠습니다.\nAndroid 플랫폼에서 지원하는 센서의 유형은 다음 표와 같습니다.\nSensor Type Description Common Uses TYPE_ACCELEROMETER Hardware Measures the acceleration force in m/s2 that is applied to a device on all three physical axes (x, y, and z), including the force of gravity. Motion detection (shake, tilt, etc.). TYPE_AMBIENT_TEMPERATURE Hardware Measures the ambient room temperature in degrees Celsius (°C). See note below. Monitoring air temperatures. TYPE_GRAVITY Software or Hardware Measures the force of gravity in m/s2 that is applied to a device on all three physical axes (x, y, z). Motion detection (shake, tilt, etc.). TYPE_GYROSCOPE Hardware Measures a device\u0026rsquo;s rate of rotation in rad/s around each of the three physical axes (x, y, and z). Rotation detection (spin, turn, etc.). TYPE_LIGHT Hardware Measures the ambient light level (illumination) in lx. Controlling screen brightness. TYPE_LINEAR_ACCELERATION Software or Hardware Measures the acceleration force in m/s2 that is applied to a device on all three physical axes (x, y, and z), excluding the force of gravity. Monitoring acceleration along a single axis. TYPE_MAGNETIC_FIELD Hardware Measures the ambient geomagnetic field for all three physical axes (x, y, z) in μT. Creating a compass. TYPE_ORIENTATION Software Measures degrees of rotation that a device makes around all three physical axes (x, y, z). As of API level 3 you can obtain the inclination matrix and rotation matrix for a device by using the gravity sensor and the geomagnetic field sensor in conjunction with the getRotationMatrix() method. Determining device position. TYPE_PRESSURE Hardware Measures the ambient air pressure in hPa or mbar. Monitoring air pressure changes. TYPE_PROXIMITY Hardware Measures the proximity of an object in cm relative to the view screen of a device. This sensor is typically used to determine whether a handset is being held up to a person\u0026rsquo;s ear. Phone position during a call. TYPE_RELATIVE_HUMIDITY Hardware Measures the relative ambient humidity in percent (%). Monitoring dewpoint, absolute, and relative humidity. TYPE_ROTATION_VECTOR Software or Hardware Measures the orientation of a device by providing the three elements of the device\u0026rsquo;s rotation vector. Motion detection and rotation detection. TYPE_TEMPERATURE Hardware Measures the temperature of the device in degrees Celsius (°C). This sensor implementation varies across devices and this sensor was replaced with the TYPE_AMBIENT_TEMPERATURE sensor in API Level 14 Monitoring temperatures. 센서도 많은 종류가 있는 것을 알 수 있습니다. 여기서는 기기에 장착된 센서를 확인하는 방법을 알아볼 겁니다.\n우선 새로운 프로젝트를 만들고 센서 리스트를 표시할 화면을 작성합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;ScrollView android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_sensor\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; \u0026lt;/ScrollView\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; 다음은 onCreate에서 센서 리스트를 획득하는 코드를 작성합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class MainActivity : AppCompatActivity() { private val binding by lazy { ActivityMainBinding.inflate(layoutInflater) } private val sensorManager by lazy { getSystemService(Context.SENSOR_SERVICE) as SensorManager } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(binding.root) getSensorList() } private fun getSensorList() { val sensorList: List\u0026lt;Sensor\u0026gt; = sensorManager.getSensorList(Sensor.TYPE_ALL) var sensorResult = String() sensorList.forEachIndexed { index, sensor -\u0026gt; sensorResult += \u0026#34;\u0026#34;\u0026#34; $index : ${sensor.name} toString : $sensor \u0026#34;\u0026#34;\u0026#34;.trimIndent() } binding.tvSensor.text = sensorResult } } 우선은 센서 서비스를 관할하는 SensorManager 인스턴스를 획득합니다. 그리고나면 getSensorList로 모든 센서 리스트를 가져온 뒤, 텍스트뷰에 이 리스트의 속성을 표시하면 됩니다.\nSensor의 get 속성은 여러가지가 있는데요, toString으로 모든 속성을 확인할 수 있습니다. 안드로이드 스튜디오에서 제공하는 에뮬레이터에는 다음과 같은 센서가 설치되어 있다고 하네요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 [ { \u0026#34;Sensor name=\u0026#34;\u0026#34;Goldfish 3-axis Accelerometer\u0026#34;, \u0026#34;vendor=\u0026#34;\u0026#34;The Android Open Source Project\u0026#34;, version=1, type=1, maxRange=39.300102, resolution=2.480159E-4, power=3.0, minDelay=10000 }, { \u0026#34;Sensor name=\u0026#34;\u0026#34;Goldfish 3-axis Gyroscope\u0026#34;, \u0026#34;vendor=\u0026#34;\u0026#34;The Android Open Source Project\u0026#34;, version=1, type=4, maxRange=16.46, resolution=0.001, power=3.0, minDelay=10000 }, { \u0026#34;Sensor name=\u0026#34;\u0026#34;Goldfish 3-axis Magnetic field sensor\u0026#34;, \u0026#34;vendor=\u0026#34;\u0026#34;The Android Open Source Project\u0026#34;, version=1, type=2, maxRange=2000.0, resolution=0.5, power=6.7, minDelay=10000 }, { \u0026#34;Sensor name=\u0026#34;\u0026#34;Goldfish Orientation sensor\u0026#34;, \u0026#34;vendor=\u0026#34;\u0026#34;The Android Open Source Project\u0026#34;, version=1, type=3, maxRange=360.0, resolution=1.0, power=9.7, minDelay=10000 }, { \u0026#34;Sensor name=\u0026#34;\u0026#34;Goldfish Ambient Temperature sensor\u0026#34;, \u0026#34;vendor=\u0026#34;\u0026#34;The Android Open Source Project\u0026#34;, version=1, type=13, maxRange=80.0, resolution=1.0, power=0.001, minDelay=0 }, { \u0026#34;Sensor name=\u0026#34;\u0026#34;Goldfish Proximity sensor\u0026#34;, \u0026#34;vendor=\u0026#34;\u0026#34;The Android Open Source Project\u0026#34;, version=1, type=8, maxRange=1.0, resolution=1.0, power=20.0, minDelay=0 }, { \u0026#34;Sensor name=\u0026#34;\u0026#34;Goldfish Light sensor\u0026#34;, \u0026#34;vendor=\u0026#34;\u0026#34;The Android Open Source Project\u0026#34;, version=1, type=5, maxRange=40000.0, resolution=1.0, power=20.0, minDelay=0 }, { \u0026#34;Sensor name=\u0026#34;\u0026#34;Goldfish Pressure sensor\u0026#34;, \u0026#34;vendor=\u0026#34;\u0026#34;The Android Open Source Project\u0026#34;, version=1, type=6, maxRange=800.0, resolution=1.0, power=20.0, minDelay=10000 }, { \u0026#34;Sensor name=\u0026#34;\u0026#34;Goldfish Humidity sensor\u0026#34;, \u0026#34;vendor=\u0026#34;\u0026#34;The Android Open Source Project\u0026#34;, version=1, type=12, maxRange=100.0, resolution=1.0, power=20.0, minDelay=0 }, { \u0026#34;Sensor name=\u0026#34;\u0026#34;Goldfish 3-axis Magnetic field sensor (uncalibrated)\u0026#34;, \u0026#34;vendor=\u0026#34;\u0026#34;The Android Open Source Project\u0026#34;, version=1, type=14, maxRange=2000.0, resolution=0.5, power=6.7, minDelay=10000 }, { \u0026#34;Sensor name=\u0026#34;\u0026#34;Game Rotation Vector Sensor\u0026#34;, \u0026#34;vendor=\u0026#34;\u0026#34;AOSP\u0026#34;, version=3, type=15, maxRange=1.0, resolution=5.9604645E-8, power=12.7, minDelay=10000 }, { \u0026#34;Sensor name=\u0026#34;\u0026#34;GeoMag Rotation Vector Sensor\u0026#34;, \u0026#34;vendor=\u0026#34;\u0026#34;AOSP\u0026#34;, version=3, type=20, maxRange=1.0, resolution=5.9604645E-8, power=12.7, minDelay=10000 }, { \u0026#34;Sensor name=\u0026#34;\u0026#34;Gravity Sensor\u0026#34;, \u0026#34;vendor=\u0026#34;\u0026#34;AOSP\u0026#34;, version=3, type=9, maxRange=19.6133, resolution=2.480159E-4, power=12.7, minDelay=10000 }, { \u0026#34;Sensor name=\u0026#34;\u0026#34;Linear Acceleration Sensor\u0026#34;, \u0026#34;vendor=\u0026#34;\u0026#34;AOSP\u0026#34;, version=3, type=10, maxRange=19.6133, resolution=2.480159E-4, power=12.7, minDelay=10000 }, { \u0026#34;Sensor name=\u0026#34;\u0026#34;Rotation Vector Sensor\u0026#34;, \u0026#34;vendor=\u0026#34;\u0026#34;AOSP\u0026#34;, version=3, type=11, maxRange=1.0, resolution=5.9604645E-8, power=12.7, minDelay=10000 }, { \u0026#34;Sensor name=\u0026#34;\u0026#34;Orientation Sensor\u0026#34;, \u0026#34;vendor=\u0026#34;\u0026#34;AOSP\u0026#34;, version=1, type=3, maxRange=360.0, resolution=0.00390625, power=12.7, minDelay=10000 } ] 이렇게해서 안드로이드 기기에 설치된 센서 리스트를 확인하는 법에 대해 알아보았습니다.\n","date":"2022-04-02T07:51:58+09:00","permalink":"https://cliearl.github.io/posts/android/show-sensor-list/","title":"기기에 설치된 센서종류 확인하기"},{"content":"LEMP는 Linux + Nginx + MariaDB + PHP 조합을 의미한다. Nginx의 N 대신 발음하기 좋게 EngineX의 E를 쓴다\n방화벽 설치 ufw 와 gufw 설치 1 sudo apt install ufw gufw 포트개방 및 폐쇄 1 2 3 4 sudo ufw allow 80/tcp sudo ufw allow 443/tcp sudo ufw allow 5900/tcp // vncserver port sudo ufw deny 22/tcp // ssh port ufw 활성화 1 sudo ufw enable 방화벽 설정확인 1 sudo ufw status verbose Nginx 설치 1 2 sudo apt install nginx sudo service nginx start 이 시점에서 서버의 80번 포트로 접속할수 있게 된다.\nPHP 설치 Nginx는 PHP를 네이티브로 지원하지 않으므로 Fastcgi Process Manager(FPM)로 구현된 PHP를 설치한다. 1 sudo apt install php php-fpm php-fpm을 사용하도록 설정하기 위해 설정파일을 만든다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 sudo nano /etc/nginx/sites-available/default // 다음 행 마지막에 index.php 추가 index index.html index.htm index.nginx-debian.html; // 다음 행의 주석처리를 해제 #location ~ \\.php$ { # include snippets/fastcgi-php.conf; # # # With php-fpm (or other unix sockets): # fastcgi_pass unix:/var/run/php/php7.4-fpm.sock; # # With php-cgi (or other tcp sockets): # fastcgi_pass 127.0.0.1:9000; #} 서비스 재시작 1 sudo service nginx reload MariaDB 설정 설치 1 sudo apt install mariadb-server php-mysql 셋업 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 셋업 시작 sudo mysql_secure_installation // 초기 셋업 Enter current password for root (enter for none): 엔터 Set root password? [Y/n] y New password: 패스워드 입력 Remove anonymous users? [Y/n] y Disallow root login remotely? [Y/n] y Remove test database and access to it? [Y/n] y Reload privilege tables now? [Y/n] y // 로그인 sudo mysql -uroot -p // 워드프레스용 DB 생성 create database wordpress; // 워드프레스 DB에 접근할 수 있는 유저 생성 create user 사용자이름 identified by \u0026#39;패스워드\u0026#39;; // 생성한 유저에 워드프레스 DB에 대한 모든 권한을 부여 grant all privileges on wordpress.* to \u0026#39;사용자이름\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#39;패스워드\u0026#39;; // 권한변경을 적용 flush privileges; WordPress 설치 html 폴더 안의 모든 파일 삭제 1 2 cd /var/www/html/ sudo rm * 설치 작업 1 2 3 4 5 6 7 8 9 10 11 // 워드프레스 다운로드 sudo wget http://wordpress.org/latest.tar.gz // 다운로드한 파일의 압축해제 sudo tar xzf latest.tar.gz // 워드프레스 폴더안의 모든파일을 현재 폴더로 이동 sudo mv wordpress/* . // 압축파일과 빈 워드프레스 폴더를 삭제 sudo rm -rf wordpress latest.tar.gz WordPress 셋업 http://localhost 로 접속하여 웹브라우저 상에서 셋업\nSSL 설정 Let`s encrypt 설치 1 sudo apt install letsencrypt HTTP-based DCV 방식으로 서버 인증 1 sudo letsencrypt certonly --webroot --webroot-path=/var/www/html -d qualitybitz.com -d www.qualitybitz.com 인증성공시 인증서 발급 /etc/letsencrypt/live/test.com/ 폴더에 cert.pem(인증서 파일), chain.pem(인증서 발급자 파일), fullchain.pem(cert.pem 과 chain.pen 을 하나로 합쳐놓은 파일),privkey.pem(인증암호를 해독하는 개인키) 가 생성된다\nApache2는 cert.pem, chain.pem, privkey.pem 을 사용하고, Nginx는 fullchain.pem, privkey.pem 을 사용한다.\nNginx 설정 /etc/nginx/sites-available/default를 다음과 같이 수정한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 server { listen 80 default_server; listen [::]:80 default_server; server_name www.test.com test.com; return 301 https://$server_name$request_uri; } server { listen 443 default_server; listen [::]:443 default_server; root /var/www/html; index index.html index.htm index.php; server_name _; location / { try_files $uri $uri/ =404; } ssl on; ssl_certificate /etc/letsencrypt/live/test.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/test.com/privkey.pem; ssl_ciphers HIGH:!aNULL:!MD5; location ~ \\.php$ { include snippets/fastcgi-php.conf; fastcgi_pass unix:/var/run/php/php7.4-fpm.sock; } } 인증서 갱신 1 sudo letsencrypt renew 인증서 삭제 1 2 certbot revoke --cert-path /etc/letsencrypt/live/test.com/cert.pem certbot delete --cert-name test.com ","date":"2022-03-30T20:35:18+09:00","permalink":"https://cliearl.github.io/posts/linux/wordpress-setup/","title":"Linux + Nginx + MariaDB + PHP 셋업하고 WordPress 설치하기"},{"content":"이번 포스팅에서는 오픈소스의 라이센스를 표시하는 법에 대해 알아보도록 하겠습니다.\n오픈소스 라이센스 오픈소스는 오픈소스 소프트웨어(Open Source Software, OSS)의 줄임말입니다. OSS는 소스가 공개되어 있어 누구나 자유롭게 확인, 수정, 배포할 수 있습니다. 이용하는데 비용이 들지 않고 필요에 따라 마음대로 변형하여 사용할 수 있기 때문에 현대의 많은 소프트웨어들이 OSS에 의존하고 있습니다.\n그런데 OSS에는 라이센스, 그러니까 저작권이 존재합니다. 자유롭게 사용할 수는 있지만 그 대신 라이센스로 제한하는 사항은 필히 준수해야 할 필요가 있지요. 오픈소스 라이센스는 수많은 종류가 있는데요 2020년 기준 인기 Top 10 라이센스는 다음과 같다고 합니다.\n출처: https://www.whitesourcesoftware.com/resources/blog/open-source-licenses-trends-and-predictions/\n각 라이센스마다 제한사항도 다릅니다만, 주로 많이 사용되는 Apache, MIT, BSD 라이센스의 경우 카피라이트를 표시해주는 것 만으로 자유롭게 사용할 수 있습니다.\n출처: https://snyk.io/learn/open-source-licenses/\n안드로이드 앱을 만들다보면 수많은 오픈소스를 사용해야 합니다. 당장 androidx에 포함되는 수많은 라이브러리들부터가 오픈소스들이지요. 따라서 앱에 사용된 오픈소스의 라이센스를 앱 어딘가에 고지해야 할 필요가 있는데, 구글에서는 오픈소스의 라이센스를 편하게 고지할 수 있도록 OSS Licenses Gradle Plugin을 공개했습니다. 이 플러그인을 추가하면 새로운 액티비티의 형태로 라이센스 내용을 고지할 수 있습니다.\nOSS Licenses Gradle Plugin 적용하기 우선은 project 레벨의 build.gradle에 다음과 같이 플러그인을 추가합니다.\n1 2 3 4 5 buildscript { dependencies { classpath \u0026#34;com.google.android.gms:oss-licenses-plugin:0.10.4\u0026#34; } } 다음은 app레벨의 build.gradle에 다음과 같이 플러그인을 추가합니다.\n1 2 3 4 5 6 7 plugins { id \u0026#39;com.google.android.gms.oss-licenses-plugin\u0026#39; } dependencies { implementation \u0026#39;com.google.android.gms:play-services-oss-licenses:17.0.0\u0026#39; } 그러면 남은것은 OssLicensesMenuActivity를 startActivity로 실행시키면 됩니다. 여기서는 버튼을 하나 만들어서 새로운 액티비티를 띄우게 해 보겠습니다. setActivityTitle을 사용하면 액티비티에 제목을 지정할 수도 있습니다.\n1 2 3 4 binding.button.setOnClickListener { OssLicensesMenuActivity.setActivityTitle(\u0026#34;오픈소스 라이센스 목록\u0026#34;) startActivity(Intent(this, OssLicensesMenuActivity::class.java)) } 이렇게해서 앱에 사용된 오픈소스 라이센스를 표시하는 법에 대해 알아보았습니다.\n","date":"2022-03-13T14:50:32+09:00","permalink":"https://cliearl.github.io/posts/android/oss-licenses/","title":"앱에 사용된 Open source의 License 표시하기"},{"content":"이번 포스팅에서는 SharedPreferences의 암호화에 대해 알아보도록 하겠습니다.\nSharedPreferences의 저장방식 SharedPreferences에 대해서는 SharedPreferences로 앱 설정값 저장하고 불러오기에서 설명했던 적이 있습니다. 소규모의 데이터를 앱 안에 XML 파일로 간편하게 저장할 수 있는 저장소인데요, XML 파일은 앱 안의 다음 경로에 만들어지게 됩니다.\n1 /data/data/{package_name}/shared_prefs/{filename}.xml Android Studio의 Device File Explorer를 사용하면 지정한 위치에 파일이 생성되어 있는것을 알 수 있고 열어서 내용을 볼 수도 있습니다. 지난 강의에서 만들었던 xml의 내용은 다음과 같이 되어 있네요. 키와 값이 앱에서 지정한대로 기입되어있는 것을 확인할 수 있습니다.\n1 2 3 4 5 6 7 \u0026lt;?xml version=\u0026#39;1.0\u0026#39; encoding=\u0026#39;utf-8\u0026#39; standalone=\u0026#39;yes\u0026#39; ?\u0026gt; \u0026lt;map\u0026gt; \u0026lt;int name=\u0026#34;graphic_quality\u0026#34; value=\u0026#34;2131231054\u0026#34; /\u0026gt; \u0026lt;int name=\u0026#34;music_volume\u0026#34; value=\u0026#34;42\u0026#34; /\u0026gt; \u0026lt;boolean name=\u0026#34;vertical_sync\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;int name=\u0026#34;sfx_volume\u0026#34; value=\u0026#34;17\u0026#34; /\u0026gt; \u0026lt;/map\u0026gt; Security Library 하지만 앱의 데이터를 이렇게 쉽게 열어볼 수 있게 하는건 좋은 생각이 아닌 것 같습니다. 그래서 구글에서는 SharedPreferences를 암호화 하여 사용할 수 있게 하는 Security 라이브러리를 제공하고 있습니다.\nSecurity는 Android 6.0 (API level 23) 이상부터 사용 가능한데, 이 라이브러리를 사용하면 암호화에 사용할 마스터키를 만들고 그 키로 SharedPreferences의 내용을 암호화/복호화 할 수 있습니다.\n데이터를 암호화하는데에는 키가 필요한데요, 이 키를 앱 내부에 저장하면 어떤 형태로 숨겨도 결국은 유출이 가능하다고 생각하시면 됩니다. 그래서 Security 라이브러리는 Android keystore system을 사용해 키를 앱 내부가 아닌, 시스템만이 접근 가능한 컨테이너에 저장하도록 하였습니다.\nAndroid keystore system을 이용해 마스터키를 만들었으면 EncryptedSharedPreferences를 써서 SharedPreferences를 암호화/복호화할 수 있습니다.\n앱에 적용해보기 우선 Security 라이브러리를 추가합니다.\n1 implementation \u0026#34;androidx.security:security-crypto-ktx:1.1.0-alpha03\u0026#34; 다음은 읽기/쓰기에 사용하던 sharedPreferences 객체를 SharedPreferences가 아닌 EncryptedSharedPreferences 로부터 작성하면 됩니다. 기존의 인스턴스는 주석처리하고 다음과 같은 인스턴스를 만들어줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 private val sharedPreferences: SharedPreferences by lazy { val masterKeyAlias = MasterKey .Builder(applicationContext, MasterKey.DEFAULT_MASTER_KEY_ALIAS) .setKeyScheme(MasterKey.KeyScheme.AES256_GCM) .build() EncryptedSharedPreferences.create( applicationContext, FILE_NAME, masterKeyAlias, EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV, EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM ) } companion object { ... private const val FILE_NAME = \u0026#34;encrypted_settings\u0026#34; } 우선은 MasterKey 클래스로 암호화에 사용할 마스터키를 생성합니다. 키를 작성하는 알고리즘은 커스텀하여 사용할 수도 있게 되어있지만 여기서는 이미 잘 정의되어있는 AES-256 GCM 알고리즘을 사용하도록 하겠습니다.\n다음은 EncryptedSharedPreferences를 이용해 읽고쓰기에 사용할 sharedPreferences 인스턴스를 만들어줍니다. 초기화를 할 때에는 위에서 만든 마스터키와 xml 파일에 적용할 파일 이름, 그리고 데이터를 암호화할 방식을 전달해주면 됩니다. 여기서는 Key의 암호화에 AES256_SIV, 그리고 Value의 암호화에는 AES256_GCM을 사용하도록 했습니다.\n그리고 나머지는 SharedPreferences와 동일하게 사용하면 됩니다. 설정을 다시 저장한 뒤 encrypted_settings.xml의 내용을 확인해보면 다음과 같이 암호화가 되어 있는 것을 알 수 있습니다.\n1 2 3 4 5 6 7 8 9 \u0026lt;?xml version=\u0026#39;1.0\u0026#39; encoding=\u0026#39;utf-8\u0026#39; standalone=\u0026#39;yes\u0026#39; ?\u0026gt; \u0026lt;map\u0026gt; \u0026lt;string name=\u0026#34;__androidx_security_crypto_encrypted_prefs_key_keyset__\u0026#34;\u0026gt;12a901d15f8baa24b9e88a9e68f3eb32ad1136cb4af22776b91caea9459bdd5a76d6992b57e268408944152c70171556e4fa065b13160a6951b75a32dc8172d6ee9cbf8b9828f7cc80d68c23794340221ad89ac94306ec5848af9d9c6e6372fdfd42d745be4b4a6d532adc365491e249e92503b64743defab475808f196b90842cabb874cce6a934d0f646f9d9f285814ded11f3d081a72abeb09d6a1849b7768b9e9899601c59797868b0a71a4408beb9cea707123c0a30747970652e676f6f676c65617069732e636f6d2f676f6f676c652e63727970746f2e74696e6b2e4165735369764b6579100118beb9cea7072001\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;AXTznL5begfyWVUl+GcGajk7xoVmW0h2DCtZudxTAghw8BjV\u0026#34;\u0026gt;ARdDw2jfHocuzA3PXT73sMwCNATF/f+ZNWWcG6mgY0mhuMvLz9hGLys=\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;AXTznL6Ev8dJ1E4Ws4dwJfyeDUQgK077hhUwLNnCt+3opw==\u0026#34;\u0026gt;ARdDw2g859mf9i8UgWzWHvbZbBQytmCdcaXBVQgfy6+Qq/eIAs4=\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;__androidx_security_crypto_encrypted_prefs_value_keyset__\u0026#34;\u0026gt;128801aa5d8f25163f993b8f95a2a874a1353f227ffca6f2e5ee1dad9243b8b3a1ea16531bfa8a10da864655c9b33e865bf072eafcdad659912a5198bf32218f186c02ff3efff27338a50617f194c3fd8b06ebfad829c3a53dbfd8b221fa7f9103ad8e8ad1583250b5c1779b20b618e46a3edb0b50d3a3bdc8c7ace84c21a69f36d4996f9e7fe81e8bf01b1a4408e8868fba01123c0a30747970652e676f6f676c65617069732e636f6d2f676f6f676c652e63727970746f2e74696e6b2e41657347636d4b6579100118e8868fba012001\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;AXTznL4uW8pTacv6rnmZqMoGZHNWTJqwuD8q0XFlWnvw\u0026#34;\u0026gt;ARdDw2gTVJYJ3PCEaYgwoZjKMCEAFAv7aLRACnmcKGyjRaHYgeBJZJE=\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;AXTznL5AE+UHfloGh5ZBZ+3iZL2hplrdIffsC3I/qA==\u0026#34;\u0026gt;ARdDw2gRmqy+haYjIRDGML/ai32T5alKEQKaqlJDRhfQHcUIzthVAQo=\u0026lt;/string\u0026gt; \u0026lt;/map\u0026gt; 이렇게 해서 SharedPreference를 암호화하여 사용하는 법에 대해 알아보았습니다.\n","date":"2022-02-26T13:39:27+09:00","permalink":"https://cliearl.github.io/posts/android/encrypted-sharedpreferences/","title":"EncryptedSharedPreferences로 데이터 암호화하기"},{"content":"이번 포스팅에서는 내 앱의 MAD score를 평가하는 방법에 대해 알아보도록 하겠습니다.\nMAD score란 구글에서는 안드로이드 앱의 안정성을 향상시키기 위해 여러가지 기술을 도입해 왔는데요, 대표적인 것이 Kotlin 언어와 Jetpack 라이브러리라고 할 수 있을 것 같습니다.\n그 외에도 수많은 선진적인 기술을 도입하고 있습니다만, 그러한 기술을 단순히 도입하는데 그치지 않고 실제 개발자들이 기술을 더 잘 이해하고 사용할 수 있도록 Modern Android Development (MAD) Skills 라는 제목으로 블로그 포스팅도 하고, 유튜브에서 강의 영상도 제공하고 있습니다.\n그런데 구글은 여기에 한술 더 떠 내 앱에서 안드로이드의 MAD 기술을 얼마나 적극적으로 사용하고 있는지를 점수로 환산해주는 MAD score 시스템을 발표합니다. 점수에 따른 이익이나 불이익이 있는 것은 아니고, 그냥 높은 숫자를 추구하는 개발자들을 노린 MAD 포교활동이라 하면 맞을 것 같습니다.\nMAD score 확인하기 여기서는 구글의 Sunflower 프로젝트의 스코어를 확인해보기로 하죠. Sunflower 프로젝트는 구글에서 Jetpack 사용방법 설명을 위해 만든 예제 앱입니다. 다음 Github 주소에서 프로젝트를 다운받습니다.\nhttps://github.com/android/sunflower\n플러그인 설치 Android Studio에 MAD Scorecard 플러그인을 설치합니다. 2020년 12월 이후로 업데이트가 없는 점은 아쉽네요.\n플러그인 실행 Anaylyze -\u0026gt; Create MAD Scorecard를 선택해 스코어카드를 작성합니다. 앱 번들 유무를 체크하는데 없어도 스코어카드는 정상적으로 만들어집니다.\n결과 공유 스코어가 다음과 같이 매겨졌습니다. 100% 코틀린에 35개의 Jetpack 라이브러리를 사용했다고 나오네요. 역대 최고의 안드로이드 개발자인 MAD 레전드 칭호를 얻었습니다.\n전체 결과는 구글에 업로드 되며 다음 주소에서 확인할 수 있습니다.\nhttps://madscorecard.withgoogle.com/scorecards/3218056070/\n이렇게 해서 MAD score에 대해 알아보았습니다.\n","date":"2022-02-12T10:24:38+09:00","permalink":"https://cliearl.github.io/posts/android/evaluate-mad-score/","title":"내 앱의 MAD score 평가하기"},{"content":"이번 포스팅에서는 런타임 퍼미션에 대해 알아보도록 하겠습니다.\n들어가기 안드로이드는 카메라나 저장소, 위치 이용와 같이 시스템에 큰 영향을 미칠 수 있는 기능에 대해서는 위험한 권한으로 분류하여 다음과 같이 관리하고 있습니다.\n출처: https://ieeexplore.ieee.org/document/9272963\n과거에는 앱 설치시 모든 권한을 부여했지만 Android 6.0(API 레벨 23) 이상에서는 앱이 이런 위험한 권한들을 필요로 할 경우 앱 실행중에 권한을 요청할 수 있도록 시스템에 Runtime Permission 을 도입하였습니다. 여기서는 위치 권한을 예로들어 권한을 획득하는 방법을 보여드리겠습니다.\n필요한 권한 정의 우선은 AndroidManifest.xml에서 앱에 필요한 위험한 권한을 추가합니다. 위치에 관련된 권한은 두가지가 있는데 하나는 네트워크만을 이용해서 약 1.6km 이내로 위치를 파악하는 ACCESS_COARSE_LOCATION과, GPS도 같이 써서 위치를 약 50m 이내로 더 정확하게 파악하는 ACCESS_FINE_LOCATION이 있습니다.\n1 2 \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_COARSE_LOCATION\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_FINE_LOCATION\u0026#34; /\u0026gt; 요청하는 권한은 한 묶음으로 만들어 다루기 위해 REQUIRED_PERMISSIONS로 정의합니다.\n1 2 3 4 5 6 companion object { private val REQUIRED_PERMISSIONS = arrayOf( Manifest.permission.ACCESS_COARSE_LOCATION, // 도시 블록 단위 Manifest.permission.ACCESS_FINE_LOCATION, // 더 정밀한 단위 ) } 권한 확인 권한을 확인하는 함수를 작성합니다. ContextCompat.checkSelfPermission으로 해당 권한이 부여되었는지 확인할 수 있는데요, REQUIRED_PERMISSIONS에 대해 all을 수행하여 이중 하나라도 권한이 부여되지 않은 경우 isAllPermissionsGranted가 false를 반환하도록 했습니다.\n1 2 3 4 private fun isAllPermissionsGranted(): Boolean = REQUIRED_PERMISSIONS.all { permission -\u0026gt; ContextCompat.checkSelfPermission(this, permission) == PackageManager.PERMISSION_GRANTED } 화면 디자인 화면에 퍼미션을 체크하는 버튼을 하나 만듭니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/location_icon\u0026#34; android:layout_width=\u0026#34;48dp\u0026#34; android:layout_height=\u0026#34;48dp\u0026#34; android:layout_marginEnd=\u0026#34;12dp\u0026#34; android:src=\u0026#34;@drawable/ic_baseline_my_location_24\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toStartOf=\u0026#34;@+id/location_text\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintHorizontal_chainStyle=\u0026#34;packed\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/location_text\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Location\u0026#34; android:textSize=\u0026#34;24sp\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toEndOf=\u0026#34;@+id/location_icon\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; Callback을 이용한 권한 획득 requestDangerousPermissions 작성 버튼에 클릭리스너를 하나 만들어 권한이 부여되어있지 않으면 권한을 요청하는 로직을 구성합니다. 권한 요청에는 ActivityCompat.requestPermissions를 사용하는데, 이 때 request code가 필요하므로 companion object 안에 REQUEST_CODE_PERMISSIONS도 정의해 줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 binding.locationIcon.setOnClickListener { if (isAllPermissionsGranted()) { Snackbar.make(binding.root, \u0026#34;Permission granted\u0026#34;, Snackbar.LENGTH_SHORT).show() } else { requestDangerousPermissions() } } private fun requestDangerousPermissions() { ActivityCompat.requestPermissions( this, REQUIRED_PERMISSIONS, REQUEST_CODE_PERMISSIONS) } // companion object private const val REQUEST_CODE_PERMISSIONS = 1001 onRequestPermissionsResult requestDangerousPermissions에서 권한을 요청한 뒤 유저의 조작이 행해지면 그 결과는 onRequestPermissionsResult 콜백으로 받게 됩니다. onRequestPermissionsResult에서는 requestCode를 확인한 뒤 모든 권한이 취득된 경우, 확인 결과 권한이 취득되지 않았을 경우 shouldShowRequestPermissionRationale를 써서 권한을 재요청할 수 있습니다. 그럼에도 요청을 거부하면 앱은 더이상 권한을 요청할 수 없습니다. 다음 그림에 권한 요청의 순서를 나타내었습니다.\n출처: https://developer.android.com/training/permissions/requesting\n여기에서는 사용자가 모든 권한을 취득했으면 \u0026ldquo;Permission granted\u0026quot;를 보여주고, 요청을 거부하면 \u0026ldquo;Permission required to use app!\u0026ldquo;을 띄운뒤 권한을 다시 요구하도록 했습니다. 여기에서도 요청을 거부하면 마지막으로 Intent를 사용해 유저를 설정화면으로 직접 보내는 openSettings가 실행되도록 했습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 override fun onRequestPermissionsResult( requestCode: Int, permissions: Array\u0026lt;out String\u0026gt;, grantResults: IntArray ) { super.onRequestPermissionsResult(requestCode, permissions, grantResults) if (requestCode == REQUEST_CODE_PERMISSIONS) { if (grantResults.isNotEmpty() \u0026amp;\u0026amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) { // 모든 권한을 취득함 Snackbar.make(binding.root, \u0026#34;Permission granted\u0026#34;, Snackbar.LENGTH_SHORT).show() } else { if (shouldShowRequestPermissionRationale(REQUIRED_PERMISSIONS[0])) { // 권한을 다시 요구함 Snackbar.make(binding.root, \u0026#34;Permission required to use app!\u0026#34;, Snackbar.LENGTH_SHORT).show() requestDangerousPermissions() } else { // Settings로 들어가서 설정할 수 있도록 함 Snackbar.make(binding.root, \u0026#34;Permission denied\u0026#34;, Snackbar.LENGTH_SHORT).show() // openSettings() } } } } private fun openSettings() { Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply { addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) data = Uri.fromParts(\u0026#34;package\u0026#34;, packageName, null) }.run(::startActivity) } activity:1.2.0 이후의 권한 획득 방법 ActivityResultContract 그런데 구글은 onRequestPermissionsResult를 androidx.activity:activity:1.2.0-alpha04부터 deprecated 시키고, 시스템에서 전달된 결과를 처리하기 위해 ActivityResultContract를 새로 만들었습니다. ActivityResultContract를 사용하면 다음과 같이 미리 정의된 계약서를 전달하는것만으로 액티비티에서 결과를 손쉽게 가져올 수 있습니다.\nNested types CaptureVideo An ActivityResultContract to take a video saving it into the provided content-Uri. CreateDocument An ActivityResultContract to prompt the user to select a path for creating a new document, returning the content:Uri of the item that was create. GetContent An ActivityResultContract to prompt the user to pick a piece of content, receiving a content://Uri for that content that allows you to use android.content.ContentResolver.openInputStream to access the raw data. GetMultipleContents An ActivityResultContract to prompt the user to pick one or more a pieces of content, receiving a content://Uri for each piece of content that allows you to use android.content.ContentResolver.openInputStream to access the raw data. OpenDocument An ActivityResultContract to prompt the user to open a document, receiving its contents as a file:/http:/content:Uri. OpenDocumentTree An ActivityResultContract to prompt the user to select a directory, returning the user selection as a Uri. OpenMultipleDocuments An ActivityResultContract to prompt the user to open (possibly multiple) documents, receiving their contents as file:/http:/content:Uris. PickContact An ActivityResultContract to request the user to pick a contact from the contacts app. RequestMultiplePermissions An ActivityResultContract to request permissions RequestPermission An ActivityResultContract to request a permission StartActivityForResult An ActivityResultContract that doesn\u0026rsquo;t do any type conversion, taking raw Intent as an input and ActivityResult as an output. StartIntentSenderForResult An ActivityResultContract that calls Activity.startIntentSender. TakePicture An ActivityResultContract to take a picture saving it into the provided content-Uri. TakePicturePreview An ActivityResultContract to take small a picture preview, returning it as a Bitmap. TakeVideo An ActivityResultContract to take a video saving it into the provided content-Uri. 그럼 계약서 기능을 이용하기 위해 gradle에 Dependency를 추가합니다.\n1 implementation \u0026#34;androidx.activity:activity-ktx:1.4.0\u0026#34; requestMultiplePermissions 작성 여기서는 복수의 권한을 한번에 요청하기 위해 registerForActivityResult 에 RequestMultiplePermissions 계약서를 전달하고 ActivityResultLauncher를 반환받도록 했습니다. 한 개의 권한만을 요청할 경우에는 RequestPermission 을 전달하면 됩니다. 그리고 권한을 승인하였을때, 승인하지 않았을 때, 완전히 거부하였을 때에 대한 분기도 정의하여 줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private val requestPermissionLauncher = registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) { permissions -\u0026gt; permissions.entries.forEach { permission -\u0026gt; when { permission.value -\u0026gt; { Snackbar.make(binding.root, \u0026#34;Permission granted\u0026#34;, Snackbar.LENGTH_SHORT).show() } shouldShowRequestPermissionRationale(permission.key) -\u0026gt; { Snackbar.make(binding.root, \u0026#34;Permission required to use app!\u0026#34;, Snackbar.LENGTH_SHORT).show() } else -\u0026gt; Snackbar.make(binding.root, \u0026#34;Permission denied\u0026#34;, Snackbar.LENGTH_SHORT).show() } } } 마지막으로 이미 정의된 requestPermissions 는 주석처리하고 requestPermissionLauncher 를 launch로 실행시키면 됩니다. RequestMultiplePermissions 및 RequestPermission 내부의 getSynchronousResult 에는 권한을 체크하는 로직도 포함되어있기 때문에 사용방식에 따라서는 isAllPermissionsGranted 를 생략할 수도 있습니다.\n1 2 3 4 5 6 7 8 binding.locationIcon.setOnClickListener { if (isAllPermissionsGranted()) { Snackbar.make(binding.root, \u0026#34;Permission granted\u0026#34;, Snackbar.LENGTH_SHORT).show() } else { // requestPermissions() requestPermissionLauncher.launch(REQUIRED_PERMISSIONS) } } 이렇게 해서 런타임 퍼미션에 대해 알아보았습니다.\n","date":"2022-01-29T15:10:31+09:00","permalink":"https://cliearl.github.io/posts/android/request-runtime-permission/","title":"Runtime Permission 이해하고 요청 구현하기"},{"content":"Language and OS iOS Conf SG https://iosconf.sg/\niOS Conf SG 2022 Android Office Hours〜2022年の技術トレンド大予想！〜 https://mercari.connpass.com/event/236909/\nAndroid Office Hours〜2022年の技術トレンド大予想！〜 Android Dev Summit https://developer.android.com/events/dev-summit\nModern Android Development | Android Dev Summit \u0026lsquo;22 DroidKaigi https://droidkaigi.jp/2022/\nDroidKaigi 2022 Day 1 DroidKaigi 2022 Day 2 droidconberlin https://berlin.droidcon.com/?utm_source=droidcon\nWatch Video iOSDC Japan https://iosdc.jp/2022/\niOSDC Japan 2022 CppCon https://cppcon.org/\nCppCon 2022 JavaOne https://www.oracle.com/cloudworld/javaone/\nJavaOne 2022 Pycon Korea https://2022.pycon.kr/\nPyCon.KR 2022 Pycon US https://us.pycon.org/\nPyCon US 2022 let us: Go! https://let-us-go-2022-summer.vercel.app/\nlet us: Go! 2022 여름 Let\u0026rsquo;s Swift https://letswift.kr/2022/\nLet\u0026rsquo;Swift 2022 SyncSwift https://www.asyncswift.org/\nSyncSwift2022 Company \u0026amp; Community AWS Summit Korea https://aws.amazon.com/ko/events/summits/korea/\nAWS Summit Korea 2022 Apple Worldwide Developers Conference (WWDC) https://developer.apple.com/wwdc22\nSessions CES https://www.ces.tech/\nCES 2022 COMPUTEX https://www.computextaipei.com.tw/en/index.html\n2022 COMPUTEX CEO Keynotes DELL Technologies Forum https://events.dell.com/event/8721d365-6b70-46e5-aa0c-240d89e01ea2/summary\nSessions DeNA TechCon https://techcon2022.dena.dev/spring/\nDeNA TechCon 2022 FEConf https://2022.feconf.kr/\nFEConf 2022 A Track FEConf 2022 B Track if (kakao) https://if.kakao.com/\nSession Kakao NEMO https://nemo.kakaomobility.com/\nNEMO 2022 Google I/O https://io.google/2022/intl/ko/\nAll Google I/O 2022 Sessions INFCON https://infcon.day/\n🌱 INFCON 2022 Microsoft Build https://news.microsoft.com/build2022\nMicrosoft Build 2022 Microsoft Ignite https://news.microsoft.com/ignite-2022/\nMicrosoft Ignite 2022 Naver SOFTWARE EDU FEST https://sef.connect.or.kr/2022\n[SEF] 소프트웨어 교육 컨퍼런스: 누구나 소프트웨어를 배울 수 있습니다. Naver Cloud Summit https://www.ncloud-online.com/navercloudsummit2022/\nNAVER Cloud SUMMIT 2022 NHN Cloud make IT https://makeit.nhncloud.com/2022/\nNHN Cloud make IT 2022 NHN Forward https://forward.nhn.com/2022\nNHN FORWARD 2022 Oracle Developer Day https://go.oracle.com/LP=120553?elqCampaignId=326404\nDay 1 - Developer Days - Oracle Cloud Region Querétaro (Spanish) Day 2 - Developer Days - Oracle Cloud Region Querétaro (Spanish) Day 3 - Developer Days - Oracle Cloud Region Querétaro (Spanish) PASCON https://www.dailysecu.com/form/register.html?form_id=1639447124\nPASCON2022 Qcon Plus https://plus.qconferences.com/recap/may2022\nQCon Plus (Virtual Event) Samsung Software Developer Conference https://www.soscon.net/\nReplay Techfeed https://techfeed.io/events/techfeed-conference-2022\nTechFeed Conference 2022 Toss Slash https://toss.im/slash-22\nSLASHㅣ개발자 컨퍼런스 Ubucon Asia https://2022.ubucon.asia/ko/\nUbuCon Asia 2022 Upbit Developer Conference https://udc.upbit.com/\nUDC 2022 | Imagine your Blockchain Life | Preview Woowacon https://www.woowacon.com/\n우아콘 2022: 문 앞으로 일상의 행복을 배달하기까지 Qiita Engineer Festa https://qiita.com/official-campaigns/engineer-festa/2022\nQiita Engineer Festa 2022 Online Meetup Yahoo! JAPAN Tech Conference https://techconference.yahoo.co.jp/2022/\nYahoo! JAPAN Tech Conference 2022 技術書典 https://techbookfest.org/\n技術に出会える - 技術書典12スペシャルオンラインイベント 技術に出会える - 技術書典13スペシャルオンラインイベント 프로그래머스 컨퍼런스 https://pgconf.vfairs.com/\n프로그래머스 온라인 컨퍼런스 1st(2022/11/26) 한국소프트웨어종합학술대회 https://www.kiise.or.kr/conference/KSC/2022/\nKCC2022(2022 한국컴퓨터종합학술대회) Artificial Intelligence 제6회 AI 차세대 컨택센터 컨퍼런스 https://conference.etnews.com/conf_info.html?uid=198\n제6회 AI 차세대 컨택센터 컨퍼런스 2022 AI 페스티벌 https://aifesta.co.kr/\n2022 AI FESTIVAL COLING https://coling2022.org/\nSocialDisNER (SMM4H) @ COLING 2022 Connect To Code https://event-us.kr/c2c/event/50535\n2022 Connect To Code(KOR) HMG Developer Conference https://www.hmgdevcon.com/2022/\n제2회 HMG Developer Conference Tech-Verse https://tech-verse.me/ko\nSessions Big Data 데이터야놀자 https://datayanolja.kr/\n데이터야놀자2022 발표영상 마이데이터 컨퍼런스 https://festa.io/events/2627\n4. 마이데이터 컨퍼런스 DATA Conference http://www.itdaily.kr/eventConfig/html/event_inc.html?eventcode=event11\n2022 데이터 컨퍼런스 데이터 그랜드 컨퍼런스 https://dataconference.or.kr/\n2022 데이터 그랜드 컨퍼런스 Cloud AWS re:Invent https://reinvent.awsevents.com/\nAWS re:Invent 2022 Google Cloud Next https://cloud.withgoogle.com/next\nGoogle Cloud Next \u0026lsquo;22 - All Sessions Games Game Developers Conference (GDC) https://gdconf.com/\nGDC 2022 Nexon Developers Conference (NDC) https://ndc.nexon.com/main\nNDC22 [NDC22] 1일차 [NDC22] 2일차 [NDC22] 3일차 NVIDIA GPU Technology Conference (GTC) https://www.nvidia.com/ko-kr/gtc/\nGTC 2022 Keynote and Related Talks RULICON https://bbs.ruliweb.com/rulicon\n루리콘(RULICON) 2022 BIC Festival https://bicfest.org/\nBIC Festival 2022 ","date":"2022-01-20T21:50:20+09:00","permalink":"https://cliearl.github.io/posts/conferences/2022/","title":"2022년 개발관련 컨퍼런스 리스트"},{"content":"안녕하세요 냉동코더입니다. 다사다난했던 2021년도 어느새 마지막을 향해 가고 있네요.\n이 채널은 딱히 정해진 주제가 있는 것은 아닙니다. 처음에는 게임을 개발하는 영상을 올렸지만, 금년은 코틀린으로 안드로이드 앱을 개발할 때 알아두면 좋을, 코드 스니펫이나 기초이론을 설명하는 영상을 업로드 하였습니다.\n‘안드로이드 스튜디오에서 코틀린으로’ 시리즈는 제가 안드로이드 앱을 만들면서 찾아보고 정리한 내용을 같이 공유하면 좋겠다는 생각에서 만들기 시작한 영상입니다. 많은 분들이 영상을 찾아봐 주시고 구독과 좋아요도 눌러주셔서 영상을 준비하는데 많은 힘이 되었습니다.\n냉동코더 채널은 지난 1년간 1.4만회의 조회수가 나왔고 230여 분의 새로운 구독자 분들이 채널을 구독해 주셨습니다. 이렇다 할 재밌는 편집점도 없는 평범한 영상을 꾸준히 봐주셔서 감사합니다. 다음은 구독자 천명을 목표로 달려보려고 합니다.\n저의 내년 키워드는 Modern Android Development입니다. 앱 아키텍처 가이드와 제트팩이 발표된 이후로 라이브러리의 수많은 수정과 갱신이 있었는데, 이제는 어느정도 안정궤도에 올랐다고 생각했는지 구글에서는 금년 12월에 새로운 앱 아키텍처 가이드를 발표했습니다.\n마침 좋은 기회다 싶어서 내년에는 제트팩 라이브러리와 MVVM구조를 잘 이해하고 사용하는 법에 대한 유료강의를 만들어 볼 계획입니다. 돈을 주고 봐도 아깝지 않은 강의가 되도록 잘 만들어보겠습니다. 목표는 여름휴가가 오기 전에 제작을 완료하는 것인데, 일정이라는것은 항상 안맞는 것이라 확실한 약속을 드리지는 못하는 점 양해부탁드립니다.\n코로나로 인해 여러가지로 불편하고 어려운 날들이 이어지고 있습니다. 그래도 인류 역사속에서 늘 그래왔듯이 인간의 지혜가 코로나에 대한 답을 찾을 것이라 믿으며 내년을 맞이하려고 합니다. 아무쪼록 구독자 여러분들도 따뜻한 연말연시 보내시고 건강하시길 빕니다.\n","date":"2021-12-31T19:08:17+09:00","permalink":"https://cliearl.github.io/posts/etc/2022-newyear-greeting/","title":"2021년 잘 마무리하시고 새해 복 많이 받으세요"},{"content":"들어가기 findViewById 대신 View Binding 사용하기 강의에서 View Binding에 대해 다루었습니다. View Binding을 도입하면 코드를 더 안전하게 작성할 수 있고 빌드도 빠르게 할 수 있습니다.\nFragment에서의 메모리 누수 그런데 Fragment에서 View Binding을 쓸 때는 메모리 누수가 일어날 수 있는 문제가 있습니다. 다음 그림을 보시면 Fragment 속의 View는 onDestroyView에서 파괴되고 생명주기가 종료되지만, 그 시점에서 Fragment는 여전히 유지되고 있는 것을 알 수 있습니다.\n메모리 누수 대응법 _binding의 직접 해제 그래서 구글에서는 Fragment에서 View Binding을 적용할 때 다음과 같이 _binding 변수를 만들어 사용한 뒤 onDestroyView에서 해제해주는 구조를 공식 문서 에서 제안하고 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class FirstFragment : Fragment() { private var _binding : FragmentFirstBinding? = null private val binding get() = _binding!! override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { _binding = FragmentFirstBinding.inflate(inflater, container, false) return binding.root } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) ... } } override fun onDestroyView() { super.onDestroyView() _binding = null } } AutoClearedValue 사용하기 그런데 Fragment마다 _binding을 사용하면 보일러플레이트 코드가 너무 많아지고, 리소스를 해제하는 걸 깜박할 수도 있습니다. 그래서 구글에서는 binding의 초기화를 위임하는 AutoClearedValue라는 개념을 제안했습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /* * Copyright (C) 2018 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package com.android.example.github.util import androidx.fragment.app.Fragment import androidx.lifecycle.DefaultLifecycleObserver import androidx.lifecycle.LifecycleOwner import androidx.lifecycle.observe import kotlin.properties.ReadWriteProperty import kotlin.reflect.KProperty /** * A lazy property that gets cleaned up when the fragment\u0026#39;s view is destroyed. * * Accessing this variable while the fragment\u0026#39;s view is destroyed will throw NPE. */ class AutoClearedValue\u0026lt;T : Any\u0026gt;(val fragment: Fragment) : ReadWriteProperty\u0026lt;Fragment, T\u0026gt; { private var _value: T? = null init { fragment.lifecycle.addObserver(object: DefaultLifecycleObserver { override fun onCreate(owner: LifecycleOwner) { fragment.viewLifecycleOwnerLiveData.observe(fragment) { viewLifecycleOwner -\u0026gt; viewLifecycleOwner?.lifecycle?.addObserver(object: DefaultLifecycleObserver { override fun onDestroy(owner: LifecycleOwner) { _value = null } }) } } }) } override fun getValue(thisRef: Fragment, property: KProperty\u0026lt;*\u0026gt;): T { return _value ?: throw IllegalStateException( \u0026#34;should never call auto-cleared-value get when it might not be available\u0026#34; ) } override fun setValue(thisRef: Fragment, property: KProperty\u0026lt;*\u0026gt;, value: T) { _value = value } } /** * Creates an [AutoClearedValue] associated with this fragment. */ fun \u0026lt;T : Any\u0026gt; Fragment.autoCleared() = AutoClearedValue\u0026lt;T\u0026gt;(this) 구조를 보면 AutoclearedValue는 viewLifecycleOwnerLiveData를 구독하고 있습니다. 따라서 onDestroy의 타이밍에 바인딩을 자동으로 해방시켜 줍니다. 그러면 _binding을 사용하던 위의 코드는 AutoclearedValue를 적용해서 다음과 같이 다시 쓸 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class FirstFragment : Fragment() { private var binding by autoCleared\u0026lt;FragmentFirstBinding\u0026gt;() override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { binding = FragmentFirstBinding.inflate(inflater, container, false) return binding.root } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) ... } } } ViewBindingPropertyDelegate 사용 AutoclearedValue는 어디까지나 코드 스니펫일 뿐이므로 업데이트가 있을 경우 관리가 쉽지 않습니다. 그래서 이 작업을 하기위해 만들어진 ViewBindingPropertyDelegate라는 라이브러리를 사용하는 방법이 있습니다.\nDependency를 추가한 뒤 Fragment를 다음과 같이 초기화하여 사용하면 됩니다.\n1 2 3 class ProfileFragment : Fragment(R.layout.profile) { private val viewBinding by viewBinding(ProfileBinding::bind) } 이렇게 해서 View Binding을 사용할 때 발생할 수 있는 Fragment의 메모리 누수를 방어하는 법에 대해 알아보았습니다.\n","date":"2021-12-05T10:20:46+09:00","permalink":"https://cliearl.github.io/posts/android/prevent-fragment-memory-leak-during-viewbinding/","title":"View Binding 사용시 Fragment의 메모리 누수 대응하기"},{"content":"Support Library Support Library의 필요성 구글에서는 Android API의 하위 호환성 문제를 해결하기 위해 Support Library를 만들었습니다. 예를들어 롤리팝(API 21)부터 도입된 RecyclerView는 API 21 이하의 기기에서는 사용할 수 없지만 다음 서포트 라이브러리를 추가하면 API 7 이상의 기기부터 RecyclerView를 사용할 수 있습니다.\n1 com.android.support:recyclerview-v7:28.0.0 com.android.support로 시작하는 서포트 라이브러리는 수많은 종류가 준비되어 있습니다. 이중에는 v4, v7, v13 등 v가 붙은 패키지들이 있는데요, 이것들은 각각 사용가능한 최소 API 레벨을 의미합니다. 예를들어 v4가 붙어있으면 API 레벨 4부터 이용할 수 있는 라이브러리라는 의미이지요.\nSupport Library의 문제점 그런데 Support Library에는 몇가지 문제점이 있었습니다.\n최소지원 API레벨 문제 구글은 2017년 Google I/O 세션인 What\u0026rsquo;s new in Android Support Library에서 Support Library version 26.0.0 부터는 최소지원 API 레벨을 Android 4.0 (API level 14)으로 올리겠다는 발표를 합니다. 너무 오래된 기종들의 사용을 막기 위해 취한 조치이긴 하나, 이로인해 라이브러리 이름에 v7이 붙어있어도 최소지원 API 레벨은 14인 이상한 현상이 발생하게 된 것입니다.\n필요없는 라이브러리의 추가 Support Library는 수많은 API들을 통합한 라이브러리이기 때문에 내가 사용하지 않는 기능도 같이 앱에 포함되게 됩니다. 단일 DEX가 65,536 개의 메소드만을 가질 수 있는 Dalvik 체계에서 서포트 라이브러리때문에 멀티DEX를 사용해야 하는 경우가 생길 수도 있습니다.\n버전통일 문제 복수개의 서포트 라이브러리를 사용하는 경우 모든 버전을 동일하게 유지해야 합니다. 예를들어 다음과 같이 라이브러리를 사용중에 cardview에 문제가 있어서 27.1.0으로 버전을 내릴 경우 다른 라이브러리도 모두 27.1.0으로 내려야 하는 것이죠.\n1 2 3 implementation com.android.support:appcompat-v7:27.1.1 implementation com.android.support:design:27.1.1 implementation com.android.support:cardview-v7:27.1.1 Androidx 체계의 도입 이러한 이름체계의 혼란을 정리하기 위해 구글은 2018년 Google I/O 세션인 Android Jetpack: What’s new in Android Support Library에서 라이브러리 패키징방식의 변경을 발표합니다. 봄맞이 대청소를 통해 Android Extension Libraries라는 명칭으로 바뀐 서포트 라이브러리는 androidx라는 네임스페이스를 부여받게 되었고 다음과 같은 원칙하에 요소들을 관리하게 됩니다.\n1. 라이브러리의 기능별 분리 발표에 따르면 support-core-ui는 asynclayoutinflater, drawerlayout, interpolator, cursoradapter, customview, slideingpanellayout, swiperefreshlayout, viewpager 등으로 쪼개집니다. 따라서 viewpager가 필요하면 쓰지도 않는 나머지 dependency를 모두 임포트할 필요 없이 viewpager를 바로 임포트하면 됩니다.\n2. Versioning 방식 변경 API 레벨과 동기화되어 올라가던 Versioning 방식은 28.0.0 부터 1.0.0으로 리셋되고 Major.Minor.Patch 형식의 엄격한 Semantic Versioning을 준수하게 됩니다. 버전으로부터 Patch는 버그픽스이고, Minor는 기능추가, Major는 바이너리의 호환성이 없다는 사실을 이제 명확하게 파악할 수 있습니다.\n라이브러리 전체의 변경이 아닌 아티팩트당 버전 변경이 이루어지게 되므로 예를들어 RecyclerView의 업데이트가 이루어지면 RecyclerView 패키지만을 개별적으로 업데이트할 수 있습니다.\n3. 패키징 방식 변경 android.support.v7.app 과 같은 이름을 가져서, 어떤 기능이 포함되어 있는지 알 수 없었던 기존 Support library의 문제점을 개선하기 위해, 패키지 이름은 기능을 직관적으로 나타내도록 변경되었습니다.\nJava Package : androidx.\u0026lt;feature\u0026gt;.ClassName Maven id : androidx.\u0026lt;feature\u0026gt;:\u0026lt;feature\u0026gt;-\u0026lt;sub-feature\u0026gt; 변화된 Java package와 Maven artifact의 리스트는 각각 Class Mappings와 Artifact Mappings 문서에서 확인할 수 있습니다.\nAndroidx의 최신 릴리즈 내용은 AndroidX releases에서 확인할 수 있고 각 릴리즈 노트는 Recent Release Notes에 정리하고 있습니다. 그리고 각 릴리즈의 개별 커밋은 Github에서 확인할 수 있습니다.\nAndroid Jetpack 그리고 Androidx를 소개했던 세션에서 Jetpack도 같이 발표됩니다.\nJetpack is a suite of libraries to help developers follow best practices, reduce boilerplate code, and write code that works consistently across Android versions and devices so that developers can focus on the code they care about.\nJetpack은 한마디로 안드로이드 앱을 더 완성도 높게 만들 수 있는 라이브러리의 모음입니다. 주로 androidx의 라이브러리가 포함되지만 androidx가 아닌 라이브러리가 포함될 수도 있습니다.\n같은 기능을 구현하더라도 개발자의 숙련도에 따라 앱의 안정성이 달라지는 현상을 가능한 줄이기 위해 구글에서 가이드라인을 만들었고 그 가이드라인에 따르기 위해 사용해야할 라이브러리를 정의한 문서스펙이라고 생각하시면 좋을 것 같습니다.\nJetpack은 Architecture, UI, Behavior, Foundation 의 네 가지 카테고리로 구성되어 있고 각 카테고리는 그림에 보이는 것과 같은 컴포넌트들이 해당됩니다. 각 컴포넌트는 개별적으로 앱에서 사용 가능하고 이전 버전과 호환성을 유지할 수 있게 구성되었는데요, Introducing Android Jetpack for developers에 따르면 Jetpack은 다음과 같은 특징을 갖는다고 하네요.\nModern App Architecture Eliminate Boiler Plate Code Simplifying Complex Tasks Robust Backwards Compatibility 그림에 표시한 것 외에도 Jetpack에는 수많은 컴포넌트들이 있는데 이들의 전체 리스트와 각각의 기능은 Explore the Jetpack libraries에서 확인하실 수 있습니다.\n이렇게 해서 Support library와 Androidx와 Jetpack에 대해 알아보았습니다.\n","date":"2021-11-21T10:55:30+09:00","permalink":"https://cliearl.github.io/posts/android/support-library-androidx-jetpack/","title":"Support Library와 Androidx와 Jetpack"},{"content":"Mermaid.js는 자바스크립트 기반의 차트 툴이다. 이를 Hugo에서 사용하는 방법이 있어 소개한다.\nHugo shortcode 설정 layouts/shortcodes/ 아래에 다음과 같은 파일을 작성하여 shortcode로 사용할 수 있도록 한다. 이 때 package version은 항상 최신의 것을 가져오도록 한다.\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script async type=\u0026#34;application/javascript\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js\u0026#34;\u0026gt; var config = { startOnLoad:true, theme:\u0026#39;{{ if .Get \u0026#34;theme\u0026#34; }}{{ .Get \u0026#34;theme\u0026#34; }}{{ else }}neutral{{ end }}\u0026#39;, align:\u0026#39;{{ if .Get \u0026#34;align\u0026#34; }}{{ .Get \u0026#34;align\u0026#34; }}{{ else }}center{{ end }}\u0026#39; }; mermaid.initialize(config); \u0026lt;/script\u0026gt; \u0026lt;div class=\u0026#34;mermaid\u0026#34;\u0026gt; {{.Inner}} \u0026lt;/div\u0026gt; Mermaid로 그릴 수 있는 차트 종류 더 구체적인 사용방법은 mermaid 홈페이지 에서 확인 가능하다.\nFlow graph TD A[Hard] --\u003e|Text| B(Round) B --\u003e C{Decision} C --\u003e|One| D[Result 1] C --\u003e|Two| E[Result 2] 1 2 3 4 5 graph TD A[Hard] --\u0026gt;|Text| B(Round) B --\u0026gt; C{Decision} C --\u0026gt;|One| D[Result 1] C --\u0026gt;|Two| E[Result 2] Sequence sequenceDiagram Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003e\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts! John--\u003e\u003eAlice: Great! John-\u003e\u003eBob: How about you? Bob--\u003e\u003eJohn: Jolly good! 1 2 3 4 5 6 7 8 9 sequenceDiagram Alice-\u0026gt;\u0026gt;John: Hello John, how are you? loop Healthcheck John-\u0026gt;\u0026gt;John: Fight against hypochondria end Note right of John: Rational thoughts! John--\u0026gt;\u0026gt;Alice: Great! John-\u0026gt;\u0026gt;Bob: How about you? Bob--\u0026gt;\u0026gt;John: Jolly good! Gantt gantt section Section Completed :done, des1, 2014-01-06,2014-01-08 Active :active, des2, 2014-01-07, 3d Parallel 1 : des3, after des1, 1d Parallel 2 : des4, after des1, 1d Parallel 3 : des5, after des3, 1d Parallel 4 : des6, after des4, 1d 1 2 3 4 5 6 7 8 gantt section Section Completed :done, des1, 2014-01-06,2014-01-08 Active :active, des2, 2014-01-07, 3d Parallel 1 : des3, after des1, 1d Parallel 2 : des4, after des1, 1d Parallel 3 : des5, after des3, 1d Parallel 4 : des6, after des4, 1d Class classDiagram Class01 \u003c|-- AveryLongClass : Cool Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla 1 2 3 4 5 6 7 8 9 10 classDiagram Class01 \u0026lt;|-- AveryLongClass : Cool Class09 --\u0026gt; C2 : Where am i? Class09 --* C3 Class09 --|\u0026gt; Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla State stateDiagram-v2 [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] 1 2 3 4 5 6 7 stateDiagram-v2 [*] --\u0026gt; Still Still --\u0026gt; [*] Still --\u0026gt; Moving Moving --\u0026gt; Still Moving --\u0026gt; Crash Crash --\u0026gt; [*] Pie pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 1 2 3 4 pie \u0026#34;Dogs\u0026#34; : 386 \u0026#34;Cats\u0026#34; : 85 \u0026#34;Rats\u0026#34; : 15 User Journey journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 3: Me 1 2 3 4 5 6 7 8 9 journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 3: Me ","date":"2021-11-08T10:56:19+09:00","permalink":"https://cliearl.github.io/posts/etc/mermaid-usage/","title":"Hugo에서 mermaid 사용하기"},{"content":"이번 포스팅에서는 Retrofit 라이브러리로 HTTP 통신을 수행하는 법에 대해 알아보도록 하겠습니다.\n안드로이드에서의 HTTP 통신에 대한 개괄적 설명과 Retrofit을 사용해야 하는 이유에 대해서는 안드로이드의 HTTP 통신 라이브러리 고찰에서 다루었으니 그것을 참조하시면 좋을 것 같습니다. 또한 Retrofit의 기술적 특징에 대해서는 라이브러리 제작자가 설명해 둔 Retrofit 2과 함께하는 정말 쉬운 HTTP 를 보는것이 가장 정확할 것 같습니다.\n이 강의에서는 경기데이터드림에서 제공하는 코로나바이러스 감염증 선별진료소 운영 의료기관 현황 API를 통해 가져온 JSON 데이터를 Recyclerview에 표시해보면서 Retrofit을 어떻게 사용하는지 알아보도록 하겠습니다.\n라이브러리 추가 build.gradle에 Retrofit과 JSON을 다루기 위한 Moshi 컨버터, 그리고 로그를 찍기위한 OkHttp 라이브러리를 추가해 줍니다.\n1 2 3 4 5 6 7 // Retrofit implementation \u0026#39;com.squareup.retrofit2:retrofit:2.9.0\u0026#39; implementation \u0026#39;com.squareup.retrofit2:converter-moshi:2.9.0\u0026#39; // OkHttp implementation \u0026#39;com.squareup.okhttp3:okhttp:4.9.1\u0026#39; implementation \u0026#39;com.squareup.okhttp3:logging-interceptor:4.9.1\u0026#39; 권한 추가 HTTP 통신에 인터넷을 사용해야 하니 AndroidManefest.xml에서 권한을 추가해줍니다.\n1 \u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34; /\u0026gt; Data Transfer Object 준비 데이터 형식 확인 API의 주소인 https://openapi.gg.go.kr/EmgMedInfo?type=json 에 웹브라우저로 접속해보면 다음과 같은 값을 반환받게 됩니다. \u0026quot;head\u0026quot;안의 항목은 필요하지 않은 메타정보이고, \u0026quot;row\u0026quot; 안의 내용이 Recyclerview로 표시해야 하는 것들입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 { \u0026#34;EmgMedInfo\u0026#34;: [ { \u0026#34;head\u0026#34;: [ { \u0026#34;list_total_count\u0026#34;: 172 }, { \u0026#34;RESULT\u0026#34;: { \u0026#34;CODE\u0026#34;: \u0026#34;INFO-000\u0026#34;, \u0026#34;MESSAGE\u0026#34;: \u0026#34;정상 처리되었습니다.\u0026#34; } }, { \u0026#34;api_version\u0026#34;: \u0026#34;1.0\u0026#34; } ] }, { \u0026#34;row\u0026#34;: [ { \u0026#34;SUM_DE\u0026#34;: \u0026#34;2021-06-09\u0026#34;, \u0026#34;SIGUN_NM\u0026#34;: \u0026#34;화성시\u0026#34;, \u0026#34;SIGUN_CD\u0026#34;: \u0026#34;41590\u0026#34;, \u0026#34;MEDCARE_INST_NM\u0026#34;: \u0026#34;센트럴아동병원\u0026#34;, \u0026#34;DISTRCT_DIV_NM\u0026#34;: \u0026#34;국민안심병원+호흡기전담클리닉\u0026#34;, \u0026#34;REPRSNT_TELNO\u0026#34;: null, \u0026#34;EMGNCY_CENTER_TELNO\u0026#34;: \u0026#34;031-8060-5000\u0026#34;, \u0026#34;REFINE_LOTNO_ADDR\u0026#34;: \u0026#34;경기도 화성시 반송동 93-1번지 동탄위버폴리스\u0026#34;, \u0026#34;REFINE_ROADNM_ADDR\u0026#34;: null, \u0026#34;REFINE_WGS84_LOGT\u0026#34;: \u0026#34;127.0720402235\u0026#34;, \u0026#34;REFINE_WGS84_LAT\u0026#34;: \u0026#34;37.2046139805\u0026#34; }, { \u0026#34;SUM_DE\u0026#34;: \u0026#34;2021-06-14\u0026#34;, \u0026#34;SIGUN_NM\u0026#34;: \u0026#34;화성시\u0026#34;, \u0026#34;SIGUN_CD\u0026#34;: \u0026#34;41590\u0026#34;, \u0026#34;MEDCARE_INST_NM\u0026#34;: \u0026#34;한림대학교 동탄성심병원\u0026#34;, \u0026#34;DISTRCT_DIV_NM\u0026#34;: \u0026#34;선별진료소+국민안심병원\u0026#34;, \u0026#34;REPRSNT_TELNO\u0026#34;: \u0026#34;031-8086-3000\u0026#34;, \u0026#34;EMGNCY_CENTER_TELNO\u0026#34;: \u0026#34;1522-2500\u0026#34;, \u0026#34;REFINE_LOTNO_ADDR\u0026#34;: \u0026#34;경기도 화성시 석우동 40번지\u0026#34;, \u0026#34;REFINE_ROADNM_ADDR\u0026#34;: \u0026#34;경기도 화성시 큰재봉길 7\u0026#34;, \u0026#34;REFINE_WGS84_LOGT\u0026#34;: \u0026#34;127.0799416615\u0026#34;, \u0026#34;REFINE_WGS84_LAT\u0026#34;: \u0026#34;37.2164957291\u0026#34; }, { \u0026#34;SUM_DE\u0026#34;: \u0026#34;2021-06-09\u0026#34;, \u0026#34;SIGUN_NM\u0026#34;: \u0026#34;구리시\u0026#34;, \u0026#34;SIGUN_CD\u0026#34;: \u0026#34;41310\u0026#34;, \u0026#34;MEDCARE_INST_NM\u0026#34;: \u0026#34;장스365의원\u0026#34;, \u0026#34;DISTRCT_DIV_NM\u0026#34;: \u0026#34;호흡기전담클리닉\u0026#34;, \u0026#34;REPRSNT_TELNO\u0026#34;: null, \u0026#34;EMGNCY_CENTER_TELNO\u0026#34;: \u0026#34;031-550-3105\u0026#34;, \u0026#34;REFINE_LOTNO_ADDR\u0026#34;: \u0026#34;경기도 구리시 수택동 853번지\u0026#34;, \u0026#34;REFINE_ROADNM_ADDR\u0026#34;: null, \u0026#34;REFINE_WGS84_LOGT\u0026#34;: \u0026#34;127.1426473636\u0026#34;, \u0026#34;REFINE_WGS84_LAT\u0026#34;: \u0026#34;37.5912595849\u0026#34; }, { \u0026#34;SUM_DE\u0026#34;: \u0026#34;2021-06-09\u0026#34;, \u0026#34;SIGUN_NM\u0026#34;: \u0026#34;김포시\u0026#34;, \u0026#34;SIGUN_CD\u0026#34;: \u0026#34;41570\u0026#34;, \u0026#34;MEDCARE_INST_NM\u0026#34;: \u0026#34;김포아이제일병원\u0026#34;, \u0026#34;DISTRCT_DIV_NM\u0026#34;: \u0026#34;호흡기전담클리닉\u0026#34;, \u0026#34;REPRSNT_TELNO\u0026#34;: null, \u0026#34;EMGNCY_CENTER_TELNO\u0026#34;: \u0026#34;031-8083-7575\u0026#34;, \u0026#34;REFINE_LOTNO_ADDR\u0026#34;: \u0026#34;경기도 김포시 구래동 6885-2번지\u0026#34;, \u0026#34;REFINE_ROADNM_ADDR\u0026#34;: \u0026#34;경기도 김포시 김포한강8로 382\u0026#34;, \u0026#34;REFINE_WGS84_LOGT\u0026#34;: \u0026#34;126.6266409118\u0026#34;, \u0026#34;REFINE_WGS84_LAT\u0026#34;: \u0026#34;37.6435680201\u0026#34; }, { \u0026#34;SUM_DE\u0026#34;: \u0026#34;2021-06-09\u0026#34;, \u0026#34;SIGUN_NM\u0026#34;: \u0026#34;성남시\u0026#34;, \u0026#34;SIGUN_CD\u0026#34;: \u0026#34;41130\u0026#34;, \u0026#34;MEDCARE_INST_NM\u0026#34;: \u0026#34;분당성모이비인후과의원\u0026#34;, \u0026#34;DISTRCT_DIV_NM\u0026#34;: \u0026#34;호흡기전담클리닉\u0026#34;, \u0026#34;REPRSNT_TELNO\u0026#34;: null, \u0026#34;EMGNCY_CENTER_TELNO\u0026#34;: \u0026#34;031-712-9075\u0026#34;, \u0026#34;REFINE_LOTNO_ADDR\u0026#34;: \u0026#34;경기도 성남시 분당구 야탑동 352-4번지\u0026#34;, \u0026#34;REFINE_ROADNM_ADDR\u0026#34;: \u0026#34;경기도 성남시 분당구 성남대로925번길 11\u0026#34;, \u0026#34;REFINE_WGS84_LOGT\u0026#34;: \u0026#34;127.1272733859\u0026#34;, \u0026#34;REFINE_WGS84_LAT\u0026#34;: \u0026#34;37.4120484252\u0026#34; } ] } ] } DTO 클래스 작성 JSON 형식으로 받아온 텍스트는 앱에서 사용할 수 있는 데이터 객체로 변환하게 되는데 이 때 그 객체의 틀이 되는것이 Data Transfer Object (DTO)입니다.\n그럼 이 JSON에 대응하는 DTO를 작성합니다. JSON To Kotlin Class 플러그인에 위의 JSON을 붙여넣고 EmgMedResponse라는 이름으로 변환하면 다음과 같이 5개의 데이터 클래스가 생성됩니다. 이 때 옵션은 Val, Nullable, MoShi (Reflect)를 선택해줍니다.\nJSON은 객체를 중괄호{} 로 감싸서 표시하는데 이걸 DTO로 변환할 때에는 객체 하나를 데이터 클래스 하나로 대응시킵니다. Moshi로 객체 안의 Key-Value 쌍을 변환할 때는 @field:Json(name = \u0026quot;\u0026quot;) 어노테이션을 사용합니다. name에 Key 값을 지정하면, 대응하는 Value를 val 프로퍼티에 매칭해 줍니다. 각 클래스의 내용이 짧기 때문에 여기서는 관리상 편의를 위해 EmgMedResponse.kt 안에 다른 클래스 내용을 다 붙여넣도록 하겠습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 data class EmgMedResponse( @field:Json(name = \u0026#34;EmgMedInfo\u0026#34;) val emgMedInfo: List\u0026lt;EmgMedInfo\u0026gt;? ) data class EmgMedInfo( val head: List\u0026lt;Head\u0026gt;?, val row: List\u0026lt;Row\u0026gt;? ) data class Head( @field:Json(name = \u0026#34;api_version\u0026#34;) val apiVersion: String?, // 1.0 @field:Json(name = \u0026#34;list_total_count\u0026#34;) val listTotalCount: Int?, // 172 @field:Json(name = \u0026#34;RESULT\u0026#34;) val rESULT: RESULT? ) data class RESULT( @field:Json(name = \u0026#34;CODE\u0026#34;) val cODE: String?, // INFO-000 @field:Json(name = \u0026#34;MESSAGE\u0026#34;) val mESSAGE: String? // 정상 처리되었습니다. ) data class Row( @field:Json(name = \u0026#34;DISTRCT_DIV_NM\u0026#34;) val dISTRCTDIVNM: String?, // 국민안심병원+호흡기전담클리닉 @field:Json(name = \u0026#34;EMGNCY_CENTER_TELNO\u0026#34;) val eMGNCYCENTERTELNO: String?, // 031-8060-5000 @field:Json(name = \u0026#34;MEDCARE_INST_NM\u0026#34;) val mEDCAREINSTNM: String?, // 센트럴아동병원 @field:Json(name = \u0026#34;REFINE_LOTNO_ADDR\u0026#34;) val rEFINELOTNOADDR: String?, // 경기도 화성시 반송동 93-1번지 동탄위버폴리스 @field:Json(name = \u0026#34;REFINE_ROADNM_ADDR\u0026#34;) val rEFINEROADNMADDR: String?, // null @field:Json(name = \u0026#34;REFINE_WGS84_LAT\u0026#34;) val rEFINEWGS84LAT: String?, // 37.2046139805 @field:Json(name = \u0026#34;REFINE_WGS84_LOGT\u0026#34;) val rEFINEWGS84LOGT: String?, // 127.0720402235 @field:Json(name = \u0026#34;REPRSNT_TELNO\u0026#34;) val rEPRSNTTELNO: String?, // null @field:Json(name = \u0026#34;SIGUN_CD\u0026#34;) val sIGUNCD: String?, // 41590 @field:Json(name = \u0026#34;SIGUN_NM\u0026#34;) val sIGUNNM: String?, // 화성시 @field:Json(name = \u0026#34;SUM_DE\u0026#34;) val sUMDE: String? // 2021-06-09 ) 아이템 디자인 Recyclerview에서 사용할 아이템의 디자인을 만들어줍니다. LinearLayout을 써서 API 응답중 Row의 내용을 표시하는 화면을 만들어줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/layout_viewholder\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;?attr/selectableItemBackground\u0026#34; android:gravity=\u0026#34;center_vertical\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:padding=\u0026#34;10dp\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;9\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_name\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;의료기관명\u0026#34; android:textSize=\u0026#34;24sp\u0026#34; android:padding=\u0026#34;3dp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_type\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;구분\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_phone\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;전화번호\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_addr\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;주소\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_wgs84lat\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;위도\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_wgs84lon\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;경도\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;30dp\u0026#34; android:layout_height=\u0026#34;30dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:src=\u0026#34;@drawable/ic_baseline_reorder_24\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 레이아웃 작성 다음은 activity_main.xml을 작성합니다. JSON 응답결과를 표시할 Recyclerview를 하나 배치하고 네트워크 연결을 시작하는데 사용할 플로팅버튼을 하나 달아줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;androidx.recyclerview.widget.RecyclerView android:id=\u0026#34;@+id/recycler_view\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:scrollbars=\u0026#34;vertical\u0026#34; tools:listitem=\u0026#34;@layout/item_emgmed\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;com.google.android.material.floatingactionbutton.FloatingActionButton android:id=\u0026#34;@+id/btn_get\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_margin=\u0026#34;20dp\u0026#34; android:clickable=\u0026#34;true\u0026#34; android:focusable=\u0026#34;true\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:srcCompat=\u0026#34;@android:drawable/ic_menu_add\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; Recyclerview 어댑터 작성 DTO 중 Row 클래스의 내용을 받아 ViewHolder에 표시하는 Recyclerview 어댑터를 작성합니다. 데이터의 갱신은 ListAdapter를 사용하여 수행합니다. ListAdapter의 구체적인 설명에 대해서는 DiffUtil과 ListAdapter 이해하고 RecyclerView에 적용하기 강의를 참조하시기 바랍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class EmgMedAdapter : ListAdapter\u0026lt;Row, EmgMedAdapter.EmgMedViewHolder\u0026gt;(DiffCallback) { override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): EmgMedViewHolder { val binding = ItemEmgmedBinding.inflate(LayoutInflater.from(parent.context), parent, false) return EmgMedViewHolder(binding) } override fun onBindViewHolder(holder: EmgMedViewHolder, position: Int) { holder.bind(getItem(position)) } class EmgMedViewHolder(private val binding: ItemEmgmedBinding) : RecyclerView.ViewHolder(binding.root) { fun bind(item: Row) { with(binding) { tvName.text = item.mEDCAREINSTNM tvType.text = item.dISTRCTDIVNM tvPhone.text = item.eMGNCYCENTERTELNO tvAddr.text = item.rEFINELOTNOADDR tvWgs84lat.text = \u0026#34;위도: ${item.rEFINEWGS84LAT}\u0026#34; tvWgs84lon.text = \u0026#34;경도: ${item.rEFINEWGS84LOGT}\u0026#34; } } } companion object { private val DiffCallback = object : DiffUtil.ItemCallback\u0026lt;Row\u0026gt;() { override fun areItemsTheSame(oldItem: Row, newItem: Row): Boolean { return oldItem.hashCode() == newItem.hashCode() } override fun areContentsTheSame(oldItem: Row, newItem: Row): Boolean { return oldItem == newItem } } } } 그리고 MainActivity의 onCreate에서 Recyclerview를 설정합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 private val myRecyclerViewAdapter by lazy { EmgMedAdapter() } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(binding.root) binding.recyclerView.apply { layoutManager = LinearLayoutManager(context, LinearLayoutManager.VERTICAL, false) adapter = myRecyclerViewAdapter addItemDecoration(DividerItemDecoration(context, DividerItemDecoration.VERTICAL)) } } 서비스 작성 Retrofit은 HTTP API의 request를 인터페이스로 정의하여 사용합니다. 이 강의에서 사용할 선별진료소 API는 다음과 같은 인자를 받을 수 있게 만들어져 있습니다.\n변수명 타입 변수 설명 설명 KEY STRING 인증키 기본값 : sample key Type STRING 호출 문서(xml, json) 기본값 : xml pIndex INTEGER 페이지 위치 기본값 : 1(sample key는 1 고정) pSize INTEGER 페이지 당 요청 숫자 기본값 : 100(sample key는 5 고정) 그러면 이중 KEY와 Type 인자를 전달받아 GET 요청을 수행하는 Retrofit 서비스를 하나 만들어보겠습니다. API 요청주소가 https://openapi.gg.go.kr/EmgMedInfo 이므로 고정주소인 Base url은 https://openapi.gg.go.kr/ 이고, @GET요청시 인자는 Base url 뒤의 EmgMedInfo 입니다. KEY와 Type 인자는 @Query 어노테이션을 써서 전달해줍니다.\n인터페이스의 메소드인 getEmgMedData는 Call 객체를 반환하도록 정의되었습니다. Call 은 서버에 request를 보내고 그 응답을 반환하는 1회용 객체입니다.\n1 2 3 4 5 interface EmgMedService { @GET(\u0026#34;EmgMedInfo\u0026#34;) fun getEmgMedData(@Query(\u0026#34;KEY\u0026#34;) KEY: String, @Query(\u0026#34;Type\u0026#34;) Type: String): Call\u0026lt;EmgMedResponse\u0026gt; } 코드를 해석하면 getEmgMedData 는 BASE_URL/EmgMedInfo?KEY=\u0026quot;KEY\u0026quot;\u0026amp;Type=\u0026quot;Type\u0026quot;이라는 GET 요청을 보내고 Call\u0026lt;EmgMedResponse\u0026gt; 객체를 반환받는 동작을 하는 함수라는 뜻이 됩니다.\nRetrofit 객체 준비 RetrofitApi 작성 Retrofit을 사용하기 위해서는 우선 객체를 만들어주어야 합니다. 이 때 여러개의 객체가 만들어지면 자원도 낭비되고 통신에 혼선도 발생할 수 있으므로 object 키워드를 써서 싱글톤으로 만들어지도록 합니다. 이 때 각 변수에는 lazy를 적용함으로써 실제 사용되는 순간이 와야 비로소 만들어지게 되고, 단 하나의 인스턴스만이 만들어지도록 하였습니다. 싱글톤에 대한 구체적인 설명은 알기쉬운 Singleton Pattern 강의를 참고하시기 바랍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 object RetrofitApi { private const val BASE_URL = \u0026#34;https://openapi.gg.go.kr/\u0026#34; private val okHttpClient: OkHttpClient by lazy { OkHttpClient.Builder() .addInterceptor(HttpLoggingInterceptor().apply { level = HttpLoggingInterceptor.Level.BODY }) .build() } private val retrofit: Retrofit by lazy { Retrofit.Builder() .addConverterFactory(MoshiConverterFactory.create()) .client(okHttpClient) .baseUrl(BASE_URL) .build() } val emgMedService: EmgMedService by lazy { retrofit.create(EmgMedService::class.java) } } 빌더 패턴을 통해 retrofit 객체를 만들어줍니다. addConverterFactory에서 DTO 변환에 사용할 JSON 컨버터를 Moshi로 지정하고, baseUrl 을 전달한 뒤 build()로 객체를 생성합니다. 그리고나서 retrofit 인스턴스의 create 명령을 이용해서 emgMedService의 인스턴스를 만들어줍니다.\n전송패킷 모니터링 retrofit 객체를 생성할때 client 속성에 okHttpClient를 넘겨주면 로그캣에서 패킷내용을 모니터링할 수 있습니다. okHttpClient는 다음과 같이 서버와 코어 사이에서 데이터를 가로채는 Interceptor로서 기능하는 객체입니다.\nRetrofit 구동 그럼 MainActivity에서 Retrofit을 사용해보겠습니다. 플로팅 버튼에 대해 다음 내용의 retrofitWork()를 실행하는 클릭리스너를 구성합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 private fun retrofitWork() { val service = RetrofitApi.emgMedService service.getEmgMedData(getString(R.string.api_key), \u0026#34;json\u0026#34;) .enqueue(object : Callback\u0026lt;EmgMedResponse\u0026gt; { override fun onResponse( call: Call\u0026lt;EmgMedResponse\u0026gt;, response: Response\u0026lt;EmgMedResponse\u0026gt; ) { if (response.isSuccessful) { Log.d(\u0026#34;TAG\u0026#34;, response.body().toString()) // head를 스킵하기 위해 index 1번을 가져옴 val result = response.body()?.emgMedInfo?.get(1)?.row myRecyclerViewAdapter.submitList(result!!) } } override fun onFailure(call: Call\u0026lt;EmgMedResponse\u0026gt;, t: Throwable) { Log.d(\u0026#34;TAG\u0026#34;, t.message.toString()) } }) } 싱글톤 Retrofit으로 서비스 인스턴스를 생성하고 getEmgMedData를 실행해서 Call 객체를 획득합니다. 인증키는 R.string.api_key 를 이용해 입력했고 서버로부터 json 데이터를 반환받도록 하였습니다.\nCall 작업은 두가지 방법으로 실행시킬 수 있습니다. execute를 사용하면 request를 보내고 response를 받는 행위를 동기적으로 행합니다. 그리고 enqueue 작업을 실행하면 request는 비동기적으로 보내고, response는 콜백으로 받게 됩니다. 여기서는 네트워크 작업을 안정적으로 수행하기 위해 enqueue로 실행하도록 하였습니다.\nenqueue의 통신결과는 성공했을 때 onResponse, 실패했을 때 onFailure 를 리스너로 받을 수 있으므로 각 상황에 따른 처리를 해 줍니다. 통신에 성공하면 response.isSuccessful을 확인하여 사용할 수 있는 응답이 돌아왔는지 확인하고, 그렇다면 body에서 값을 꺼내어 Recyclerview에 넘겨주면 됩니다.\n코루틴에서 사용하기 retrofit의 사양에 따르면 enqueue는 request를 백그라운드 스레드에서, response 콜백은 메인스레드에서 처리하게 됩니다. 그런데 코루틴을 사용하면 콜백을 쓰지 않아도 동일한 처리를 할 수 있습니다. 그래서 이번엔 코루틴 안에서 retrofit 처리를 수행하도록 해 보겠습니다. 코루틴에 대한 구체적인 설명에 대해서는 알기쉬운 코루틴 이론을 참조하시기 바랍니다.\n우선은 build.gradle에 플러그인을 추가합니다.\n1 implementation \u0026#39;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.5.1\u0026#39; 다음으로 코루틴으로 작동하는 서비스를 인터페이스에 추가해 줍니다. 서비스가 코루틴 안에서 수행되어야 하므로 suspend 키워드를 붙여주고, 반환값은 Call 객체가 아니라 Response 객체로 받도록 변경하였습니다. 코루틴 자체적으로 비동기적인 처리를 수행하기 때문에, Call이 제공하는 흐름처리 기능은 더이상 필요가 없습니다.\n1 2 3 4 5 @GET(\u0026#34;EmgMedInfo\u0026#34;) suspend fun getDataCoroutine( @Query(\u0026#34;KEY\u0026#34;) KEY: String, @Query(\u0026#34;Type\u0026#34;) Type: String ): Response\u0026lt;EmgMedResponse\u0026gt; 다음은 retrofitWork()에서 enqueue 처리를 주석처리하고 다음 코드를 추가합니다. 네트워크 작업이므로 IO 디스패처에서 Response 반환을 획득합니다. 그리고 반환값을 RecylerView에 표시할 때만 컨텍스트를 메인 스레드로 스위치하면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 CoroutineScope(Dispatchers.IO).launch { val response = service.getDataCoroutine(getString(R.string.api_key), \u0026#34;json\u0026#34;) withContext(Dispatchers.Main) { if (response.isSuccessful) { val result = response.body()?.emgMedInfo?.get(1)?.row result?.let { myRecyclerViewAdapter.submitList(it) } } else { Log.e(\u0026#34;TAG\u0026#34;, response.code().toString()) } } } 이렇게 해서 Retrofit으로 HTTP 통신을 수행하는 법에 대해 알아보았습니다.\n","date":"2021-11-07T08:32:11+09:00","permalink":"https://cliearl.github.io/posts/android/download-json-data-using-retrofit/","title":"Retrofit으로 다운받은 Json 데이터를 RecyclerView에 표시하기"},{"content":"컴퓨터과학 개론 컴퓨터과학이 여는 세계_이광근 https://www.youtube.com/playlist?list=PL0Nf1KJu6Ui7yoc9RQ2TiiYL9Z0MKoggH\nCS50 Lectures 2020 https://www.youtube.com/playlist?list=PLhQjrBD2T382_R182iC2gNZI9HzWFMC_8\nMITx: Introduction to Computer Science and Programming - 6.00x https://www.youtube.com/playlist?list=PL2fCZiDqOYYVeUQ47xSkwnioVf_xQoQm2\nMIT 6.0001 Introduction to Computer Science and Programming in Python, Fall 2016 https://www.youtube.com/playlist?list=PLUl4u3cNGP63WbdFxL8giv4yhgdMGaZNA\nMIT 6.00SC Introduction to Computer Science and Programming, Spring 2011 https://www.youtube.com/playlist?list=PLB2BE3D6CA77BB8F7\n프로그래밍 개론 Programming Methodology (Stanford) https://www.youtube.com/playlist?list=PL84A56BC7F4A1F852\nLecture Collection | Programming Abstractions https://www.youtube.com/playlist?list=PLFE6E58F856038C69\n자료구조 \u0026amp; 알고리즘 MIT 6.006 Introduction to Algorithms, Fall 2011 https://www.youtube.com/playlist?list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb\nMIT 6.006 Introduction to Algorithms, Spring 2020 https://www.youtube.com/playlist?list=PLUl4u3cNGP63EdVPNLG3ToM6LaEUuStEY\nMIT 6.046J Design and Analysis of Algorithms, Spring 2015 https://www.youtube.com/playlist?list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp\nMIT 6.046J / 18.410J Introduction to Algorithms (SMA 5503) https://www.youtube.com/playlist?list=PL8B24C31197EC371C\nMIT 6.851 Advanced Data Structures, Spring 2012 https://www.youtube.com/playlist?list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf\n이산수학 MIT 6.042J Mathematics for Computer Science, Fall 2010 https://www.youtube.com/playlist?list=PLB7540DEDD482705B\nMIT 6.042J Mathematics for Computer Science, Spring 2015 https://www.youtube.com/playlist?list=PLUl4u3cNGP60UlabZBeeqOuoLuj_KNphQ\nMIT 18.085 Computational Science and Engineering I, Fall 2008 https://www.youtube.com/playlist?list=PLF706B428FB7BD52C\n아키텍쳐 MIT 6.035 Computer Language Engineering, Fall 2005 https://www.youtube.com/playlist?list=PL0300FE43396456C1\nMIT 6.189 Multicore Programming Primer, IAP 2007 https://www.youtube.com/playlist?list=PLE638294EA3288272\n인공지능 모두를 위한 딥러닝 강좌 시즌 1 https://www.youtube.com/playlist?list=PLlMkM4tgfjnLSOjrEJN31gZATbcj_MpUm\nDo It! 딥러닝 입문 https://www.youtube.com/playlist?list=PLJN246lAkhQgbBx2Kag0wIZedn-P9KcH9\n혼자 공부하는 머신러닝+딥러닝 https://www.youtube.com/playlist?list=PLJN246lAkhQjoU0C4v8FgtbjOIXxSs_4Q\n서울대학교의 모두를 위한 AI 강연 https://tv.naver.com/aiis/home\nMachine Learning — Andrew Ng, Stanford University [FULL COURSE] https://www.youtube.com/playlist?list=PLLssT5z_DsK-h9vYZkQkYNWcItqhlRJLN\nMachine Learning Specialization by Andrew Ng https://www.youtube.com/playlist?list=PLkDaE6sCZn6FNC6YRfRQc_FbeQrF8BwGI\nMIT 6.S191: Introduction to Deep Learning https://www.youtube.com/playlist?list=PLtBw6njQRU-rwp5__7C0oIVt26ZgjG9NI\nStanford CS229: Machine Learning Full Course taught by Andrew Ng https://www.youtube.com/playlist?list=PLoROMvodv4rMiGQp3WXShtMGgzqpfVfbU\n","date":"2021-10-30T19:12:43+09:00","permalink":"https://cliearl.github.io/posts/etc/computer-science-lectures/","title":"컴퓨터공학 온라인 대학강의"},{"content":"이번 포스팅에서는 안드로이드의 HTTP 통신에 대해 알아보도록 하겠습니다.\n안드로이드에서의 통신 앱에서 가장 많이 수행하는 처리중 하나는 서버에 데이터를 요청하고 받아온 데이터를 단말-다시말해 클라이언트의 화면에 표시하는 것입니다. 이 때 클라이언트와 서버가 통신하는 방식은 크게 소켓연결과 HTTP연결 두 가지로 나눌 수 있습니다.\n소켓 연결 소켓은 네트워크 상의 두 프로그램 사이에서 일어나는 양방향 통신중 한 쪽의 엔드 포인트를 의미합니다. 여기서 엔드포인트란 IP와 포트의 조합을 뜻합니다.\n소켓 연결방식에서는 클라이언트와 서버가 특정 포트를 통해 연결을 계속 유지하고 있기 때문에 실시간으로 양방향 통신을 할 수 있는데요, 주로 동영상 스트리밍이나, 온라인 게임등에서 사용되는 연결방식입니다.\nNative Socket.IO and Android 에 소켓통신을 사용해서 채팅앱을 만드는 법을 설명하고 있으니 궁금하신분은 참고하시면 좋을 것 같습니다.\nHTTP 연결 HTTP는 HyperText Transfer Protocol의 약자로, 80번 포트를 사용하여 웹 상에서 정보를 주고받을 수 있는 프로토콜을 말합니다. HTTP 통신에서는 클라이언트가 서버에 헤더(header)와 바디(body)로 이루어진 메시지를 요청(request)합니다. 그러면 서버는 이 요청을 처리하고 응답코드와 함께 응답(response)을 반환하게 됩니다.\nConnectionless : HTTP 연결은 소켓을 사용해서 접속을 만들지만, 용건이 있을때만 연결했다가 용건이 끝나면 연결을 끊게 되어 있습니다. 이걸 Connectionless하다고 표현하는데, 이렇게 하면 서버에 여유가 생겨 더 많은 접속요구에 대응할 수 있게 됩니다.\nStateless : 통신이 일어날때마다 새로운 접속을 생성하고 삭제하는 Connectionless 특징때문에 HTTP 통신에서는 기본적으로 서버가 클라이언트를 식별할 수가 없는데 이것을 Stateless하다고 합니다. 그래서 서버가 클라이언트를 기억해야 할 경우 쿠키나 세션, 혹은 토큰이라는 기술을 사용하게 됩니다.\nHTTP Method HTTP Method란 클라이언트가 서버에 메시지를 보낼 때 어떠한 목적을 가졌는지 밝히는 것으로, 다음과 같은 것들이 있습니다. 일반적으로 많이 사용되는 GET, POST, PUT, DELETE 이외에도 여러가지 명령어들이 있습니다.\nMethod 설명 GET 서버에 리소스를 요청합니다. 서버를 수정하지 않기 때문에 safe method로 분류. HEAD GET과 같지만 서버가 본문(body)을 포함하지 않음. POST 클라이언트에서 요청한 URL에 본문의 내용으로 새로운 리소스를 생성. PUT 클라이언트가 요청한 내용으로 서버의 리소스를 수정. DELETE 서버의 리소스를 삭제. CONNECT 요청 리소스에 대해 양방향 연결을 수립, 예로 프록시를 통한 SSL 연결수립에 사용될 수 있음. OPTIONS 서버가 어떤 HTTP 메소드를 지원하는지 물어봄. TRACE 메시지의 변조여부 확인을 위해, 서버가 수신한 클라이언트의 메시지를 반환하도록 함. PATCH PUT은 리소스 전체를 수정하나, PATCH는 해당 리소스의 일부만을 수정. RESTful API 구글, 페이스북, 트위터, 네이버, 카카오 등 많은 IT회사는 자기 회사의 서비스를 이용할 수 있도록 REST API를 제공합니다. REST API라는게 뭘까요?\nREST(Representational State Transfer)는 HTTP 기반으로 필요한 자원에 접근하는 방식을 정해놓은 네트워크 아키텍처입니다. 일반적으로 다음과 같은 기준을 만족하면 RESTful 하다고하며 RESTful하게 작동하도록 만든 API를 RESTful API라고 합니다.\n클라이언트와 서버의 분리 무상태(Stateless) 캐시 처리가 가능해야 함 시스템이 계층화(Layered) 되어있어야 함 일관성 있는 인터페이스 Http Method와 RESTful API의 대응은 다음 표와 같이 정리할 수 있습니다.\nHTTP Method CRUD Entire Collection (e.g. /customers) Specific Item (e.g. /customers/{id}) POST Create 201 (Created), \u0026lsquo;Location\u0026rsquo; header with link to /customers/{id} containing new ID. 404 (Not Found), 409 (Conflict) if resource already exists.. GET Read 200 (OK), list of customers. Use pagination, sorting and filtering to navigate big lists. 200 (OK), single customer. 404 (Not Found), if ID not found or invalid. PUT Update/Replace 405 (Method Not Allowed), unless you want to update/replace every resource in the entire collection. 200 (OK) or 204 (No Content). 404 (Not Found), if ID not found or invalid. PATCH Update/Modify 405 (Method Not Allowed), unless you want to modify the collection itself. 200 (OK) or 204 (No Content). 404 (Not Found), if ID not found or invalid. DELETE Delete 405 (Method Not Allowed), unless you want to delete the whole collection—not often desirable. 200 (OK). 404 (Not Found), if ID not found or invalid. Android HTTP 통신 라이브러리 안드로이드에는 HTTP 통신을 구현하는 여러가지 라이브러리가 있는데요, 여기서는 주요하게 사용된 몇 가지 라이브러리를 시간순으로 다루어보도록 하겠습니다.\nHttpClient Http 통신을 용이하게 수행하기 위해 Apache에서 제작한 라이브러리입니다. 안드로이드 초기에 주로 사용되었으며 실제로는 HttpClient를 래핑한 DefaultHttpClient나, 안드로이드에 맞게 개수한 AndroidHttpClient가 사용되었습니다.\nHttpClient는 안드로이드와 독립적으로 개발되는 라이브러리인지라 변경점을 안드로이드 SDK에 일괄적으로 즉시 반영할 수 없었습니다. 결국 버전이 뒤쳐지면서 버그가 계속 발생하게 되었고, HttpClient는 Android 5.1에서 Deprecated 되며 6.0에서는 아예 삭제되었습니다. 이 시기 클라이언트의 버그는 네이버 D2 블로그의 Android의 HTTP 클라이언트 라이브러리에 잘 정리되어 있으니 참고하시기 바랍니다.\nHttpUrlConnection HttpClient를 삭제하면서 구글에서 제시한 대안이 HttpUrlConnection인데요, 기존의 URLConnection에 HTTP를 다루는데 필요한 메서드를 추가한 클래스입니다.\nURL.openConnection()으로 얻어진 URLConnection 객체를 HttpURLConnection으로 캐스팅하여 데이터 송수신을 행하고 disconnect로 접속을 종료하는 방식으로 사용합니다.\n1 2 3 4 5 6 7 8 URL url = new URL(\u0026#34;http://www.android.com/\u0026#34;); HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); try { InputStream in = new BufferedInputStream(urlConnection.getInputStream()); readStream(in); } finally { urlConnection.disconnect(); } Volley HttpUrlConnection을 사용할 때는 Application Not Responding(ANR)을 피하기 위해 백그라운드 스레드도 만들어야하고, 버퍼를 통한 입출력도 준비해야 하고, 캐시나 예외처리도 한땀한땀 다 처리해 주어야 하는 불편함이 있었습니다.\n그래서 구글에서는 HTTP 연결을 만들때마다 이런 귀찮은 일을 안해도 되는 라이브러리인 Volley를 2013년 Google I/O에서 발표했습니다. Volley는 다음과 같은 특징이 있다고 하네요.\nAutomatic scheduling of network requests. Multiple concurrent network connections. Transparent disk and memory response caching with standard HTTP cache coherence. Support for request prioritization. Cancellation request API. You can cancel a single request, or you can set blocks or scopes of requests to cancel. Ease of customization, for example, for retry and backoff. Strong ordering that makes it easy to correctly populate your UI with data fetched asynchronously from the network. Debugging and tracing tools. 사용법은 다음과 같습니다. HTTP 메소드와 url 정보를 가진 Request를 만들어서 RequestQueue에 넣어줍니다. 그러면 Volley가 알아서 스레드를 만들고 HttpUrlConnection으로 통신을 수행한 뒤 response를 반환해줍니다. 코드를 보시면 HttpUrlConnection을 직접 사용할 때보다 코드가 더 읽기 쉬워진 것을 알 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 val textView = findViewById\u0026lt;TextView\u0026gt;(R.id.text) val queue = Volley.newRequestQueue(this) val url = \u0026#34;https://www.google.com\u0026#34; val stringRequest = StringRequest(Request.Method.GET, url, Response.Listener\u0026lt;String\u0026gt; { response -\u0026gt; // Display the first 500 characters of the response string. textView.text = \u0026#34;Response is: ${response.substring(0, 500)}\u0026#34; }, Response.ErrorListener { textView.text = \u0026#34;That didn\u0026#39;t work!\u0026#34; }) queue.add(stringRequest) OkHttp 그런 와중에 2013년 5월 6일엔 Square에서 OkHttp라는 HTTP 클라이언트 라이브러리를 발표합니다. 이 라이브러리는 Okio와 코틀린을 활용해 쓰여졌고 다음과 같은 특징이 있습니다. Connection pooling과 Redirection을 도입해 접속을 더 안정적이게 하면서도, 속도를 개선시킬 수 있는 여러가지 기술이 적용된 것으로 보입니다.\nHTTP/2 support allows all requests to the same host to share a socket. Connection pooling reduces request latency (if HTTP/2 isn’t available). Transparent GZIP shrinks download sizes. Response caching avoids the network completely for repeat requests. 사용법은 다음과 같습니다. 클라이언트 인스턴스를 생성하고 리퀘스트 객체를 만들어 클라이언트에 전해주면 response가 반환되는 구조를 가지고 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 OkHttpClient client = new OkHttpClient(); String run(String url) throws IOException { Request request = new Request.Builder() .url(url) .build(); try (Response response = client.newCall(request).execute()) { return response.body().string(); } } Retrofit Retrofit은 OkHttp를 개발한 Square에서 2013/05/14 에 발표한 라이브러리입니다. HttpURLConnection을 사용하기 편하도록 랩핑한게 Volley라면 Retrofit은 OkHttp를 랩핑한 것입니다.\n사용법은 다음과 같습니다. 우선 REST API 콜을 인터페이스 형식으로 준비합니다. 그리고 Retrofit 객체를 만들어서 인터페이스의 인스턴스를 생성합니다. 마지막으로 인터페이스를 동기 혹은 비동기적으로 구동시켜 response를 반환받게 되어 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 public interface GitHubService { @GET(\u0026#34;users/{user}/repos\u0026#34;) Call\u0026lt;List\u0026lt;Repo\u0026gt;\u0026gt; listRepos(@Path(\u0026#34;user\u0026#34;) String user); } Retrofit retrofit = new Retrofit.Builder() .baseUrl(\u0026#34;https://api.github.com/\u0026#34;) .build(); GitHubService service = retrofit.create(GitHubService.class); Call\u0026lt;List\u0026lt;Repo\u0026gt;\u0026gt; repos = service.listRepos(\u0026#34;octocat\u0026#34;); Ktor Jetbrains에서 개발한 Ktor는 코틀린을 이용해 비동기 서버와 클라이언트를 구축할수 있게 해주는 라이브러리입니다. 1.6.3 버전까지 발표되어 있으며 현재도 활발한 업데이트가 이루어지고 있습니다\n안드로이드에서의 사용법은 다음과 같습니다. 코루틴 스코프 안에서 Http 클라이언트를 만들어서 request를 보내고 response를 확인한 뒤, 클라이언트의 리소스를 close로 반환하면 됩니다.\n1 2 3 4 5 6 CoroutineScope(Dispatchers.IO).launch { val client = HttpClient() val response: HttpResponse = client.get(\u0026#34;https://ktor.io/\u0026#34;) val stringBody: String = response.receive() client.close() } Volley or Retrofit? 안드로이드의 통신 라이브러리로는 주로 Volley 나 Retrofit을 이용하실 겁니다. 그렇다면 둘 중 어느것을 사용해야 할까요?\nVolley와 Retrofit은 지금도 꾸준히 갱신되고 있는 라이브러리인데요, 두 라이브러리의 기능차이는 다음과 같이 정리할 수 있을 것 같습니다.\nFunction Volley Retrofit Automatic Parsing No Yes Caching Yes No Retrying Yes No Post Requests \u0026amp; Multipart uploads Yes Partly Image Loading Built-in No 속도에 있어서는 Volley가 빠르다는 사람도 있고 Retrofit이 빠르다는 사람도 있습니다만 결국 밀리세컨드 스케일의 차이라 속도만으로 어느 한쪽을 선택하는건 어려울 것 같네요. 코드 가독성은 대부분 Retrofit이 더 좋다는 평가인 것 같습니다. 사용법을 보시고 더 편한 쪽을 선택하시면 될 것 같습니다.\n개인적으로는 API 콜을 인터페이스로 정의해서 사용하는 Retrofit이 전체 구조를 파악하기 더 좋은것 같아 이쪽을 선호합니다. 한가지 재밌는 것은 구글의 권장 앱 아키텍처에서는 HTTP 통신에 Volley가 아닌 Retrofit을 추천하고 있다는 점입니다.\n이렇게 해서 HTTP 통신과 안드로이드의 통신 라이브러리에 대해 알아보았습니다.\n","date":"2021-10-23T10:58:16+09:00","permalink":"https://cliearl.github.io/posts/android/android-http-library-review/","title":"안드로이드의 HTTP 통신 라이브러리 고찰"},{"content":"이번 포스팅에서는 제가 즐겨 사용하는 Android Studio의 플러그인을 소개해 보도록 하겠습니다.\nADB Idea https://plugins.jetbrains.com/plugin/7380-adb-idea ADB 커맨드를 Android Studio의 UI 위에서 사용할 수 있게 해 줍니다 ADB Wi-Fi https://plugins.jetbrains.com/plugin/14969-adb-wi-fi 개발장비와 모바일기기는 Android Debug Bridge(ADB)를 통해 USB나 Wifi로 연결할 수 있는데요, ADB Wi-Fi는 Wifi를 통한 ADB연결을 간편하게 수행해줍니다 CodeGlance Pro https://plugins.jetbrains.com/plugin/18824-codeglance-pro Sublime text처럼 에디터 오른쪽에 코드 미니맵을 표시해줍니다 CPU Usage Indicator https://plugins.jetbrains.com/plugin/8580-cpu-usage-indicator 스테이터스바에 IDE와 전체 시스템의 CPU 사용량을 표시합니다 CSV https://plugins.jetbrains.com/plugin/10037-csv CSV 파일을 테이블 형식으로 열람하고 편집할 수 있게 해 줍니다 Extra ToolWindow Colorful Icons https://plugins.jetbrains.com/plugin/16604-extra-toolwindow-colorful-icons 툴 윈도우 아이콘에 색을 입혀줍니다. 안스에 기본 장착되었으면 하는 플러그인 GitToolBox https://plugins.jetbrains.com/plugin/7499-gittoolbox Git status와 blame을 스테이터스바와 에디터에 표시할 수 있게 합니다 개인적으로 Show editor inline 'Blame'은 False로 두고 사용합니다. Grep Console https://plugins.jetbrains.com/plugin/7125-grep-console 콘솔창에서 Grep, tail, filter, highlight 등의 기능을 사용할 수 있게 합니다 IDE Features Trainer https://plugins.jetbrains.com/plugin/8554-ide-features-trainer Android Studio의 기본적인 단축어나 기능을 학습하는 튜토리얼을 제공합니다 Indent Rainbow https://plugins.jetbrains.com/plugin/13308-indent-rainbow 인덴트를 서로다른 색으로 표시하여 블럭구분을 쉽게 해 줍니다 개인적으로는 Preferences \u0026gt; Editor \u0026gt; General \u0026gt; Appearance \u0026gt; Show whitespaces와 조합해 사용하면 더 보기 편한 것 같습니다 JSON To Kotlin Class https://plugins.jetbrains.com/plugin/9960-json-to-kotlin-class-jsontokotlinclass- JSON 데이터를 data class로 간편하게 변환해줍니다 Key Promoter X https://plugins.jetbrains.com/plugin/9792-key-promoter-x 수행한 조작에 대응하는 단축키를 화면에 표시함으로써 단축기를 더 익히기 쉽게 해 줍니다 MAD Scorecard https://plugins.jetbrains.com/plugin/15549-mad-scorecard 앱의 MAD score를 평가해 줍니다 Mario Progress Bar https://plugins.jetbrains.com/plugin/14708-mario-progress-bar 심심한 프로그래스바를 마리오로 바꿔줍니다 Markdown https://plugins.jetbrains.com/plugin/7793-markdown 마크다운 파일을 편집하고 미리보기 할수 있게 해 줍니다 PlantUML integration https://plugins.jetbrains.com/plugin/7017-plantuml-integration Unified Modeling Language(UML)를 사용할 수 있게 해 줍니다 Presentation Assistant https://plugins.jetbrains.com/plugin/7345-presentation-assistant 방금 수행한 액션을 화면에 표시해서 화면을 보는 사람이 어떤 행위를 했는지 확인할 수 있게 합니다 Save Actions https://plugins.jetbrains.com/plugin/7642-save-actions 파일을 저장할 때 자동으로 어떤 액션이 실행되게 할 수 있습니다 Statistic https://plugins.jetbrains.com/plugin/4509-statistic 작성된 프로젝트의 파일 사이즈나 라인수 등의 통계를 표시해줍니다 String Manipulation https://plugins.jetbrains.com/plugin/2162-string-manipulation 문자열에 대해 Case switching, sorting, filtering, incrementing, aligning to columns, grepping, escaping, encoding 등등의 변형을 간편하게 수행할 수 있습니다 Xcode-Dark Theme https://plugins.jetbrains.com/plugin/13106-xcode-dark-theme 안드로이드 스튜디오를 Xcode 스타일로 점령하는 테마입니다 ","date":"2021-10-10T09:13:13+09:00","permalink":"https://cliearl.github.io/posts/android/android-studio-plugins/","title":"내가 Android Studio에서 사용하는 Plugins"},{"content":"Docker로 Postgresql의 12버전을 사용하고 있었는데 2021-09-30부로 14버전이 발표됐다. 이젠 12를 버리고 13으로 가야겠다 싶어 업그레이드 방법을 정리한다.\nPostgresql Version Postgresql 메이저 버전은 최근것만 정리하면 다음과 같다.\nRelease First release Latest minor version Latest release End of life Milestones 11 2018-10-18 11.13 2021-08-12 2023-11-09 Increased robustness and performance for partitioning, transactions supported in stored procedures, enhanced abilities for query parallelism, just-in-time (JIT) compiling for expressions 12 2019-10-03 12.8 2021-08-12 2024-11-14 Improvements to query performance and space utilization; SQL/JSON path expression support; generated columns; improvements to internationalization, and authentication; new pluggable table storage interface. 13 2020-09-24 13.4 2021-08-12 2025-11-13 Space savings and performance gains from de-duplication of B-tree index entries, improved performance for queries that use aggregates or partitioned tables, better query planning when using extended statistics, parallelized vacuuming of indexes, incremental sorting 14 2021-09-30 14.0 2021-09-30 2026-11-12 Added SQL-standard SEARCH and CYCLE clauses for common table expressions, allow DISTINCT to be added to GROUP BY 15 2022-10-13 15.0 2022-10-13 2027-11-11 Implements SQL-standard MERGE statement. PL/Python now only supports current Python 3, and plpythonu means the discontinued What’s New in PostgreSQL 13? 12버전도 지원기간은 많이 남았긴 한데.. 새 버전을 써보고 싶으니 업그레이드하기로 했다. 13의 특징은 다음과 같은 게 있다고 하는데 좀 더 구체적인 설명은 What’s New in PostgreSQL 13? 을 참고하자.\nSpace savings and performance gains from de-duplication of B-tree index entries Improved performance for queries that use aggregates or partitioned tables Better query planning when using extended statistics Parallelized vacuuming of indexes Incremental sorting Docker Image Postgresql의 공식 도커이미지는 Docker Hub에서 제공하고 있고, 이미지는 다음과 같은 형식으로 제공되고 있다.\n14.0, 14, latest, 14.0-bullseye, 14-bullseye, bullseye 14.0-alpine, 14-alpine, alpine, 14.0-alpine3.14, 14-alpine3.14, alpine3.14 14.0은 마이너 버전까지 고정시켜 만든 것이고 14는 14 릴리즈의 최신버전을 의미한다. latest는 모든 버전중 최신버전을 의미하는데 안정성을 위해 사용은 추천하지 않는다. bullseye는 최신 데비안인 11.0을 기반으로 만들어진 이미지이고, alpine은 용량을 최적화한 알파인 리눅스를 기반으로 만들어진 이미지이다. 개인적으로는 14 형식의 이미지를 사용한다.\n각 이미지의 디테일은 깃헙 저장소에서 확인할 수 있다.\nVersion upgrade pg_upgrade 이용 Postgresql은 pg_upgrade와 pg_upgradecluster라는 명령어를 제공해주는데 이걸 사용하면 업그레이드를 비교적 간단하게 수행할 수 있다. 문제는 이 명령어를 사용하기 위해서는 OS에 현재버전과 업그레이드할 버전이 모두 설치되어 있어야 하기 때문에 도커에서는 사용할 수 없다는 점이다.\n다만 이걸 또 도커에서 사용할 수 있게 만들어놓은 사람이 있긴 하다\u0026hellip;\n백업파일 이용 하지만 내생각에 가장 속편한 것은 그냥 이전버전에서 전체 데이터를 덤프받아 다음버전에 올려버리는 것이다. 우선 이전버전과 다음버전 컨테이너를 동시에 띄우고 다음 내용을 따라한다.\n도커 컨테이너의 ID 확인 1 docker ps -a 이전버전 컨테이너에서 파일 덤프 1 docker exec -it [이전버전 container ID] /usr/bin/pg_dumpall -U [username] \u0026gt; dumpfile.sql 다음버전 컨테이너에 파일 복원 1 docker exec -it [다음버전 container ID] psql \u0026lt; dumpfile.sql 이 때 the input device is not a TTY 라고 뜨면서 입력이 안되면 다음 명령어로 직접 집어넣으면 된다.\n1 cat dumpfile.sql | docker exec -i [다음버전 container ID] psql -U gitea 끗.\n","date":"2021-10-09T17:45:11+09:00","permalink":"https://cliearl.github.io/posts/linux/postgresql-docker-upgrade/","title":"Postgresql Docker Image의 메이저 버전 업그레이드"},{"content":"Language and OS Android Dev Summit https://developer.android.com/events/dev-summit\nAndroid Dev Summit 2021 | All Sessions CppCon https://cppcon.org/program2021/\nCppCon 2021 - All Sessions .Net Conf https://www.dotnetconf.net/\n.NET Conf 2021 Pycon https://pycon.org/\nPyCon US 2021 PyCascades https://2021.pycascades.com\nPyCascades 2021 droidcon Berlin https://www.droidcon.com/events/droidcon-berlin-2021/\nWATCH VODS droidcon London https://www.droidcon.com/events/droidcon-london-2021/\nWATCH VODS DroidKnights https://sites.google.com/view/dk21/\nDroidKnights 2021 DroidKaigi https://droidkaigi.jp/2021/\nDroidKaigi 2021 GDG DevFest Tokyo https://gdg-tokyo.connpass.com/event/229935/\nGDG DevFest Tokyo 2021 GDG Devfest Korea 2021 https://sites.google.com/view/devfest-korea-2021/compose-codelab\nJetpack Compose I/O Extended with doubleS https://gdg.community.dev/events/details/google-gdg-seoul-presents-io-extended-double-s-day-1/\nI/O 2021 Extended I/O Extended Japan 2021 - Android https://gdgnagoya.connpass.com/event/215260/?utm_campaign=event_publish_to_follower\u0026utm_source=notifications\u0026utm_medium=twitter\nI/O Extended Japan 2021 - Android iOS Conf SG https://2021.iosconf.sg/ -iOS Conf SG 2021\niOSDC Japan https://iosdc.jp/2021/\niOSDC Japan 2021 Company \u0026amp; Community Agile Korea Conference http://agilekorea.kr/\nAKC2021 Apple Worldwide Developers Conference (WWDC) https://developer.apple.com/wwdc21/\nWWDC21 Videos CEDEC https://cedec.cesa.or.jp/\nCEDEC2021【1日目】 CEDEC2021【2日目】 CEDEC2021【3日目】 【CEDEC2021】～日本最大にして世界的なゲーム開発者会議～ CES https://www.ces.tech/\nLIVE at CES 2021 CES 2021 Recaps Coupang Reveal https://event.coupangcorp.com\n쿠팡(Coupang) | Reveal2021 Dell Technologies World https://www.delltechnologies.com/ko-kr/events/delltechnologiesworld/index.htm\nSessions DeNA TechCon https://techcon2021.dena.dev/\nDeNA TechCon 2021 DeNA TechCon 2021 Summer FEConf https://2021.feconf.kr/\nFEConf 2021 A Track FEConf 2021 B Track Google I/O https://www.google.com/io\nGoogle I/O 2021 IBM Developer Day https://developer.ibm.com/conferences/\nDigital Developer Conferences if (kakao) https://if.kakao.com/\nif(kakao)2021 if(kakao)2021 발표 영상 (수어) INNO-CON https://www.innocon.io/\nINNO-CON ㅣ CHANGE THE WORLD WITH SOFTWARE JetBrains Customer Appreciation Day / 한국 사용자 고맙데이 https://blog.jetbrains.com/ko/blog/2021/11/26/jetbrains-cadk/\n(Korean) JetBrains Customer Appreciation Day / 한국 사용자 고맙데이 JetBrains IntelliJ IDEA Conf https://www.jetbrains.com/ko-kr/lp/intellijidea-20-anniversary/\nIntelliJ IDEA Conf 2021 LINE DEVELOPER DAY https://linedevday.linecorp.com/2021/\nLINE DEVELOPER DAY 2021 日本語音声 LINE DEVELOPER DAY 2021 English version LINE DEVELOPER DAY 2021 Korean version Microsoft Build https://mybuild.microsoft.com/home\nMicrosoft Build 2021 | All Sessions Microsoft Ignite https://news.microsoft.com/march-2021-ignite/\nMore from Microsoft Ignite 2021 Naver Deview https://deview.kr/\nSESSIONS OKKYCON http://www.okkycon.com/2021/\nOKKYCON: 2021 Oracle Developer Day https://developer.oracle.com/jp/developer-days-2021/\nOracle Developer Day 2021 Qcon Plus https://plus.qconferences.com/plus-home\nQCon Plus Virtual Software Development Conference Samsung SDS REAL 2021 https://www.samsungsds.com/kr/event/real2021.html\nREAL 2021 - 삼성SDS 온라인 컨퍼런스 Samsung Software Developer Conference https://www.soscon.net/ssdc2021\nSSDC 2021 Samsung Techtonic https://www.samsungsds.com/kr/event/techtonic2021.html\nTechtonic 2021 - 삼성SDS 기술/개발자 컨퍼런스 SOFTWARE EDU FEST https://sef.connect.or.kr/2021\nSEF2021 다시보기 SK ICT Tech Summit https://www.skicttechsummit.com/\nSK DT Webinar 모음 Strange loop https://www.thestrangeloop.com\nStrange Loop 2021 Toss Slash https://toss.im/slash-21\nSLASHㅣ개발자 컨퍼런스 Upbit Developer Conference https://udc.upbit.com/\nUDC 2021 | \u0026ldquo;Welcome to the Blockchain World\u0026rdquo; | 일자별 프로그램 한 번에 보기 | At a glance UDC 2021 | \u0026ldquo;Welcome to the Blockchain World\u0026rdquo; | 세부 프로그램 연사로 나눠보기 | At a glance Woowacon https://www.woowacon.com/\n우아콘2021, 우아한형제들의 기술 컨퍼런스 Yahoo! JAPAN Tech Conference https://techconference.yahoo.co.jp/2021/\nYahoo! JAPAN Tech Conference 基調講演 Yahoo! JAPAN Tech Conference 2021 技術書典 https://techbookfest.org/\n技術に出会える - 技術書典11スペシャルオンラインイベント Artificial Intelligence AI \u0026amp; Big Data Smart Convergence https://conference.etnews.com/conf_info.html?uid=188\n2021 AI \u0026amp; Big Data Smart Convergence SK ai.x conference https://www.skt.ai/kr/ai_x/index.do\nConference 다시 보기 NAVER AI NOW https://naver-ai-now.kr/\nNAVER AI NOW 2021 (ENG-Sub) MODUCON https://moducon.kr/\nMODUCON 2021 Big Data 데이터 그랜드 컨퍼런스 https://www.datastars.or.kr/2021-%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B7%B8%EB%9E%9C%EB%93%9C-%EC%BB%A8%ED%8D%BC%EB%9F%B0%EC%8A%A4-%EC%82%AC%EC%A0%84%EB%93%B1%EB%A1%9D-%EC%95%88%EB%82%B4/\n2021 데이터 그랜드 컨퍼런스 데이터야놀자 https://datayanolja.kr/\n데이터야놀자2021 발표영상 마이데이터 컨퍼런스 https://event-us.kr/4GcPKLNZsxaf/event/40478\n4. 마이데이터 컨퍼런스 Cloud AWS re:Invent https://reinvent.awsevents.com/\nAWS re:Invent 2021 AWS re:Invent 2021 - AWS On-Air Live AWS Summit Online Korea https://aws.amazon.com/ko/events/summits/online/korea/\nAWS Summit Online Korea 2021 DockerCon https://docker.events.cube365.net/dockercon-live/2021\nDockerCon 2021 | Digital Event Kubernetes Community Days Korea https://community.cncf.io/events/details/cncf-kcd-korea-presents-kubernetes-community-days-korea/\nKCD Korea 2021 Global Azure https://github.com/krazure/ga2021kr\nGlobal Azure 2021 Korea Google Cloud Next https://cloud.withgoogle.com/next/\nGoogle Cloud Next - All Sessions NAVER Cloud Summit https://www.ncloud-online.com/navercloudsummit2021/\nNAVER Cloud Summit 2021 Open Sources ETRI Open Source Tech DAY https://eostday.kr/\nETRI 오픈소스 테크데이 2021 ubuCon ASIA https://2021.ubucon.asia/ko/\nUbuCon Asia 2021 - Day 1, Room 1 UbuCon Asia 2021 - Day 1, Room 2 UbuCon Asia 2021 - Day 2, Room 1 UbuCon Asia 2021 - Day 2, Room 2 공개SW 페스티벌 https://www.oss.kr/festival\n공개소프트웨어 페스티벌 Games Game Developers Conference (GDC) https://gdconf.com/\nGDC 2021 GAME X CONFERENCE https://www.gamex.game/\n2021 GAME X CONFERENCE GodotCon https://godotengine.org/article/godotcon-july-2021-schedule\nGodotCon 2021 @ Online (Jan 2021) Google for Games Developer Summit https://developersonair.withgoogle.com/events/game-dev-summit-2021\nAll Google for Games Developer Summit Sessions Inven game conference https://igc.inven.co.kr/\nNexon Developers Conference (NDC) https://ndc.nexon.com/main\n[NDC21] [NDC21] 1일차 [NDC21] 2일차 [NDC21] 3일차 NVIDIA GPU Technology Conference (GTC) https://www.nvidia.com/ko-kr/gtc/\nNVIDIA GTC 2021 RULICON https://bbs.ruliweb.com/rulicon\n루리콘(RULICON 2021) Tokyo Game Show https://tgs.nikkeibp.co.jp/tgs/2021/\n【TGS2021 公式番組 Official Program 9/30-10/3】 【TGS2021 Indie Game】 Unreal Summit Online https://epiclounge.co.kr/new/event_summit.php\n언리얼 서밋 2021 ","date":"2021-10-02T11:35:27+09:00","permalink":"https://cliearl.github.io/posts/conferences/2021/","title":"2021년 개발관련 컨퍼런스 리스트"},{"content":"이번 포스팅에서는 두 파트에 걸쳐 안드로이드에서 SQLite를 다루는 법에 대해 알아보도록 하겠습니다.\nPart A. 데이터베이스 관계형 데이터베이스 여러 사람들의 연락처 데이터는 다음과 같이 테이블 구조로 관리할 수 있습니다. 이런 식으로 통일된 규칙의 데이터를 관리할 수 있는 테이블을 데이터베이스라고 합니다.\n순서 이름 전화번호 이메일 주소 0 김철수 010-1111-1111 kim@abc.com 서울 1 이영희 010-2222-2222 lee@abc.com 서울 2 박모모 010-3333-3333 park@abc.com 인천 이 때 1행 2열의 이름을 Key라고 하고 2행 2열의 김철수를 Value라고 합니다. 전화번호, 이메일, 주소도 역시 Key이고 그에 대응되는 값들도 역시 Value가 되겠죠. 순서라는 Key는 각 데이터에 대해 겹치지 않는 고유한 값이기 때문에 고유키(Primary Key)라고 합니다.\n이렇게 Key와 Value가 1:1이나 1:n 또는 n:n 의 관계를 가지는 데이터베이스를 관계형 데이터베이스(Relational Database)라고 합니다.\nSQL과 CRUD 위에 보여드린 DB에서 박모모의 전화번호를 찾는건 매우 간단합니다. 하지만 만약 행의 길이가 수만줄에 이르고 그 안에 박모모의 동명이인도 수백명이 존재하는 테이블이 있다면 어떨까요? 그 안에서 내가 원하는 박모모의 전화번호를 찾는건 쉽지 않은 일일겁니다. Structured Query Language (SQL)는 그런 복잡한 DB를 좀 더 용이하게 다루기 위해서 만들어진 언어입니다.\nCRUD라는 표현을 들어보신적 있으실 겁니다. CRUD는 기본적인 데이터 처리 기능인 Create(생성), Read(읽기), Update(갱신), Delete(삭제)를 의미하는 말로, 데이터베이스를 다루기 위해 가장 기본이 되는 4가지의 명령을 묶어놓은 단어입니다. SQL은 다음과 같은 명령어를 통해 CRUD를 구현할 수 있습니다.\n이름 조작 SQL Create 생성 INSERT Read(또는 Retrieve) 읽기(또는 인출) SELECT Update 갱신 UPDATE Delete(또는 Destroy) 삭제(또는 파괴) DELETE SQL에서 실제 CRUD는 다음과 같이 구현하게 되는데요, 언어의 전체 문법은 SQL syntax 페이지에서 확인할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 작성자가 무명씨, 홍길동인 문서의 모든 항목을 가져옴 SELECT * FROM document WHERE author like \u0026#39;김*\u0026#39;; // table에 field1=value1, field2=value2, ...와 같은 속성값을 가지는 항목을 새로 생성하여 삽입 INSERT INTO table(field1, field2, ...) VALUES (value1, value2, ...); // 데이터를 수정하는 구문으로 table의 field1에 value1, field2에 value2, ... 로 변경 UPDATE table SET field1=value1, field2=value2, {WHERE 조건}; // 데이터를 삭제 DELETE FROM table {WHERE 조건}; // 데이터베이스 내의 모든 테이블, 스키마, 관계(Relation)를 전부 삭제 DROP DATABASE database_name; DataBase Management System 대량의 데이터를 다루는데 관계형 데이터베이스가 사용되고, SQL이라는 언어를 사용해 데이터베이스의 데이터를 다룬다는 걸 알았습니다. 이런 데이터베이스와 SQL을 결합해서, 사용할 수 있는 형태의 프로그램으로 만든 것을 Database Management System이라고 합니다. 거기에 관계형 데이터베이스를 사용했다면 RDBMS가 되겠죠.\n여러분이 잘 아시는 Oracle이나 MySQL 등이 대표적인 DBMS입니다. DB-Engines Ranking에 따르면 Oracle, MySQL, Microsoft SQL Server가 현재 시장에서 제일 인기있는 DBMS라고 하네요.\nSQLite란 그렇게 많고많은 DBMS중에 SQLite라는 것이 있습니다. 표준SQL을 지원하는 DB를 파일 하나로 구현한 경량 DBMS인데요, 운용시 리소스사용이 적고 무료로 사용할 수 있는 오픈소스이기 때문에 Android와 iOS에서 DB를 구현하기 위한 기본 라이브러리로 채택되어 있습니다.\n처음엔 미해군의 구축함에서 이용하기 위해 만들어진 프로그램인데 공식 홈페이지에 따르면 현재는 전세계에서 1조개가 넘는 SQLite가 운용되고 있다고 하네요. SQLite에 대해 더 알고싶으신 분은 SQLite의 알려지지 않은 이야기를 읽어보시면 좋을 것 같습니다.\n안드로이드의 SQLite 버전 상기한 이유로 안드로이드 API에는 SQLite가 기본 내장되어 있습니다. 복잡한 DB를 다룰 계획이 없다면 SQLite를 이용해 DB를 구축하는 것으로 충분합니다.\n현재까지 개발된 SQLite의 최신 버전은 3.36.0 (2021-06-18)인데 Android API에 내장되는 SQLite는 안정성을 고려해 다음 표와 같이 좀 더 낮은 버전이 내장되어 있습니다.\nAndroid API SQLite Version API 31 3.32 API 30 3.28 API 28 3.22 API 27 3.19 API 26 3.18 코틀린에서는 다음 명령어를 이용해 현재 사용중인 SQLite의 버전을 확인할 수도 있습니다.\n1 2 3 4 val version = android.database.sqlite.SQLiteDatabase.create(null).use { DatabaseUtils.stringForQuery(it, \u0026#34;SELECT sqlite_version()\u0026#34;, null) } println(\u0026#34;Framework (API ${Build.VERSION.SDK_INT}) SQLite version: $version\u0026#34;) 외부 라이브러리를 추가하면 안드로이드에서 최신버전의 SQLite를 사용할 수도 있습니다만 가능하면 공식 라이브러리를 사용하는 게 좋겠죠.\n안드로이드에서의 SQLite 사용 SQLite를 사용하기 위해서는 DB를 만들고 그 DB에 대해 SQL query를 전달하여 CRUD를 수행하면 됩니다. 안드로이드에서는 SQLiteDatabase 클래스를 이용해, 작성한 데이터베이스에 대해 CRUD를 수행할 수 있습니다.\n그런데 구글 공식문서인 Save data using SQLite에서는 다음과 같은 이유로 이 작업을 직접 수행하는것을 권하지 않고 있습니다.\n원시 SQL 쿼리에 관한 컴파일 시간 확인이 없습니다. 따라서 데이터 그래프가 변경됨에 따라 영향을 받는 SQL 쿼리를 수동으로 업데이트해야 합니다. 이 과정은 시간이 오래 걸리고 오류가 쉽게 발생할 수 있습니다.\nSQL 쿼리와 데이터 객체 간에 변환하려면 많은 상용구 코드를 사용해야 합니다.\n그 대신 구글에서는 SQLite를 더 안전하게 사용할 수 있는 SQLiteOpenHelper라는 헬퍼클래스를 제공하고 있습니다. 다음 파트에서는 이 SQLiteOpenHelper 클래스를 사용해서 CRUD작업을 하는 간단한 앱을 만들어보도록 하겠습니다.\nPart B. 샘플 앱 작성 메인 레이아웃 New Project \u0026gt; Empty Activity를 선택해 빈 프로젝트를 하나 만들어줍니다.\n그리고 앱에서 사용할 화면을 만듭니다. 전화번호부 DB를 상정할 것이므로 이름, 전화번호, 이메일 그리고 데이터의 Primary Key로 사용할 ID를 화면에서 입력할 수 있도록 EditText를 배치하겠습니다. 고유키는 데이터를 데이터베이스에 입력할 때 자동으로 부여되기 때문에 입력할 필요가 없지만 삭제, 업데이트를 테스트할 때 필요하기 때문입니다.\nCRUD 테스트를 위해서 데이터를 입력하는 INSERT, 갱신하는 UPDATE, 삭제하는 DELETE 그리고 DB의 모든 내용을 표시하는 VIEW 버튼을 만들겠습니다. 작동에 대한 로그는 화면 아래쪽에 배치한 ScrollView에 표시되도록 하였습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;ID: \u0026#34; android:textStyle=\u0026#34;bold\u0026#34; /\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/et_id\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;2\u0026#34; android:hint=\u0026#34;ID\u0026#34; android:inputType=\u0026#34;number\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;NAME: \u0026#34; android:textStyle=\u0026#34;bold\u0026#34; /\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/et_name\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;2\u0026#34; android:hint=\u0026#34;NAME\u0026#34; android:inputType=\u0026#34;textPersonName\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;PHONE: \u0026#34; android:textStyle=\u0026#34;bold\u0026#34; /\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/et_phone\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;2\u0026#34; android:hint=\u0026#34;PHONE\u0026#34; android:inputType=\u0026#34;phone\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;Email: \u0026#34; android:textStyle=\u0026#34;bold\u0026#34; /\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/et_email\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;2\u0026#34; android:hint=\u0026#34;Email\u0026#34; android:inputType=\u0026#34;textEmailAddress\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:gravity=\u0026#34;center_vertical\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_insert\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_margin=\u0026#34;1dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:textSize=\u0026#34;12dp\u0026#34; android:text=\u0026#34;INSERT\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_update\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_margin=\u0026#34;1dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:textSize=\u0026#34;12dp\u0026#34; android:text=\u0026#34;UPDATE\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_delete\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_margin=\u0026#34;1dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:textSize=\u0026#34;12dp\u0026#34; android:text=\u0026#34;DELETE\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_view\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_margin=\u0026#34;1dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:textSize=\u0026#34;12dp\u0026#34; android:text=\u0026#34;VIEW\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;ScrollView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:background=\u0026#34;@color/teal_200\u0026#34; android:padding=\u0026#34;10dp\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_result\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:textSize=\u0026#34;20sp\u0026#34; /\u0026gt; \u0026lt;/ScrollView\u0026gt; \u0026lt;/LinearLayout\u0026gt; DatabaseHelper 작성 다음은 SQLiteOpenHelper 클래스를 상속하는 DatabaseHelper 클래스를 작성합니다. 이 앱에서 사용하게 될 데이터베이스의 프라이머리키는 _id이고 그 외에 name, phone, email 이라는 키를 갖고 있습니다. 데이터베이스의 파일명 및 그외 중복으로 써야하는 상수들을 companion object에 정의하고 상속에 필요한 생성자들을 전달해줍니다.\nDatabaseHelper는 복수개의 인스턴스가 생성되어 DB에 동시접근할수 있는 문제를 방지하기 위해 싱글톤으로 작성합니다. constructor에 직접 접근하지 못하도록 private화 하고, getInstance에서 Double Checked Locking을 통해 인스턴스를 반환하는 싱글톤 구조를 구축합니다. 싱글톤에 대한 더 자세한 설명은 알기쉬운 Singleton Pattern 강의를 참고하세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class DatabaseHelper private constructor(context: Context) : SQLiteOpenHelper(context, DATABASE_NAME, null, DATABASE_VERSION) { companion object { const val DATABASE_NAME = \u0026#34;PhoneBook.db\u0026#34; const val DATABASE_VERSION = 1 const val TABLE_NAME = \u0026#34;book_table\u0026#34; const val COL1_ID = \u0026#34;_id\u0026#34; const val COL2_NAME = \u0026#34;name\u0026#34; const val COL3_PHONE = \u0026#34;phone\u0026#34; const val COL4_EMAIL = \u0026#34;email\u0026#34; //SingleTon Pattern(싱글톤 패턴) @Volatile private var instance: DatabaseHelper? = null fun getInstance(context: Context) = instance ?: synchronized(DatabaseHelper::class.java) { instance ?: DatabaseHelper(context).also { instance = it } } } } onCreate 구현 테이블을 생성하는 onCreate함수를 오버라이드 합니다. onCreate는 시스템에 DB가 없을경우에만 실행되기 때문에 쿼리를 CREATE TABLE IF EXIST로 줄 필요가 없습니다.\n_id는 데이터가 입력될 때 자동으로 증가시키기 위해 PRIMARY KEY AUTOINCREMENT를 추가해줍니다. 작성한 쿼리는 execSQL로 실행시키면 됩니다.\n1 2 3 4 5 6 7 8 9 10 override fun onCreate(db: SQLiteDatabase?) { val createQuery = \u0026#34;CREATE TABLE $TABLE_NAME (\u0026#34; + \u0026#34;$COL1_ID INTEGER PRIMARY KEY AUTOINCREMENT, \u0026#34; + \u0026#34;$COL2_NAME TEXT, \u0026#34; + \u0026#34;$COL3_PHONE TEXT, \u0026#34; + \u0026#34;$COL4_EMAIL TEXT\u0026#34; + \u0026#34;)\u0026#34; db?.execSQL(createQuery) } onUpgrade 구현 다음은 DB버전이 변경되었을 때 동작하는 onUpgrade를 구현합니다. 여기서는 DB버전이 증가되었으면 기존 DB를 삭제하고 새로운 DB를 작성하는 단순한 구조로 정의했습니다.\n1 2 3 4 5 6 override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) { if (oldVersion != newVersion) { db?.execSQL(\u0026#34;DROP TABLE IF EXISTS $TABLE_NAME\u0026#34;) onCreate(db) } } CRUD 구현 Create 우선은 CRUD의 C를 구현하겠습니다. insertData에서는 name, phone, email을 파라메터로 받게 됩니다. writableDatabase로 데이터베이스를 오픈하고 외부에서 받아온 데이터를 contentValues로 묶어서 insert 명령으로 데이터베이스에 값을 추가합니다.\n1 2 3 4 5 6 7 8 9 fun insertData(name: String, phone: String, email: String) { val db = this.writableDatabase val contentValues = ContentValues().apply { put(COL2_NAME, name) put(COL3_PHONE, phone) put(COL4_EMAIL, email) } db.insert(TABLE_NAME, null, contentValues) // 값이 없으면 행을 삽입하지않음 } Update update에서는 id로 선택해 준 데이터의 내용을 갱신합니다. insert에서처럼 writableDatabase로 데이터베이스를 오픈하고 contentValues를 넘겨주어 데이터를 갱신합니다. 이 때 \u0026quot;$COL1_ID = ?\u0026quot; 쿼리를 사용해 갱신할 데이터를 특정해주면 됩니다.\n1 2 3 4 5 6 7 8 9 10 fun updateData(id: String, name: String, phone: String, email: String) { val db = this.writableDatabase val contentValues = ContentValues().apply { put(COL1_ID, id) put(COL2_NAME, name) put(COL3_PHONE, phone) put(COL4_EMAIL, email) } db.update(TABLE_NAME, contentValues, \u0026#34;$COL1_ID = ?\u0026#34;, arrayOf(id)) } Delete 전달받은 id를 프라이머리키로 가진 데이터를 delete 명령으로 삭제합니다.\n1 2 3 4 fun deleteData(id: String) { val db = this.writableDatabase db.delete(TABLE_NAME, \u0026#34;$COL1_ID = ?\u0026#34;, arrayOf(id)) } Read 마지막으로 읽기를 구현합니다. readableDatabase로 데이터베이스를 열고 rawQuery 에 \u0026quot;SELECT * FROM $TABLE_NAME\u0026quot; 을 전달하여 Cursor 객체를 받아옵니다.\n객체가 정상적으로 얻어졌으면 try 블록 안에서 moveToNext로 데이터를 순회하면서 값을 확인하고 커서를 다 사용했으면 close로 리소스를 반환하도록 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 fun getAllData(): String { var result = \u0026#34;No data in DB\u0026#34; val db = this.readableDatabase val cursor = db.rawQuery(\u0026#34;SELECT * FROM $TABLE_NAME\u0026#34;, null) try { if (cursor.count != 0) { val stringBuffer = StringBuffer() while (cursor.moveToNext()) { stringBuffer.append(\u0026#34;ID :\u0026#34; + cursor.getInt(0).toString() + \u0026#34;\\n\u0026#34;) stringBuffer.append(\u0026#34;NAME :\u0026#34; + cursor.getString(1) + \u0026#34;\\n\u0026#34;) stringBuffer.append(\u0026#34;PHONE :\u0026#34; + cursor.getString(2) + \u0026#34;\\n\u0026#34;) stringBuffer.append(\u0026#34;EMAIL :\u0026#34; + cursor.getString(3) + \u0026#34;\\n\\n \u0026#34;) } result = stringBuffer.toString() } } catch (e: Exception) { e.printStackTrace() } finally { if (cursor != null \u0026amp;\u0026amp; !cursor.isClosed) { cursor.close() } } return result } MainActivity 준비 뷰 바인딩을 적용한 메인액티비티를 작성합니다. dbHelper 인스턴스를 생성하고, 사용이 끝나면 onDestroy에서 close()로 리소스를 반환하도록 하였습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class MainActivity : AppCompatActivity() { private val binding: ActivityMainBinding by lazy { ActivityMainBinding.inflate(layoutInflater) } private val dbHelper: DatabaseHelper by lazy { DatabaseHelper.getInstance(applicationContext) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(binding.root) } override fun onDestroy() { dbHelper.close() super.onDestroy() } } 유틸 메소드 준비 데이터베이스 조작이 이루어졌을때 처리 결과를 텍스트뷰에 표시하기 위한 showTxt를 작성합니다. 그리고 버튼을 눌렀을 때 에디트텍스트에 입력한 내용을 삭제하는 clearEditTexts 함수도 작성합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 private fun showTxt(text: String) { binding.tvResult.append(text + \u0026#34;\\n\u0026#34;) } private fun clearEditTexts() { with(binding) { etId.setText(\u0026#34;\u0026#34;) etName.setText(\u0026#34;\u0026#34;) etPhone.setText(\u0026#34;\u0026#34;) etEmail.setText(\u0026#34;\u0026#34;) } } 버튼기능 정의 각 버튼을 클릭했을 때 부여할 기능을 정의합니다. 값을 입력하는 insertDb, 갱신하는 updateDb, 삭제하는 deleteDb, 그리고 조회하는 getAllDb함수를 만듭니다. 작업은 try 블록 안에서 실행하며 에디트텍스트에 입력한 값을 dbHelper에 정의한 각 함수로 전달합니다. 이 때 입력되는 sql 쿼리에 공백이 있으면 안되기 때문에 trim으로 공백을 제거하도록 했습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 private fun insertDb() { binding.btnInsert.setOnClickListener { try { dbHelper.insertData( binding.etName.text.toString().trim(), binding.etPhone.text.toString().trim(), binding.etEmail.text.toString().trim(), ) clearEditTexts() showTxt(\u0026#34;Data inserted\u0026#34;) } catch (e: Exception) { e.printStackTrace() } } } private fun updateDb() { binding.btnUpdate.setOnClickListener { try { dbHelper.updateData( binding.etId.text.toString().trim(), binding.etName.text.toString().trim(), binding.etPhone.text.toString().trim(), binding.etEmail.text.toString().trim(), ) showTxt(\u0026#34;Data updated\u0026#34;) } catch (e: Exception) { e.printStackTrace() } } } private fun deleteDb() { binding.btnDelete.setOnClickListener { try { dbHelper.deleteData(binding.etId.text.toString().trim()) clearEditTexts() showTxt(\u0026#34;Data deleted\u0026#34;) } catch (e: Exception) { e.printStackTrace() } } } private fun getAllDb() { binding.btnView.setOnClickListener { try { val selectResult = dbHelper.getAllData() showTxt(selectResult) } catch (e: Exception) { e.printStackTrace() } } } onCreate 정의 마지막으로 위에서 정의한 버튼기능을 onCreate 안에서 실행하도록 하면 되겠죠.\n1 2 3 4 5 6 7 8 9 override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(binding.root) insertDb() updateDb() deleteDb() getAllDb() } 이렇게 해서 SQLite의 개념과, SQLiteHelper를 이용해 안드로이드에서 데이터베이스를 다루는 법에 대해 알아보았습니다.\n","date":"2021-09-25T17:33:35+09:00","permalink":"https://cliearl.github.io/posts/android/implement-crud-with-sqliteopenhelper/","title":"SQLite 이해하고 SQLiteOpenHelper로 CRUD 구현하기"},{"content":"Github에는 다음과 같이 프로필 페이지를 설정할 수 있는 기능이 있습니다.\n프로필 페이지 생성 프로필 페이지를 설정하기 위해서는\n내 github ID와 동일한 이름의 저장소를 만들고, public으로 설정한 뒤, README.md 파일을 생성해줍니다. 그러면 github이 README.md를 특별히 프로필 페이지로 인식해 주므로 카와이하게 별모양으로 수정하시면 됩니다.\nGitHub 사용통계 표시 GitHub Readme Stats를 사용하면 나의 Github 활동 통계를 다음과 같이 카드로 볼 수 있습니다.\n사용법은 간단합니다. 다음 코드를 README.md에 붙여넣으면 됩니다. 여러가지 테마나 옵션도 설정할 수 있으므로 이것저것 시험해보세요.\n1 [![Anurag\u0026#39;s GitHub stats](https://github-readme-stats.vercel.app/api?username=\u0026#34;자신의 Github ID\u0026#34;)](https://github.com/anuraghazra/github-readme-stats) 다음 코드를 사용하면 어떤 언어를 주로 사용하고 있는지도 표시할 수 있습니다.\n1 [![Top Langs](https://github-readme-stats.vercel.app/api/top-langs/?username=\u0026#34;자신의 Github ID\u0026#34;)](https://github.com/anuraghazra/github-readme-stats) 뱃지 표시하기 shields.io 를 이용하면 프로필에 여러가지 뱃지를 달 수 있습니다. 제공되는 뱃지 종류는 여러가지가 있는데 여기서는 프로필에 사용하는 두가지 뱃지만 소개합니다.\n소셜 Social 페이지에서 다음과 같이 원하는 배지에 대한 코드를 만들어서 소셜 관련된 뱃지를 달 수 있습니다.\n1 2 3 ![Twitter Follow](https://img.shields.io/twitter/follow/github?style=social) ![YouTube Channel Subscribers](https://img.shields.io/youtube/channel/subscribers/UC7c3Kb6jYCRj4JOHHZTxKsQ?style=social) 기술 스택 기술 스택 표시를 위한 뱃지는 Simple Icons에서 아이콘을 검색한 뒤 다음 양식에 따라 코드를 작성하면 됩니다.\n1 2 3 4 ![기술 뱃지](https://img.shields.io/badge/\u0026#34;표시할 이름\u0026#34;-\u0026#34;뱃지 색상\u0026#34;?style=flat\u0026amp;logo=\u0026#34;Simple Icons 이름\u0026#34;\u0026amp;logoColor=white) // 예제 ![github badge](https://img.shields.io/badge/Github-181717?style=flat\u0026amp;logo=Github\u0026amp;logoColor=white) 코드를 입력하면 뱃지는 다음과 같이 표시됩니다.\n","date":"2021-09-07T18:39:09+09:00","permalink":"https://cliearl.github.io/posts/etc/customize-github-profile/","title":"Github Profile Page 꾸미기"},{"content":"이번 포스팅에서는 싱글톤 패턴에 대해 알아보도록 하겠습니다.\nSingleton 이란 싱글톤(Singleton)은 소프트웨어 디자인패턴의 한 종류로, 프로그램 안에서 클래스의 인스턴스가 단 하나만 존재해야 할 때 사용합니다. 예를들어 데이터베이스를 변경할 수 있는 DBHandler 클래스의 인스턴스가 두개 있어서 동시에 데이터베이스에 접근한다면 문제가 생기겠죠.\n자바에서는 일반적으로 다음과 같은 방식으로 싱글톤을 구현할 수 있습니다. private를 이용해 외부에서 생성자에 접근하지 못하도록 막고 getInstance를 통해야 인스턴스를 만들 수 있게 합니다. 이 때 static instance를 확인해서 인스턴스가 없으면 객체를 새로 만들고, 있다면 그대로 반환해주는 구조를 가집니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class DBHandler { private static DBHandler instance; // 생성자 접근 차단 private DBHandler(){} public static DBHandler getInstance() { if(instance == null) { instance = new DBHandler(); } return instance; } } 코틀린에서 구현하기 그런데 코틀린에서는 object 키워드를 사용해서 다음과 같이 간단하게 싱글톤을 생성할 수 있습니다. 언어차원에서 object 키워드로 생성하는 인스턴스는 초기화시 한번만 실행되며 Thread-safe하다는 것이 보장되기 때문에 싱글톤을 만들기 위해서는 따로 패턴을 만들어서 구현할 필요없이 그냥 object를 사용하면 됩니다.\n1 2 object DBHandler {...} val dbHandler = DBHandler 클래스로 구현하기 다만 object를 사용하면 인스턴스를 생성할 때 파라미터를 전달할 수가 없다는 한계가 있습니다. 파라미터를 전달하기 위해서는 결국 다음과 같이 클래스를 구성해서, 자바의 static을 companion object로 구현하도록 해야 합니다.\n아래 보이는 코드는 맨 처음에 보여드린 자바코드와 동일한 작동을 하는 코틀린 코드입니다. private를 이용해 외부에서 생성자에 직접 접근하지 못하도록 막고 getInstance를 통해야 인스턴스를 만들수 있게 합니다.\n그 후 instance를 확인해서 값이 없으면 새로 만들고, 그렇지 않다면 기존 값을 반환하는 구조를 가지고 있습니다. 이 때 생성자는 context를 전달받을 수 있게 구성하였습니다.\n1 2 3 4 5 6 7 8 9 10 class DBHandler private constructor(context: Context) { companion object { private var instance: DBHandler? = null fun getInstance(context: Context) = instance ?: DBHandler(context).also { instance = it } } } Double Checked Locking 앞에서 설명한 구조라면 한 개의 스레드안에서는 싱글톤이 구현됩니다. 하지만 두 개의 스레드가 동시에 인스턴스를 만들려고 접근할 경우를 생각해보겠습니다.\n인스턴스를 만들기 직전에 두 스레드가 보는 instance는 모두 null이기 때문에 각 스레드는 모두 인스턴스를 만드는데 성공하게 되어 두 개의 DBHandler 인스턴스가 생성되게 됩니다.\n싱글톤 생성시 발생하는 이러한 스레드 동기화 문제를 해결하기 위해 제안된 해결책 중 Double Checked Locking(DCL) 방법이 있는데요, 코틀린에서는 다음과 같이 구현할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 class DBHandler private constructor(context: Context) { companion object { @Volatile private var instance: DBHandler? = null fun getInstance(context: Context) = instance ?: synchronized(DBHandler::class.java) { instance ?: DBHandler(context).also { instance = it } } } } 8번 라인에서 인스턴스를 생성하기 전에 7번 라인에서 synchronized를 써서 스레드가 동시에 경합하지 않도록 막아줍니다. 7번 라인에서는 synchronized를 실행하기 전에 instance의 null을 한 번 더 체크합니다. 이 체크가 없으면 각 스레드에서 getInstance에 접근할 때 인스턴스가 이미 존재하더라도 synchronized에 의해 일단 lock이 걸리게 되어 성능저하가 발생할 수 있습니다. 그래서 우선 널체크를 하고 인스턴스가 없을때만 synchronized 이하 블록을 실행하도록 한 것입니다. 이렇게 두번에 걸쳐 인스턴스를 체크하기 때문에 Double Checked Locking 이라는 이름이 붙었습니다.\n이때 instance 변수에는 Volatile 어노테이션을 붙였습니다. 스레드는 메인 메모리와 독립된 스택 메모리 공간을 할당받습니다. 그래서 스레드가 객체를 참조할 때는 메인 메모리를 바로 보는 것이 아니라, 메인 메모리에서 읽어온 내용을 스레드의 스택에 저장한 후 이 스택을 보게 되어 있습니다. 다시말해 인스턴스를 인식하는데 시차가 발생하게 됩니다.\n그렇게 되면 메인 메모리에서 null인 instance 객체를 1번 스레드에서 확인하고 인스턴스화 하더라도, 2번 스레드에서 확인한 instance는 아직 null로 보여서 인스턴스를 만드는 일이 발생할 수 있습니다. 이 때 instance에 Volatile 어노테이션을 붙여주면 스레드가 메인메모리에서 직접 instance를 참조하게 되므로 인스턴스 인식 시차에 의해 싱글톤이 깨지는 문제를 회피할 수 있습니다.\nJDK 1.4 이하에서는 이 Volatile 기능이 제대로 호환되지 않는 문제가 있었지만 현재 JDK 1.8을 사용하고 있는 안드로이드에서는 사용하는데 문제가 없습니다.\nDCL에 대해서는 여러가지 논란이 있습니다만 그래도 이 구조는 현재 구글의 Room 라이브러리나, 코틀린의 lazy 함수에서도 사용되는 코드이기 때문에 안심하고 사용하셔도 될 것 같습니다.\nBill Pugh Solution 하지만 메인 메모리를 직접 사용하면서 스레드를 잠그는 방식은 처리성능에 영향을 줄 수 있는데요, 자바에는 Volatile + synchronized 조합을 사용하지 않아도 Thread-safe한 싱글톤을 만드는 Bill Pugh Solution이라는 수법이 있습니다.\n여기서는 Inner static helper class를 활용합니다. 예를 들어 두 개의 스레드가 순서대로 getInstance를 실행했다고 하겠습니다. 우선 1번 스레드에 의해 실행된 getInstance는 holder 클래스를 통해 싱글톤을 생성합니다. 이 작업중에 2번 스레드가 getInstance를 실행해도 인스턴스는 private static final로 되어있기 때문에 JVM은 1번 스레드의 작업완료를 기다리게 됩니다.\n따라서 성능저하를 불러올 수 있는 synchronized를 사용하지 않고도 Thread-safe하게 싱글톤을 생성할 수 있게 됩니다. 또한 getInstance를 실행하기 전까지는 싱글톤이 생성되지 않으므로 자원을 낭비하지 않을 수도 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 public class DBHandler { private DBHandler() {} private static class Holder{ private static final DBHandler INSTANCE = new DBHandler(); } public static DBHandler getInstance() { return Holder.INSTANCE; } } 위 코드는 굳이 코틀린으로 변환한다면 다음과 같은 코드가 될 것입니다. 다만 내부 클래스가 object가 되어 생성자를 사용할 수 없으므로 이럴거면 그냥 처음부터 DBHandler를 object로 인스턴스화 하는것이 나을것 같네요.\n1 2 3 4 5 6 7 8 9 class DBHandler private constructor() { companion object { val instance: DBHandler by lazy { Holder.INSTANCE } } private object Holder { val instance = DBHandler() } } 이렇게 해서 싱글톤 패턴을 구현하는 방법에 대해 알아보았습니다.\n","date":"2021-09-05T15:59:57+09:00","permalink":"https://cliearl.github.io/posts/android/understanding-singleton-pattern/","title":"알기쉬운 Singleton Pattern"},{"content":"Language and OS CppCon https://cppcon.org/program2020/\nCppCon 2020 JSConf https://jsconf.com/ https://2020.jsconf.kr/ko\nJSConf Korea 2020 Home Edition KotlinConf https://kotlinconf.com/ Kotlin Fest https://twitter.com/kotlin_fest Let\u0026rsquo;Swift http://letswift.kr/ Let\u0026rsquo;Swift 20 Oracle Code One https://www.oracle.com/code-one/ Pycon https://pycon.org/ https://www.pycon.kr/2020\nPyCon US 2020 PyCon.KR 2020 PyCon Japan 2020 try! Swift https://www.tryswift.co/\ndroidcon https://www.droidcon.com/\ndroidcon Italy 2020 DroidKaigi https://droidkaigi.jp/2020/\nDroidKaigi 2020 DroidKnights https://droidknights.github.io/2020/\nDroidKnights 2020 iOSDC Japan https://iosdc.jp/2020/\niOSDC Japan 2020 Company \u0026amp; Community Apple Worldwide Developers Conference (WWDC) https://developer.apple.com/wwdc20/\nDiscover More from our Apple Events AWS re:Invent https://reinvent.awsevents.com/\nAWS re:Invent 2020 AWS re:Invent 2020 Daily Recap - 일일 요약 re:Invent 2020 한국어 세션 AWS Summit Online https://aws.amazon.com/ko/events/summits/online/korea/\nAWS Summit Online Korea 2020 https://aws.amazon.com/jp/summits/2020/ AWS Summit Online 2020 オンデマンド Coupang Reveal https://event.coupangcorp.com\nReveal 2020: Talk concert with CTO DeNA TechCon https://techcon.dena.com/2020/\nDeNA TechCon 2020 ライブ配信 DEVELOPERWEEK https://www.developerweek.com/\nDeveloperWeek 2020 DockerCon https://www.docker.com/blog/dockercon-2020-top-rated-sessions-the-fundamentals/\nDockerCon 2020: Best Practices \u0026amp; How To DockerCon 2020: Devs in Action DockerCon 2020: Container Ecosystem ETRI Open Source Tech DAY https://eostday.kr/\nETRI 오픈소스 테크데이 2020 FEConf https://2020.feconf.kr/\nFEConf 2020 Korea FEConf 2020 A Track FEConf 2020 B Track Google Cloud Next https://cloud.withgoogle.com/next/\nGoogle Cloud Next ’20: OnAir - All Sessions Google I/O https://www.google.com/io\nIBM Developer Day https://developer.ibm.com/conferences/\nif (kakao) https://if.kakao.com/\nif (kakao)2020 INNO-CON https://www.innocon.co.kr/\nINNO-CON ㅣ CHANGE THE WORLD WITH SOFTWARE , 8th, Dec, 2020 LINE DEVELOPER DAY https://linedevday.linecorp.com/2020/\nLINE DEVELOPER DAY 2020 日本語音声 LINE DEVELOPER DAY 2020 Korean version Microsoft Build https://mybuild.microsoft.com/home\nMicrosoft Build 2020 Microsoft de:code https://www.microsoft.com/ja-jp/events/decode/2020/default.aspx\nde:code 2020 (6月17日-7月17日) Naver Cloud AI Summit https://www.ncloud-online.com/aisummit/\nNAVER Cloud AI SUMMIT (네이버클라우드 AI 서밋) Naver Deview https://deview.kr/\nDEVIEW 2020 NAVER TECH CONCERT https://techcon.naver.com/\nNAVER TECH CONCERT 2020 NHN FORWARD https://forward.nhn.com/\nNHN FORWARD 2020 Samsung Open Source Conference https://www.sosconhistory.net/soscon2020/\nSOSCON 2020 SESSION SOFTWARE EDU FEST https://sef.connect.or.kr/2020\nSEF2020 다시보기 Upbit Developer Conference https://udc.upbit.com/about/2020\nUDC 2020 | return blockchain * future; | 세부 프로그램 | Detailed program Woowa Tech Concert https://www.woowacon.com/\n우아한테크콘서트 공개SW 페스티벌 https://www.oss.kr/festival\n공개SW페스티벌 데이터야놀자 https://datayanolja.github.io/\n데이터야놀자2020 발표영상 라이선싱 콘 https://www.licensingcon.co.kr/page/licensing2020\n라이선싱 콘 2020 (컨퍼런스) 라이선싱 콘 2020 (실무워크숍) 마이데이터 컨퍼런스 https://www.datastars.or.kr/growth/2020-%EB%A7%88%EC%9D%B4%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%BB%A8%ED%8D%BC%EB%9F%B0%EC%8A%A4/\n4. 마이데이터 컨퍼런스 Games Develop:Brighton https://www.developconference.com/\nDevelop:Brighton Digital 2020 2020 Keynotes Game Developers Conference (GDC) https://gdconf.com/\nGDC20 Virtual Talks Google for Games Developer Summit https://events.withgoogle.com/gdc2020/\n게임 개발자를 위한 Google 회담 기조 연설 Inven game conference https://igc.inven.co.kr/\n[G-STAR 2020] G-CON X IGC Part. 1 [G-STAR 2020] G-CON X IGC Part. 2 Nexon Developers Conference (NDC) https://ndc.nexon.com/main\nNVIDIA GPU Technology Conference (GTC) https://www.nvidia.com/ko-kr/gtc/\nNVIDIA GTC October 2020 Keynote Unite Seoul http://www.unitysquare.co.kr/event/uniteseoul2020\nUnite Seoul 2020 Unreal Fest Online https://www.unrealengine.com/ko/events/unreal-fest-online-2020\nUnreal Fest Online 2020 | Unreal Engine Unreal Summit Online https://www.unrealengine.com/ko/events/unreal-summit-online-2020\n언리얼 서밋 ","date":"2021-08-20T22:48:02+09:00","permalink":"https://cliearl.github.io/posts/conferences/2020/","title":"2020년 개발관련 컨퍼런스 리스트"},{"content":"이번 포스팅에서는 Android Studio Arctic Fox와 JDK 11의 도입에 관한 내용을 다루어보도록 하겠습니다.\nAndroid Gradle 7.0.0 도입 2021년 7월 말에 Android Studio의 버전이 Arctic Fox|2020.3.1 로 올라갔습니다. 그 과정에서 Android Gradle plugin의 버전도 4.2.0에서 7.0.0으로 올라갔는데요, Android Gradle 7.0.0의 사양은 다음과 같습니다.\nDefault Version Gradle 7.0.2 SDK Build Tools 30.0.2 NDK 21.4.7075529 JDK 11 이번 플러그인의 가장 큰 변화중 하나는 디폴트 JDK 버전을 1.8에서 11로 올린점입니다. Java SE 8은 2014년 3월에 발표되었는데, 2019년 1월에 무료 업데이트가 종료되고 현재는 유료 업데이트만을 지원하고 있습니다. 따라서 구글에서는 사실상 기능지원이 종료된 8을 버리기로 결정한 것으로 보입니다.\nJava 8에서 11로 변경된 이유 그렇다면 왜 11버전이 선택되었을까요? 11은 2018년 9월 발표된 버전으로 8과 비교하면 기술적으로 많은 발전이 있었습니다. 그 내용에 대해서는 Microsoft의 Java 11로 전환해야 하는 이유를 참조하시면 좋을 것 같습니다.\nAndroid Studio에서 Java 11의 기능을 이용하고 싶다면 build.gradle을 다음과 같이 수정하면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 android { compileSdkVersion 30 compileOptions { sourceCompatibility JavaVersion.VERSION_11 targetCompatibility JavaVersion.VERSION_11 } // For Kotlin projects kotlinOptions { jvmTarget = \u0026#34;11\u0026#34; } } 또한 11은 LTS(Long Term Support)가 적용되었으며 ADOPTIUM 으로부터 오픈소스 빌드인 OpenJDK를 제공받을 수 있는 버전이기도 합니다. OpenJDK는 Oracle JDK의 기능을 모두 구현하면서도 무료로 사용할 수 있는 JDK라고 생각하시면 됩니다.\n이러한 이유들로 인해 구글에서는 Android Gradle의 JDK 디폴트 버전을 11로 채용하게 된 것으로 보입니다. synk에서 발표한 JVM Ecosystem Report 2020에 따르면 현재 Java SE 8 사용자는 64%, 11 사용자는 25%라고 하는데 이번 결정으로 11버전의 사용자가 빠르게 증가할 것 같네요.\nAndroid Studio의 빌드 실패 현재 Arctic Fox에서 New Project로 생성하는 프로젝트의 Android Gradle은 7.0.0 버전이 적용되도록 되어 있습니다.\n1 2 3 dependencies { classpath \u0026#34;com.android.tools.build:gradle:7.0.0\u0026#34; } 근데 문제는 프로젝트의 JDK가 1.8로 지정되었을 경우 Gradle의 디폴트 버전과 맞지 않으므로 다음과 같은 메시지를 뿜으며 빌드에 실패하게 됩니다.\n1 2 3 4 5 6 7 An exception occurred applying plugin request [id: \u0026#39;com.android.application\u0026#39;] \u0026gt; Failed to apply plugin \u0026#39;com.android.internal.application\u0026#39;. \u0026gt; Android Gradle plugin requires Java 11 to run. You are currently using Java 1.8. You can try some of the following options: - changing the IDE settings. - changing the JAVA_HOME environment variable. - changing `org.gradle.java.home` in `gradle.properties`. JDK 버전 변경 이 문제를 해결하기 위해서는 프로젝트가 사용하는 JDK 버전을 변경해주면 됩니다.\n안드로이드 스튜디오 4.2에는 이미 JDK 11이 내장되어 있지만 여기서는 패키지 버전관리가 용이한 brew를 통해 JDK 11을 새로 설치하여 사용하는 법을 소개하겠습니다.\n우선 brew로 시스템에 OpenJDK 11을 설치해 줍니다.\n1 2 $ brew tap AdoptOpenJDK/openjdk $ brew install --cask adoptopenjdk11 설치된 JDK의 위치는 /usr/libexec/java_home -V 명령으로 확인할 수 있습니다.\n다음은 JAVA_HOME 파라미터를 변경하기 위해 ~/.zshrc에 다음 행을 추가합니다.\n1 2 3 4 5 export JAVA_HOME=$(/usr/libexec/java_home -v 11) export PATH=${PATH}:$JAVA_HOME/bin // 변경사항 반영 $ source ~/.zshrc 마지막으로 Android Studio 메뉴에서 Preferences \u0026gt; Build, Execution, Deployment \u0026gt; Build Tools \u0026gt; Gradle로 들어가 Gradle JDK 항목을 Android Studio java home으로 변경해 주면 됩니다.\n","date":"2021-08-15T14:23:23+09:00","permalink":"https://cliearl.github.io/posts/android/android-gradle-java-11/","title":"Android Studio Arctic Fox와 JDK 11의 도입"},{"content":"이번 포스팅에서는 jsoup을 이용해서 html을 파싱하는 법에 대해 알아보도록 하겠습니다.\njsoup이란 jsoup은 html을 파싱하기 위해 만들어진 오픈소스 자바 라이브러리입니다. 웹페이지를 HTML5 DOM으로 변환하여 요소들을 간편하게 추출할 수 있습니다. 자바 라이브러리이니만큼 코틀린에서도 자유롭게 사용이 가능하지요.\njsoup에는 여러가지 클래스가 있는데 그 중 제 생각에 중요한 것들만 정리하면 다음과 같습니다.\n클래스 설명 Document jsoup로 얻어온 html 문서 Element 데이터를 추출할 수 있는 개별 html 요소 Elements Iterable한 Element 집합의 자료형 Connection http 접속에 관련한 메소드를 가지는 클래스 파싱할 html 구조 확인 그럼 코루틴으로 로또번호 당첨 확인하기 강의에서 만들었던 코루틴으로 로또번호 당첨을 확인하는 앱에 jsoup을 적용해보도록 하겠습니다. 기존의 앱은 당첨번호를 가져오는데 API를 사용했지만 이번에는 웹페이지에서 가져와야 합니다. 동행복권 홈페이지에 접속하면 메인화면에 금주의 당첨번호를 표시하고 있는데 이 내용을 가져오면 될 것 같습니다.\n이 화면을 브라우저의 개발자도구로 보면 html의 레이아웃을 확인할 수 있습니다. 우리가 원하는 정보는 containerWrap \u0026gt; article \u0026gt; wrap_box wrap1 \u0026gt; box win win645 \u0026gt; content 클래스 안에 위치하고 있네요. 여기서 회차와 당첨번호는 다음과 같은 요소로 정의되어 있습니다.\n1 \u0026lt;strong id=\u0026#34;lottoDrwNo\u0026#34;\u0026gt;968\u0026lt;/strong\u0026gt; 1 2 3 4 5 6 7 8 9 \u0026lt;span class=\u0026#34;accessibility\u0026#34;\u0026gt;당첨번호\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;drwtNo1\u0026#34; class=\u0026#34;ball_645 ball1\u0026#34;\u0026gt;2\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;drwtNo2\u0026#34; class=\u0026#34;ball_645 ball1\u0026#34;\u0026gt;5\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;drwtNo3\u0026#34; class=\u0026#34;ball_645 ball2\u0026#34;\u0026gt;12\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;drwtNo4\u0026#34; class=\u0026#34;ball_645 ball2\u0026#34;\u0026gt;14\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;drwtNo5\u0026#34; class=\u0026#34;ball_645 ball3\u0026#34;\u0026gt;24\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;drwtNo6\u0026#34; class=\u0026#34;ball_645 ball4\u0026#34;\u0026gt;39\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;bonus\u0026#34;\u0026gt;보너스번호\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;bnusNo\u0026#34; class=\u0026#34;ball_645 ball4\u0026#34;\u0026gt;33\u0026lt;/span\u0026gt; 라이브러리 추가 우선은 라이브러리를 추가합니다. 소스의 최신버전은 Github에서 확인할 수 있습니다.\n1 implementation \u0026#39;org.jsoup:jsoup:1.14.1\u0026#39; crawlLottoNumbers 작성 다음은 당첨번호를 가져오는 crawlLottoNumbers함수를 작성합니다. API로 당첨번호를 가져오는 getLottoNumbers와 동일하게 반환값이 당첨번호, 보너스번호, 회차 정보를 가지도록 하겠습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private suspend fun crawlLottoNumbers() : ArrayList\u0026lt;Int\u0026gt; { val lottoNumbers = ArrayList\u0026lt;Int\u0026gt;() // var doc: Document? = null try { val doc = Jsoup.connect(\u0026#34;https://dhlottery.co.kr/common.do?method=main\u0026#34;).get() for (i in 1..6) { val drwtNo = doc.select(\u0026#34;#drwtNo$i\u0026#34;).text().toInt() lottoNumbers.add(drwtNo) } val bnusNo = doc.select(\u0026#34;#bnusNo\u0026#34;).text().toInt() lottoNumbers.add(bnusNo) val lottoDrwNo = doc.select(\u0026#34;#lottoDrwNo\u0026#34;).text().toInt() lottoNumbers.add(lottoDrwNo) } catch (e: IOException) { e.printStackTrace() } return lottoNumbers } 우선은 connect로 세션을 생성하고 get을 수행해 html을 Document 객체로 만들어 줍니다.\nDocument 객체에서 데이터를 뽑아낼때는 select 명령을 사용하는데 괄호 안에는 CSS or jquery-like selector syntax를 넣습니다. 주요한 셀렉터들은 다음과 같습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 tagname: find elements by tag, e.g. a ns|tag: find elements by tag in a namespace, e.g. fb|name finds \u0026lt;fb:name\u0026gt; elements #id: find elements by ID, e.g. #logo .class: find elements by class name, e.g. .masthead [attribute]: elements with attribute, e.g. [href] [^attr]: elements with an attribute name prefix, e.g. [^data-] finds elements with HTML5 dataset attributes [attr=value]: elements with attribute value, e.g. [width=500] (also quotable, like [data-name=\u0026#39;launch sequence\u0026#39;]) [attr^=value], [attr$=value], [attr*=value]: elements with attributes that start with, end with, or contain the value, e.g. [href*=/path/] [attr~=regex]: elements with attribute values that match the regular expression; e.g. img[src~=(?i)\\.(png|jpe?g)] *: all elements, e.g. * 당첨번호와 회차정보는 id로 정의되어 있기 때문에 select 함수에 #id 쿼리를 전달해주면 됩니다. 추출한 정보가 String이니까 Int로 변환하여 lottoNumbers에 추가하면 되겠네요.\n이렇게 해서 jsoup으로 html을 다운받고 파싱하는 법에 대해 알아보았습니다.\n","date":"2021-08-14T11:03:31+09:00","permalink":"https://cliearl.github.io/posts/android/jsoup-lotto-checker/","title":"jsoup으로 로또 홈페이지의 당첨번호 파싱하기"},{"content":"이번 포스팅에서는 RecyclerView에 ListAdapter를 적용하는 법에 대해 알아보도록 하겠습니다.\n들어가기 Recyclerview의 데이터가 변하면 Recyclerview Adapter가 제공하는 notifyItem 메소드를 사용해서 ViewHolder 내용을 갱신할 수 있습니다.\n1 2 3 4 5 6 notifyItemChanged(int) notifyItemInserted(int) notifyItemRemoved(int) notifyItemRangeChanged(int, int) notifyItemRangeInserted(int, int) notifyItemRangeRemoved(int, int) 그런데 데이터가 변경되는 방식을 확인하고 그때마다 이렇게 notify를 일일이 해 주는것은 번거롭기도 하고, 또 사용하기에 따라서는 갱신이 필요없는 ViewHolder를 같이 갱신하는 불필요한 작업이 생길수도 있습니다.\nDiffUtil DiffUtil은 두 데이터셋을 받아서 그 차이를 계산해주는 클래스입니다. DiffUtil을 사용하면 두 데이터 셋을 비교한 뒤 그중 변한부분만을 파악하여 Recyclerview에 반영할 수 있습니다.\nDiffUtil은 Eugene W. Myers의 difference 알고리즘을 이용해서 O(N + D^2)시간 안에 리스트의 비교를 수행하는데 넥서스 5X에서 테스트를 수행한 결과는 다음과 같았다고 합니다. 이때 N은 추가 및 제거된 항목의 갯수이고, D는 스크립트의 길이입니다.\n1 2 3 4 5 6 7 100 items and 10 modifications: avg: 0.39 ms, median: 0.35 ms 100 items and 100 modifications: 3.82 ms, median: 3.75 ms 100 items and 100 modifications without moves: 2.09 ms, median: 2.06 ms 1000 items and 50 modifications: avg: 4.67 ms, median: 4.59 ms 1000 items and 50 modifications without moves: avg: 3.59 ms, median: 3.50 ms 1000 items and 200 modifications: 27.07 ms, median: 26.92 ms 1000 items and 200 modifications without moves: 13.54 ms, median: 13.36 ms DiffUtil을 사용하기 위해서는 DiffUtil.Callback()을 상속받아 areItemsTheSame으로 비교대상인 두 객체가 동일한지 확인하고, areContentsTheSame으로 두 아이템이 동일한 데이터를 가지는지 확인하면 됩니다.\nAsyncListDiffer DiffUtil은 아이템 개수가 많을 경우 비교연산에 필요한 시간이 길어질 수 있기 때문에 백그라운드 스레드에서 처리되어야 합니다. AsyncListDiffer는 DiffUtil을 편하게 쓰기 위해서 만들어진 클래스로, DiffUtil에 대해 자체적으로 스레드 처리를 해 줍니다.\n코드를 사용하기 위해서는 우선 어댑터 내부로 DiffUtil 콜백을 전달받은 AsyncListDiffer 객체를 만들어 줍니다. 그리고 currentList로 데이터를 참조하고 submitList 로 리스트 데이터를 갱신하면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // Google Developers에서 제공하는 코드 class UserAdapter extends RecyclerView.Adapter\u0026lt;UserViewHolder\u0026gt; { private final AsyncListDiffer\u0026lt;User\u0026gt; mDiffer = new AsyncListDiffer(this, DIFF_CALLBACK); @Override public int getItemCount() { return mDiffer.getCurrentList().size(); } public void submitList(List\u0026lt;User\u0026gt; list) { mDiffer.submitList(list); } @Override public void onBindViewHolder(UserViewHolder holder, int position) { User user = mDiffer.getCurrentList().get(position); holder.bindTo(user); } public static final DiffUtil.ItemCallback\u0026lt;User\u0026gt; DIFF_CALLBACK = new DiffUtil.ItemCallback\u0026lt;User\u0026gt;() { @Override public boolean areItemsTheSame( @NonNull User oldUser, @NonNull User newUser) { // User properties may have changed if reloaded from the DB, but ID is fixed return oldUser.getId() == newUser.getId(); } @Override public boolean areContentsTheSame( @NonNull User oldUser, @NonNull User newUser) { // NOTE: if you use equals, your object must properly override Object#equals() // Incorrectly returning false here will result in too many animations. return oldUser.equals(newUser); } } } ListAdapter ListAdapter는 AsyncListDiffer를 더 쓰기 편하도록 랩핑한 클래스로 Recyclerview 어댑터를 만들때 ListAdapter를 상속하도록 하면 됩니다. 초기화할때 DiffUtil 콜백 객체를 받도록 하면 나머지는 AsyncListDiffer와 같이 currentList로 현재 데이터를 불러올 수 있고, submitList로 데이터를 갱신할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Google Developers에서 제공하는 코드 class UserAdapter extends ListAdapter\u0026lt;User, UserViewHolder\u0026gt; { public UserAdapter() { super(User.DIFF_CALLBACK); } @Override public void onBindViewHolder(UserViewHolder holder, int position) { holder.bindTo(getItem(position)); } public static final DiffUtil.ItemCallback\u0026lt;User\u0026gt; DIFF_CALLBACK = new DiffUtil.ItemCallback\u0026lt;User\u0026gt;() { @Override public boolean areItemsTheSame( @NonNull User oldUser, @NonNull User newUser) { // User properties may have changed if reloaded from the DB, but ID is fixed return oldUser.getId() == newUser.getId(); } @Override public boolean areContentsTheSame( @NonNull User oldUser, @NonNull User newUser) { // NOTE: if you use equals, your object must properly override Object#equals() // Incorrectly returning false here will result in too many animations. return oldUser.equals(newUser); } } } 다시말해 Recyclerview 어댑터를 ListAdapter로 구현하면 데이터가 어떻게 바뀌든간에 submitList로 전체 리스트를 넘겨주기만 하면 어댑터가 알아서 백그라운드 스레드를 사용해 리스트 차이를 계산하여 화면을 갱신시켜주게 됩니다.\n앱 작성 여기서는 Data class 이해하고 RecyclerView에서 사용하기에서 작성했던 프로젝트를 고치면서 ListAdapter를 구현해 보도록 하겠습니다.\nMonster.kt 우선 Recyclerview에 표시할 데이터를 Data class 형태로 준비합니다.\n1 2 3 4 5 6 7 8 9 10 11 data class Monster( val name: String, val race: Race, val level: Int, val stats: List\u0026lt;Int\u0026gt;, val encount: Boolean ) enum class Race { Zombie, Human, Goblin, Dragon } view_itemlist.xml Recyclerview의 ViewHolder 레이아웃을 만들어줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/vhLayout\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;?attr/selectableItemBackground\u0026#34; android:baselineAligned=\u0026#34;false\u0026#34; android:gravity=\u0026#34;center_vertical\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:padding=\u0026#34;10dp\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;9\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_name\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:padding=\u0026#34;3dp\u0026#34; android:text=\u0026#34;Monster name\u0026#34; android:textSize=\u0026#34;24sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_race\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Race\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_level\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Level\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_stats\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Stats\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_encount\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Encount\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;30dp\u0026#34; android:layout_height=\u0026#34;30dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:src=\u0026#34;@drawable/ic_baseline_reorder_24\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; MyViewHolder.kt Recyclerview의 ViewHolder 클래스를 만들어줍니다. View Binding을 사용하도록 세팅하고 나중에 투명도를 바꾸는데 사용하도록 setAlpha 함수를 만들어줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class MyViewHolder(private val binding: ViewItemlistBinding) : RecyclerView.ViewHolder(binding.root) { fun bind(data: Monster) { with(binding) { tvName.text = \u0026#34;Name: ${data.name}\u0026#34; tvRace.text = \u0026#34;Race: ${data.race}\u0026#34; tvLevel.text = \u0026#34;Level: ${data.level}\u0026#34; tvStats.text = \u0026#34;HP: ${data.stats[0]} / MP: ${data.stats[1]} / Exp: ${data.stats[2]}\u0026#34; tvEncount.text = \u0026#34;Encounted: ${data.encount}\u0026#34; vhLayout.setOnClickListener { Snackbar.make(it, \u0026#34;Item $layoutPosition touched!\u0026#34;, Snackbar.LENGTH_SHORT).show() } } } fun setAlpha(alpha: Float) { with(binding) { tvName.alpha = alpha tvRace.alpha = alpha tvLevel.alpha = alpha tvStats.alpha = alpha tvEncount.alpha = alpha } } } MyDiffCallback.kt 코틀린에서는 Equality를 다음과 같이 두가지 방법으로 판정할 수 있습니다.\nStructural equality (==- a check for equals())\nReferential equality (===- two references point to the same object)\nareItemsTheSame에서 비교대상인 두 객체가 Referential equality를 갖는지 판정하는데에는 ===를 이용하였습니다. 그리고 areContentsTheSame 에서 두 객체의 아이템이 Structural equality를 갖는지 판정하는데에는 equals를 사용했습니다. Monster가 데이터클래스이기 때문에 데이터클래스의 정의에 따라 ==을 equals 대신 사용할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 class MyDiffCallback : DiffUtil.ItemCallback\u0026lt;Monster\u0026gt;() { override fun areItemsTheSame(oldItem: Monster, newItem: Monster): Boolean { return oldItem === newItem } override fun areContentsTheSame(oldItem: Monster, newItem: Monster): Boolean { return oldItem == newItem } } MyListAdapter.kt ListAdapter를 상속받는 Recyclerview Adapter를 작성합니다. onCreateViewHolder에서 뷰바인딩을 사용하도록 설정합니다. 데이터의 개수는 ListAdapter가 관리하므로 기존의 Recyclerview 어댑터에서 정의했던 getItemCount는 오버라이드하지 않아도 됩니다.\n그리고 아이템을 이동했을때 실행할 moveItem, 지울때 실행할 removeItem 메소드를 작성해줍니다. 이 때 ListAdapter에서는 데이터를 직접 조작할 수 없고 비교만 할수 있기 때문에 변형된 데이터셋은 새로운 객체로 만들어 기존의 데이터셋과 비교도록 submitList를 수행하게 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class MyListAdapter : ListAdapter\u0026lt;Monster, RecyclerView.ViewHolder\u0026gt;(MyDiffCallback()) { override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder { val viewHolder = MyViewHolder( ViewItemlistBinding.inflate( LayoutInflater.from(parent.context), parent, false ) ) return viewHolder } override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) { if (holder is MyViewHolder) { val monster = getItem(position) as Monster holder.bind(monster) } } fun moveItem(fromPosition: Int, toPosition: Int) { val newList = currentList.toMutableList() // val item = newList.removeAt(fromPosition) // newList.add(toPosition, item) Collections.swap(newList, fromPosition, toPosition) submitList(newList) } fun removeItem(position: Int) { val newList = currentList.toMutableList() newList.removeAt(position) submitList(newList) } } MyItemTouchHelperCallback.kt 기존 프로젝트에서 터치 콜백을 받기 위해 MainActivity에서 사용했던 ItemTouchHelper.SimpleCallback 클래스는 코드의 가독성을 위해 개별 클래스로 분리시키겠습니다.\n그리고 홀딩중인 ViewHolder는 투명하게 변화시켜 더 인지하기 쉽게 만들겠습니다. 그럴려면 onSelectedChanged에서 투명도를 50%로 낮추었다가 clearView에서 다시 100%로 되돌리도록 하면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class MyItemTouchHelperCallback(private val recyclerView: RecyclerView) : ItemTouchHelper.SimpleCallback( ItemTouchHelper.UP or ItemTouchHelper.DOWN, ItemTouchHelper.LEFT ) { override fun onMove( recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder, target: RecyclerView.ViewHolder ): Boolean { (recyclerView.adapter as MyListAdapter).moveItem( viewHolder.absoluteAdapterPosition, target.absoluteAdapterPosition ) return true } override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) { (recyclerView.adapter as MyListAdapter).removeItem(viewHolder.layoutPosition) } // 홀딩중인 ViewHolder 투명도를 변경 override fun onSelectedChanged(viewHolder: RecyclerView.ViewHolder?, actionState: Int) { super.onSelectedChanged(viewHolder, actionState) when (actionState) { ItemTouchHelper.ACTION_STATE_DRAG, ItemTouchHelper.ACTION_STATE_SWIPE -\u0026gt; { (viewHolder as MyViewHolder).setAlpha(0.5f) } } } // 홀딩중인 ViewHolder 투명도를 되돌림 override fun clearView( recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder ) { super.clearView(recyclerView, viewHolder) (viewHolder as MyViewHolder).setAlpha(1.0f) } } activity_main.xml Recyclerview와 floating action button을 배치해줍니다. DiffUtil 처리를 테스트하기 위해 플로팅버튼을 누르면 데이터가 랜덤하게 뒤섞이는 기능이 수행되도록 하겠습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;androidx.recyclerview.widget.RecyclerView android:id=\u0026#34;@+id/recyclerview\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:scrollbars=\u0026#34;vertical\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; tools:listitem=\u0026#34;@layout/view_itemlist\u0026#34; /\u0026gt; \u0026lt;com.google.android.material.floatingactionbutton.FloatingActionButton android:id=\u0026#34;@+id/fab\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_margin=\u0026#34;20dp\u0026#34; android:src=\u0026#34;@drawable/ic_baseline_add_24\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; MainActivity.kt 데이터셋에 초기값을 넣어주고, 어댑터 인스턴스를 생성하여 Recyclerview와 연동시킵니다. 그리고 터치헬퍼를 달아 스와이프와 드래그를 했을때 데이터가 잘 갱신되는지 확인합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class MainActivity : AppCompatActivity() { private val binding: ActivityMainBinding by lazy { ActivityMainBinding.inflate(layoutInflater) } private val myListAdapter: MyListAdapter by lazy { MyListAdapter() } private val dataSet = arrayListOf\u0026lt;Monster\u0026gt;().apply { add(Monster(\u0026#34;타일런트\u0026#34;, Race.Zombie, 10, listOf(100, 10, 50), false)) add(Monster(\u0026#34;조커\u0026#34;, Race.Human, 23, listOf(200, 20, 100), false)) add(Monster(\u0026#34;그렘린\u0026#34;, Race.Goblin, 2, listOf(10, 1, 5), true)) add(Monster(\u0026#34;리오레우스\u0026#34;, Race.Dragon, 2500, listOf(10000, 1000, 50000), false)) add(Monster(\u0026#34;사우론\u0026#34;, Race.Human, 100, listOf(1000, 200, 1000), false)) add(Monster(\u0026#34;리바이어던\u0026#34;, Race.Dragon, 50, listOf(2000, 250, 10000), true)) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(binding.root) binding.recyclerview.apply { layoutManager = LinearLayoutManager(context, LinearLayoutManager.VERTICAL, false) addItemDecoration(DividerItemDecoration(context, DividerItemDecoration.VERTICAL)) adapter = myListAdapter } myListAdapter.submitList(dataSet) binding.fab.setOnClickListener { myListAdapter.submitList(dataSet.shuffled()) } val itemTouchHelper = ItemTouchHelper(MyItemTouchHelperCallback(binding.recyclerview)) itemTouchHelper.attachToRecyclerView(binding.recyclerview) } } 이렇게해서 ListAdapter를 RecyclerView에 적용하는 법에 대해 알아보았습니다.\n","date":"2021-07-31T21:22:17+09:00","permalink":"https://cliearl.github.io/posts/android/recyclerview-listadapter/","title":"DiffUtil과 ListAdapter 이해하고 RecyclerView에 적용하기"},{"content":"minSdkVersion 과연 몇으로 해야할지 정해드립니다.\n다음 코드는 build.gradle의 코드 일부입니다. build.gradle의 minsdkversion은 내 앱을 설치할 수 있는 기기버전을 정하는 인자인데요, 낮으면 낮을수록 더 많은 기기에 앱을 설치할 수 있지만 그만큼 앱을 설계할 때 구형 API까지 고려해야 한다는 문제가 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 android { compileSdkVersion 30 buildToolsVersion \u0026#34;30.0.3\u0026#34; defaultConfig { applicationId \u0026#34;com.example.myapplication\u0026#34; minSdkVersion 16 targetSdkVersion 30 versionCode 1 versionName \u0026#34;1.0\u0026#34; testInstrumentationRunner \u0026#34;androidx.test.runner.AndroidJUnitRunner\u0026#34; } 그렇다면 2021년 7월 현재, 앱의 minSdkVersion은 몇으로 하는게 적당할까요?\nAPI 버전별 특징 그걸 판단하기 위해서 API별로 어떤 기능이 추가되었는지를 확인하는게 좋을 것 같습니다. 제가 생각하기에 API별로 채용된 특징 중 성능이나 개발과정에 큰 변화를 가져오는 내용은 다음과 같습니다.\n21 Lollipop ART를 기본 런타임환경으로 채용 : Dalvik 런타임이 ART로 변경되면서 구동 퍼포먼스가 향상되었습니다.\nOpenGL ES 3.1 지원 : 그래픽처리에서 더 많은 기능을 사용할 수 있게 되었습니다.\n머테리얼 디자인 지원 : 구글에서 제시한 플랫 디자인을 사용할 수 있게 되었습니다.\n23 Marshmallow 런타임 퍼미션 채용 : GPS나 파일쓰기 같은 위험한 권한이 필요할 때 앱 실행중에 권한을 추가적으로 요청함으로써 사용자의 주의를 환기시키는 것이 가능해졌습니다. 24 Nougat ART 엔진 개선 : 기존의 ART 런타임을 ART + JIT 형태로 변경하여 상호보완적인 기능을 수행하도록 하였습니다.\nOpenGL ES 3.2 지원 그래픽처리에서 더더 많은 기능을 사용할 수 있게 되었습니다.\n26 Oreo 백그라운드 실행제한 : 백그라운드에서 앱이 계속 살아있지 못하도록 제한하므로 API 26부터는 백그라운드를 사용하는 앱의 구조를 근본적으로 다시 설계해야 합니다. 사용자 비율 statcounter 와 AppBrain이 제공하는 2021년 7월 현재 전세계 안드로이드 API 점유율은 다음 표와 같습니다. 킷캣은 1%대 점유율을 가지고 있네요. 일본내 점유율만을 보여주는 smatabinfo에 따르면 이젠 롤리팝조차 1% 점유율이 안된다고 하네요.\nOS Version API level statcounter AppBrain smatabinfo 11 (Android 11) 30 17.50% 17.20% 16.186% 10 (Android 10) 29 35.91% 33.00% 40.773% 9.0 (Pie) 28 17.03% 17.60% 18.903% 8.0-8.1 (Oreo) 26 13.04% 13.70% 13.118% 7.0-7.1 (Nougat) 24 6.89% 7.30% 7.594% 6.0 (Marshmallow) 23 4.63% 5.00% 2.175% 5.0-5.1 (Lollipop) 21 3.47% 4.00% 0.818% 4.4 (KitKat) 19 1.11% 1.40% 0.317% 결론 롤리팝(21)에서는 성능이 향상될 수 있는 여러가지 획기적인 기술도입이 있었으므로 킷캣(19)은 이제는 버리는게 맞아 보입니다. 다만 롤리팝은 설치시 퍼미션을 다 줘버리는 한계가 있으므로, 런타임 퍼미션을 사용할 수 있는 마시멜로(23)를 minsdkversion으로 설정하는 것을 추천합니다. 여기까지만 해도 95%의 기기를 커버할 수 있습니다.\n더 강력한 이유로는 https://twitter.com/minsdkversion 이 23을 트윗했기 때문입니다\u0026hellip;?\n23\n\u0026mdash; minSdkVersion (@minSdkVersion) December 9, 2019 그리고 개인적으로 개발하는 어플이라면 오레오(26)을 minSdkVersion으로 추천합니다. 누가(24)는 2019년 10월자로 보안 업데이트가 중단되어 해킹의 위험이 있는데다, API 26까지의 전세계 점유율은 이미 80%를 넘어섰고 앞으로도 계속 늘어날 것이기 때문입니다. 또한 개발자로서는 API 26 이전의 백그라운드 실행방식을 고려하지 않아도 되는 커다란 이점도 있습니다. 개발자의 편의를 위해 이젠 누가 이하를 사용하는 기기는 과감하게 지원을 포기하는것도 나쁘지 않다고 생각합니다.\n다시 말씀드리지만 상용앱이 아니라 개인적으로 개발하는 어플에 적용하는게 좋겠죠. 어디까지나 제 개인의 의견일 뿐이고 참고 정도로 생각해주시면 감사하겠습니다.\n","date":"2021-07-19T18:39:10+09:00","permalink":"https://cliearl.github.io/posts/android/how-much-minsdkversion/","title":"2021년 7월 현재, minSdkVersion 몇으로 해야 할까?"},{"content":"문제출처 : 프로그래머스 모의테스트 페이지 https://programmers.co.kr/learn/courses/18\n파트1. 자릿수 더하기 문제 https://programmers.co.kr/learn/courses/18/lessons/1876\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import Foundation func solution(_ n:Int) -\u0026gt; Int { var answer:Int = 0 let input = String(n) for c in input { answer += Int(String(c))! } // 또는 // answer = input.map({ Int(String($0))! }).reduce(0) { $0 + $1 } return answer } 파트2. 순열 검사 문제 https://programmers.co.kr/learn/courses/18/lessons/1877\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import Foundation func solution(_ arr:[Int]) -\u0026gt; Bool { var answer = true // 빠른 탐색을 위해 배열을 정렬 let newArr = arr.sorted() for i in 0..\u0026lt;newArr.count { // 중간에 false가 뜨면 더 이상 탐색하지 않고 종료 if answer == false { break } // contains는 느리므로 배열값을 i와 바로 비교 if newArr[i] != (i + 1) { answer = false } } return answer } 파트3. 나머지 한 점 문제 https://programmers.co.kr/learn/courses/18/lessons/1878\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import Foundation func solution(_ v: [[Int]]) -\u0026gt; [Int] { var answer = [Int]() let setA = v[0] let setB = v[1] let setC = v[2] // A와 B가 같으면 D는 C와 동일 // A와 C가 같으면 D는 B와 동일 // 같은게 없으면 D는 A와 동일 // 앞의 점 구하기 if (setA[0] == setB[0]) { answer.append(setC[0]) } else if (setA[0] == setC[0]) { answer.append(setB[0]) } else { answer.append(setA[0]) } // 뒤의 점 구하기 if (setA[1] == setB[1]) { answer.append(setC[1]) } else if (setA[1] == setC[1]) { answer.append(setB[1]) } else { answer.append(setA[1]) } return answer } 파트4. 가장 큰 정사각형 찾기 문제 https://programmers.co.kr/learn/courses/18/lessons/1879\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import Foundation func solution(_ board:[[Int]]) -\u0026gt; Int { var newBoard = board let row = newBoard.count let col = newBoard[0].count var answer = 0 // 행이나 열의 길이가 2 미만이라면 직접 돌리면서 1이 하나라도 있는지 체크 // 하나라도 있으면 통과. if (col \u0026lt; 2 || row \u0026lt; 2) { for i in 0 ..\u0026lt; row { for j in 0 ..\u0026lt; col { if newBoard[i][j] == 1 { answer = 1 } } } } else { // 배열의 [1][1]부터 반복문을 돌린다. (첫 번째 행, 첫 번째 열 무시) // 현재 값이 1일 경우, 좌측값, 상단값, 좌측상단값 중 // 가장 작은 값의 +1 한 값을 현재 값으로 할당 for i in 1 ..\u0026lt; row { for j in 1 ..\u0026lt; col { if newBoard[i][j] == 1 { newBoard[i][j] = min(newBoard[i - 1][j], newBoard[i][j - 1], newBoard[i - 1][j - 1]) + 1 if newBoard[i][j] \u0026gt; answer { answer = newBoard[i][j] } } } } } return answer - answer } 파트5. 땅따먹기 문제 https://programmers.co.kr/learn/courses/18/lessons/1880\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import Foundation func solution(_ land:[[Int]]) -\u0026gt; Int{ var answer = 0 var newLand = land for i in 1 ..\u0026lt; newLand.count { newLand[i][0] += max(newLand[i - 1][1], newLand[i - 1][2], newLand[i - 1][3]) newLand[i][1] += max(newLand[i - 1][0], newLand[i - 1][2], newLand[i - 1][3]) newLand[i][2] += max(newLand[i - 1][0], newLand[i - 1][1], newLand[i - 1][3]) newLand[i][3] += max(newLand[i - 1][0], newLand[i - 1][1], newLand[i - 1][2]) } answer = (newLand.last?.max())! return answer } 파트6. 스티커 모으기 문제 https://programmers.co.kr/learn/courses/18/lessons/1881\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import Foundation func solution(_ sticker:[Int]) -\u0026gt; Int{ // 예외처리 if sticker.count == 0 { return 0 } if sticker.count == 1 { return sticker[0] } var dp1 = [Int]() // 첫번째 뜯은 경우 var dp2 = [Int]() // 첫번째 안뜯은 경우 // 첫번째 뜯은 경우 첫번째는 스티커값 dp1.append(sticker[0]) dp1.append(dp1[0]) // 첫번째 안뜯은 경우 첫번째는 0, 두번째는 스티커값 dp2.append(0) dp2.append(sticker[1]) // 스티커가 원형인걸 반영하기 위해 탐색범위를 다르게 함 if sticker.count \u0026gt; 2 { // 첫번째를 뜯었으면 n-1을 뜯으면 안되므로 n-2까지 탐색 for i in 2 ... sticker.count - 2 { // 하나 건너뛰어서 스티커를 떼는게 나은지 다음 스티커를 기다릴지 판정 let value = max(dp1[i-2] + sticker[i], dp1[i-1]) dp1.append(value) } // n-1까지 탐색 for i in 2 ... sticker.count - 1 { let value = max(dp2[i-2] + sticker[i], dp2[i-1]) dp2.append(value) } } return max(dp1.max()!, dp2.max()!) } 파트7. 단어 퍼즐 문제 https://programmers.co.kr/learn/courses/18/lessons/1882\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import Foundation func solution(_ strs:[String], _ t:String) -\u0026gt; Int { let INF = 9999 let wordLength = t.count // 고속탐색을 위한 해시셋 생성 let strsSet = Set(strs.map { $0 }) // 고속탐색을 위한 스트링셋 생성 let splitT = t.map { String($0) } // 각 자리에서 사용가능한 단어조각 최소값 저장을 가장 큰값으로 저장한 배열을 생성 // dp[i] = min(dp[i+1],dp[i+2],dp[i+3],dp[i+4]) + 1 var dp = [Int](repeating: INF, count: wordLength) dp.append(0) // 각자리별로 사용 가능한 단어조각의 최소값을 뒷자리부터 계산 for i in (0 ..\u0026lt; wordLength).reversed() { // 단어조각 최대 길이는 5 for j in 0 ..\u0026lt; 5 { let k = i + j + 1 // 검색 인덱스를 넘어가면 종료 if k \u0026gt; wordLength { break } // 사용가능한 단어가 있는지 확인 // Swift의 String.index는 쓰기는 편하지만 매우 느리다 // let availWord = String(t[t.index(t.startIndex, offsetBy: i)..\u0026lt;t.index(t.startIndex, offsetBy: k)]) // 그래서 단어매치를 할땐 배열로 직접 가져와서 해시셋과 비교해야 된다 // strsSet과 비교할 단어를 생성 var availWord = String() for idx in i ..\u0026lt; k { availWord += splitT[idx] } // 조합이 가능하면 dp[i]의 값을 최소값으로 갱신 if (strsSet.contains(availWord) \u0026amp;\u0026amp; dp[i + j + 1] != INF) { dp[i] = min(dp[i], dp[i + j + 1] + 1) } } } // 단어를 조합해서 만들 수 없으면 -1 반환, 아니면 dp[0] 반환 if dp[0] == INF { return -1 } return dp[0] } ","date":"2021-07-17T16:01:16+09:00","permalink":"https://cliearl.github.io/posts/coding-test/programmers-mocktest/","title":"프로그래머스 모의테스트 Swift 풀이"},{"content":"이번 포스팅에서는 코루틴을 사용해서 로또번호의 당첨을 확인하는 법에 대해 알아보도록 하겠습니다.\n당첨번호 조회하기 이전에 로또번호 생성기 만들기강의에서 로또번호를 생성하는 앱을 만들어보았는데요, 여기서는 이 앱에 코루틴을 이용해서 당첨여부를 확인하는 기능을 추가하도록 하겠습니다. 코루틴에 대한 이론설명은 알기쉬운 코루틴 이론 강의를 참조하시기 바랍니다.\n금주의 로또 당첨번호는 동행복권 홈페이지에서 확인할 수 있습니다. 다른 회차의 당첨번호는 홈페이지의 회차별 당첨번호 페이지에서 확인할 수 있게 되어 있습니다.\n그런데 이렇게 홈페이지에 접속하지 않고도 당첨번호는 API로 조회할 수 있습니다. 다음 주소의 \u0026ldquo;회차\u0026quot;라고 되어 있는 부분에 확인하고 싶은 회차의 숫자를 넣으시면 됩니다.\n1 https://dhlottery.co.kr/common.do?method=getLottoNumber\u0026amp;drwNo=\u0026#34;회차\u0026#34; 예를 들면 968회차의 응답은 다음과 같은 json 형식으로 돌아옵니다. totSellamnt는 총 판매액, returnValue는 API응답 성공여부, drwNoDate는 추첨일, firstWinamnt는 1등상금, drwNo는 회차, drwtNo1~6이 당첨번호이고, bnusNo가 보너스번호입니다.\n1 {\u0026#34;totSellamnt\u0026#34;:95924229000,\u0026#34;returnValue\u0026#34;:\u0026#34;success\u0026#34;,\u0026#34;drwNoDate\u0026#34;:\u0026#34;2021-06-19\u0026#34;,\u0026#34;firstWinamnt\u0026#34;:1667729683,\u0026#34;drwtNo6\u0026#34;:39,\u0026#34;drwtNo4\u0026#34;:14,\u0026#34;firstPrzwnerCo\u0026#34;:13,\u0026#34;drwtNo5\u0026#34;:24,\u0026#34;bnusNo\u0026#34;:33,\u0026#34;firstAccumamnt\u0026#34;:21680485879,\u0026#34;drwNo\u0026#34;:968,\u0026#34;drwtNo2\u0026#34;:5,\u0026#34;drwtNo3\u0026#34;:12,\u0026#34;drwtNo1\u0026#34;:2} Dependency 확인 자 그러면 drwtNo1~6, bnusNo의 값을 추출해서 나의 값과 비교하면 되겠네요. 당첨번호는 네트워크에서 백그라운드로 받아와야 하기 때문에 코루틴으로 처리하도록 하면 되겠고, 받아온 json으로부터 값을 추출하는데에는 gson 라이브러리를 사용하면 될 것 같습니다. gson의 사용법에 대해서는 SharedPreferences를 json 포맷으로 관리하기 강의에서 다루었으니 그것을 참고하시면 되겠습니다.\n1 2 implementation \u0026#39;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1\u0026#39; implementation \u0026#39;com.google.code.gson:gson:2.8.6\u0026#39; 네트워크로 당첨번호 받아오기 그럼 네트워크로 당첨번호를 받아오는 getLottoNumbers 함수와, 두 값을 비교하는 whatIsRank 함수를 만들도록 하겠습니다.\ngetLottoNumbers는 전달받은 API 주소에 조회를 요청하고 반환값을 처리합니다. 이 함수는 네트워크를 사용해야 하므로 코루틴 안에서 사용하기 위해 suspend 키워드를 붙여줍니다. API는 단순한 GET 요청이므로 소켓을 만들지 않고 간단하게 URL과 readText로 값을 읽어오도록 하였습니다.\nAPI 주소와 결합할 round에는 내 번호와 비교할 당첨번호의 회차를 넣습니다. 읽어온 값의 returnValue가 success이면 drwtNo1~6, bnusNo 값을 추출하여 배열에 모으도록 하였습니다. 마지막에는 당첨번호를 확인할 회차를 추가하였습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 private suspend fun getLottoNumbers(): ArrayList\u0026lt;Int\u0026gt; { val round = \u0026#34;968\u0026#34; val url = \u0026#34;https://dhlottery.co.kr/common.do?method=getLottoNumber\u0026amp;drwNo=$round\u0026#34; val lottoNumbers = ArrayList\u0026lt;Int\u0026gt;() try { val response = URL(url).readText() val jsonObject = JsonParser.parseString(response).asJsonObject val returnValue = jsonObject.get(\u0026#34;returnValue\u0026#34;).asString if (returnValue == \u0026#34;success\u0026#34;) { for (i in 1..6) { val lottoNumber = jsonObject.get(\u0026#34;drwtNo$i\u0026#34;).asInt lottoNumbers.add(lottoNumber) } val bonusNumber = jsonObject.get(\u0026#34;bnusNo\u0026#34;).asInt lottoNumbers.add(bonusNumber) lottoNumbers.add(round.toInt()) } } catch (e: Exception) { e.printStackTrace() } return lottoNumbers } 내 번호와 당첨번호 비교하기 다음은 내 번호와 당첨번호를 비교하는 함수를 만듭니다. 로또의 규칙은 표의 내용과 같이 되어 있습니다. 그래서 whatIsRank에서는 내 로또번호와 당첨번호를 전달받아 처음 6개까지의 숫자를 비교해 일치한 갯수를 세고, 일치한 번호의 갯수가 5개이면 추가로 보너스번호인 7번째 번호가 일치하는지 확인하도록 하면 됩니다.\n순위 당첨내용 1 6개 번호 모두 일치 2 5개 번호 일치 + 나머지 1개가 보너스 번호와 일치 3 5개 번호 일치 4 4개 번호 일치 5 3개 번호 일치 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 private suspend fun whatIsRank(lottoNumbers: ArrayList\u0026lt;Int\u0026gt;, winningNumbers: ArrayList\u0026lt;Int\u0026gt;): String { // https://namu.wiki/w/%EB%A1%9C%EB%98%90%206/45#s-4 var matchCount = 0 for (i in 0..5) { if (lottoNumbers.contains(winningNumbers[i])) { matchCount += 1 } } return if (matchCount == 6) { \u0026#34;1등\u0026#34; } else if (matchCount == 5) { if (lottoNumbers.contains(winningNumbers[6])) { \u0026#34;2등\u0026#34; } else { \u0026#34;3등\u0026#34; } } else if (matchCount == 4) { \u0026#34;4등\u0026#34; } else if (matchCount == 3) { \u0026#34;5등\u0026#34; } else { \u0026#34;낙첨\u0026#34; } } xml에는 비교결과를 보여주는 텍스트뷰 하나를 추가하도록 하겠습니다.\n1 2 3 4 5 6 7 8 \u0026lt;TextView android:id=\u0026#34;@+id/tv_winning\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;20dp\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;당첨결과\u0026#34; android:textAppearance=\u0026#34;@style/TextAppearance.AppCompat.Large\u0026#34; /\u0026gt; 코루틴으로 작업 처리하기 그러면 번호생성버튼을 눌렀을 때 생성된 번호를 당첨번호와 비교하는 코루틴을 추가하겠습니다. CoroutineScope로 스코프를 정의하고, 네트워크에서 값을 가져올 것이기 때문에 Dispatchers는 IO로 설정합니다. 그리고 작업 후에 값을 반환할 필요가 없기 때문에 빌더는 launch를 사용합니다.\n작업은 getLottoNumbers에서 얻어진 결과값를 whatIsRank에 사용해야 하기 때문에 winningNumbers는 async로 자식 코루틴을 만듭니다. whatIsRank에 전달할때는 Deferred 반환값을 끝까지 처리하여 ArrayList를 전해주기 위해 await를 사용합니다. 최종적으로 텍스트뷰에 표시할 텍스트를 만들때도 await를 사용해서 처리가 모두 종료될 때까지 기다리도록 합니다.\n마지막으로 text를 텍스트뷰에 표시해야 하는데 이 부분은 UI를 건드리는 부분이라 메인스레드에서 작업이 이루어져야 하기 때문에 작업할 스레드를 withContext로 전환한 뒤 당첨결과를 표시하면 되겠죠.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 binding.generateButton.setOnClickListener { val lottoNumbers = createLottoNumbers() Log.d(\u0026#34;TAG\u0026#34;, lottoNumbers.toString()) updateLottoBallImage(lottoNumbers) CoroutineScope(Dispatchers.IO + job).launch { val winningNumbers = async { getLottoNumbers() } val rank = whatIsRank(lottoNumbers, winningNumbers.await()) val text = \u0026#34;${winningNumbers.await()} : $rank\u0026#34; withContext(Dispatchers.Main) { binding.tvWinning.text = text } } } 코루틴 취소하기 액티비티가 종료되었을 때 실행중인 코루틴이 살아남는것을 방지하기 위해 취소하는 기능을 추가해 보도록 하겠습니다. 알기쉬운 코루틴 이론 강의에서 설명했던 것처럼 코루틴을 취소하기 위해서는 job에 대해 cancel을 수행하면 됩니다. 그런데 generateButton 안에서 수행된 CoroutineScope에 대해서는 반환되는 job을 오브젝트로 만들지 않았습니다.\n이런 경우에는 Job 전역변수를 하나 만들어 주고 디스패처와 결합합니다. 코틀린의 코루틴은 자식 코루틴이 취소되면 연결된 부모 코루틴이 모두 취소되는 특징을 가지고 있으므로 onDestroy에서 job에 대해 cancel을 수행하면 연결시킨 코루틴을 취소할 수 있습니다.\n실제 예제에서는 뷰모델을 이용하게 되므로 lifecycle 모듈과 결합하여 사용하면 좀 더 앱의 라이프사이클과 연동된 생명주기를 가지게 할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class MainActivity : AppCompatActivity() { ... private val job = Job() override fun onCreate(savedInstanceState: Bundle?) { ... binding.generateButton.setOnClickListener { ... CoroutineScope(Dispatchers.IO + job).launch { ... } } } override fun onDestroy() { job.cancel() super.onDestroy() } } 이렇게 코루틴을 이용해서 나의 로또번호를 인터넷의 당첨결과와 비교하는 법에 대해 알아보았습니다.\n","date":"2021-07-17T16:01:01+09:00","permalink":"https://cliearl.github.io/posts/android/lotto-checker/","title":"코루틴으로 로또번호 당첨 확인하기"},{"content":"작업환경에서 사용하는 폰트에 대하여 정리해 보았다.\n텍스트 에디터용 폰트 메모장, 워드, 파워포인트, 한글 등에서 한국어, 영어, 일본어를 모두 표시할 수 있는 폰트가 필요하다.\nGoogle Noto Fonts https://fonts.google.com/noto/use\n본고딕(Source Han Sans) 소개: 오픈 소스 한중일 통합 서체 KoPubWorld https://www.kopus.org/biz-electronic-font2/\n한국출판인회의에서 제공하는 전자출판에 특화된 서체 네이버 나눔폰트 https://hangeul.naver.com/2017/nanum\n네이버에서 제공하는 나눔시리즈 폰트 낸네 https://github.com/naen-nae/naen-nae\n라이선스 걱정 없는 한글 폰트 사이트 코딩용 폰트 코딩용 폰트에 요구되는 사항들\n문자열을 스페이스단위로 일치시켜야 하므로 폰트가 고정폭(Monospaced)이어야 한다. 오인식하기 쉬운 알파벳, 특수문자에 대한 대책이 있어야 한다. 특수문자의 가독성을 높여주는 Ligature는 필수는 아니다. 한글까지 깨끗하게 나오면 좋지만 영문체보다 중요하진 않다. 개인적으로 괜찮다 생각하는 폰트 (알파벳순) 폰트 특징 Consolas 마이크로소프트 개발. D2Coding 네이버 개발. 다닥다닥 붙어있는 느낌. 리가쳐 지원. Fira Code 리가쳐가 이쁘게 나옴. Hack 동글동글한 폰트. IBM Plex Mono IBM 개발. 정렬과 각을 강조. Inconsolata 동글하면서도 살짝 딱딱. Input Mono Inconsolata보다 폭이 약간 넓고 굵음. JetBrains Mono 젯브레인 개발. 아래위로 긴 느낌. 리가쳐 지원. Menlo 애플 개발. Myrica 일본어 코딩용. Source Code Pro 어도비 개발. 글씨폭이 넓고 아래위로 납작한 편. Ubuntu Mono 캐노니컬 개발. 폰트 확인 사이트 Programming Fonts Coding Font ","date":"2021-07-16T02:39:00+09:00","permalink":"https://cliearl.github.io/posts/etc/fonts-for-work/","title":"작업용 폰트 정보 정리"},{"content":"이번 포스팅에서는 코틀린의 코루틴(Coroutine)에 대해 알아보도록 하겠습니다.\n코루틴의 개념 안드로이드에서는 AsyncTask를 이용해서 손쉽게 비동기 프로그래밍을 구현했었지만 구글이 다음과 같이 밝힌 것처럼 메모리 누수등 여러가지 문제가 있었습니다. 그래서 API 30부터는 AsyncTask를 deprecate 시키고 코루틴을 사용하도록 권장하고 있습니다.\nAsyncTask was intended to enable proper and easy use of the UI thread. However, the most common use case was for integrating into UI, and that would cause Context leaks, missed callbacks, or crashes on configuration changes. It also has inconsistent behavior on different versions of the platform, swallows exceptions from {@code doInBackground}, and does not provide much utility over using {@link Executor}s directly.\n코루틴은 1958년 멜빈 콘웨이가 처음 제창했다고 하는 개념으로 현재 여러 프로그래밍 언어에 구현되어 있으며 코틀린만의 고유한 개념은 아닙니다.\n프로그래밍에서 루틴이란 프로그램의 흐름을 추상적으로 일컫는 말입니다. 루틴은 크게 메인루틴과 서브루틴으로 나눌 수 있는데요. 예를들어 main 함수에 의해 수행되는 프로그램의 흐름을 메인루틴이라고 한다면, main 함수 안에서 실행되는 개별 함수들에 의해 수행되는 흐름을 서브루틴이라 비유할 수 있겠습니다.\n루틴의 한 종류인 함수는 호출을 함으로써 그 내부에 진입하여 내부에서 처리를 수행하고, 처리가 끝나면 함수도 종료되는 구조를 가지고 있기 때문에 보통은 루틴이 일직선적인 흐름을 가지고 있다고 할 수 있습니다.\n그런데 코루틴의 특징은 이 일직선적인 흐름을 중간에 지연시켰다가(suspend) 다시 재시작하는(resume) 것이 가능합니다. 따라서 코루틴을 사용하면 루틴이 실행 되었더라도 더 바쁜 다른 루틴이 실행되는동안 잠시 멈췄다가, 바쁜게 끝나면 재시작하여 나머지 작업을 끝내는 형태의 비동기 프로그래밍이 가능하게 됩니다.\n또 코루틴은 자기 스스로가 메인루틴이 되면서도 서브루틴이 될 수 있다는 특징도 있습니다.\n코루틴과 스레드 구글에서는 AsyncTask를 코루틴으로 대체하여 쓰라고 하고 있기 때문에 얼핏 생각하면 코루틴은 AsyncTask의 약점인 메모리누수가 없는 스레드라고 생각하기 쉽습니다. 그러나 코루틴은 스레드가 아닙니다.\n메모리 구조의 차이 ProgressDialog로 Thread와 Handler 이해하기 강의에서 다루었던 것처럼 프로세스속에서 실행되는 독립된 여러 흐름중의 하나를 스레드라고 합니다. 프로세스는 자기가 사용할 메모리영역(Heap)을 할당받는데, 이때 스레드는 Heap 안에서 다시 자신만이 사용할 수 있는 고유의 메모리영역(Stack)을 할당받게 됩니다.\n그런데 앞에서 설명했듯이 코루틴은 스택을 할당받지 않고 프로세스의 Heap 메모리를 공유하여 사용하기 때문에 비동기 작업을 구현한다는 점에서는 스레드와 동일한 일을 하고 있지만, 스레드보다는 함수에 가까운 구조를 가지고 있습니다.\n수행방식의 차이 코루틴은 비선점형 멀티태스킹(Non-preemptive Multitasking)이고 스레드는 선점형 멀티태스킹(Preemptive Multitasking)입니다. 스레드는 실제로 멀티코어를 사용함으로써 동시에 복수의 스레드를 처리할 수 있는데요 이것을 병행성이 있다고 합니다. 그런데 코루틴은 CPU를 시간분할하여 사용하기 때문에 실제로는 복수의 작업을 동시에 처리할 수 없어 병행성은 없습니다. 하지만 코루틴은 한번에 한개밖에 실행되지 않음에도 불구하고 전환속도가 빠르기 때문에 외부에서 볼 때는 마치 동시에 처리되는 것처럼 인식되므로 동시성이 있다고 합니다.\n코루틴의 장점 예를들어 세개의 스레드를 사용해야 하는 작업을 코루틴 세개로 만들어 사용할 경우 스택을 따로 할당할 필요가 없으니 사용되는 메모리가 줄어들게 됩니다. 그리고 스레드끼리 처리순서를 조정할 때 메모리를 공유하지 않기 때문에 수행해야 했던 context switching을 하지 않게 되므로 작업전환시의 오버헤드도 줄어들게 됩니다. 한 개의 스레드 안에서 여러개의 코루틴이 돌아가도록 할 수 있으니 스레드를 불필요하게 많이 만들어야 할 필요도 없어지게 됩니다.\n코틀린에서의 사용 코틀린의 코루틴 안에서 실행되는 함수에는 suspend 키워드를 붙여서 실행을 보류하거나 재개할수 있다는 표시를 하게 됩니다.\n공식 가이드에 따르면 suspend 키워드로 마킹된 함수는 Continuation Passing Style로 변환되고, Coroutine Builder를 통해 적절한 스레드 상에서 시나리오에 따라 동작하도록 구성되게 됩니다.\n코루틴 구조 코틀린의 코루틴은 크게 Coroutine Scope, Coroutine Context, Coroutine Builder의 세 부분으로 나눌 수 있습니다.\nCoroutine Scope 코루틴의 동작하는 범위를 규정합니다. 스코프 내에서 실행되는 코루틴의 실행을 감시하거나 취소할 수 있습니다.\nCoroutineScope 다음과 같은 인터페이스로 정의되며 특정한 dispatcher를 지정하여 동작이 실행될 스코프를 제한할 수 있습니다.\n1 2 3 public interface CoroutineScope { public val coroutineContext: CoroutineContext } GlobalScope GlobalScope는 CoroutineScope의 한 종류입니다. 안드로이드에서 어플리케이션 라이프사이클을 따르며, 싱글톤으로 최상위 레벨에서 코루틴을 시작하기 때문에 필요할때 만들어 쓰고 버린다는 사용법이 불가능합니다. 일반적으로는 사용 자체를 추천하지 않습니다.\nCoroutine Context 코루틴은 항상 Coroutine Context로 구성된 콘텍스트 안에서 실행되는데, 이 콘텍스트는 Dispatchers와 Job으로 구성됩니다.\nDispatchers Dispatchers는 코루틴이 실행될 스레드를 지정하는 역할을 합니다. 네가지 타입이 있는데 특징을 간단하게 정리해보면 .Default는 주로 CPU에서 많은 연산이 필요한 처리, .IO는 파일IO나 네트워크 콜을 수행해야 할 때, 그리고 코루틴에서 처리된 값을 UI에 반영할 때는 .Main을 사용한다고 생각하면 될 것 같습니다. .Unconfined는 일반적인 용도에서는 사용하지 않기 때문에 무시하셔도 됩니다.\nDispatchers.Default\nCPU자원을 많이 필요로하는 작업에 사용. 공유 백그라운드 스레드의 common pool에서 동작. 동시작업 가능한 최대 개수는 CPU코어수와 같으며 최소 2개임. Dispatchers.IO\n파일 혹은 소켓IO등의 가볍고 빈번한 IO작업에 사용. Blocking IO용 공유 스레드풀에서 동작. 필요에 따라 스레드를 추가 생성하거나 없앨 수 있는데 64 or 코어 수 중 큰 수만큼 생성가능함. Dispatchers.Default와 스레드를 공유하므로 withContext에서 Dispatcher변경시 context switching하지 않고 동일한 스레드에서 실행됨. Dispatchers.Main\nMainCoroutineDispatcher 클래스의 인스턴스이다 안드로이드에서는 UI 오브젝트를 다루는 메인스레드에서 동작 일반적으로 싱글스레드가 된다 Dispatchers.Unconfined\n첫번째 지연점까지만 실행된다. 메인스레드에서 동작한다. 일반적인 용도로는 사용하지 않는다. Job \u0026amp; Deferred 코틀린에서는 코루틴 작업을 Job 혹은 Deferred라는 오브젝트로 만들어 다룹니다. Deferred는 결과값을 가지는 Job이므로 실제로는 둘 다 Job이라고 볼 수 있습니다.\n코루틴이라는 것은 프로그램의 흐름이라고 하는 추상적인 개념인데요, 코루틴 한 덩어리를 한 개의 Job이라는 오브젝트로 만들게 되면 그 오브젝트에 대해 취소나 예외처리를 함으로써 용이하게 코루틴의 흐름제어를 할 수 있게 됩니다.\n1 2 3 val job = scope.launch { // New coroutine } 코루틴은 일시정지될수 있는 작업의 흐름이기 때문에 Job은 코루틴의 여러가지 상태를 반영할 수 있도록 다음과 같이 설계되었습니다.\nState isActive isCompleted isCancelled New (optional initial state) false false false Active (default initial state) true false false Completing (transient state) true false false Cancelling (transient state) false false true Cancelled (final state) false true true Completed (final state) false true false 그리고 각 상태는 다음과 같이 전환되죠.\n1 2 3 4 5 6 7 8 9 10 11 12 Job states cycle wait children +-----+ start +--------+ complete +-------------+ finish +-----------+ | New | -----\u0026gt; | Active | ---------\u0026gt; | Completing | -------\u0026gt; | Completed | +-----+ +--------+ +-------------+ +-----------+ | cancel / fail | | +----------------+ | | V V +------------+ finish +-----------+ | Cancelling | --------------------------------\u0026gt; | Cancelled | +------------+ +-----------+ Job 객체에 대해서는 cancel, join, start 등의 메소드가 정의되어 있습니다. cancel과 start는 위의 다이어그램에서 표시되는 cancel과 start 동작을 구현하는 메소드입니다. join은 코루틴을 병렬처리하지 않고 현재 job에 정의된 작업을 수행하는동안 기다리도록 하는 메소드입니다.\nCoroutine Builder 코루틴을 시작하는 방법에는 4가지가 있습니다.\nlaunch : 메인 스레드를 블록하지 않는 코루틴 작업을 실행합니다. 결과를 반환할 필요가 없는 작업에 사용하며 Job 객체를 반환합니다. async : 메인 스레드를 블록하지 않는 코루틴 작업을 실행합니다. 결과를 반환할 필요가 있는 작업에 사용하며 Deferred 객체를 반환합니다. runBlocking : 메인 스레드를 블록하고 작업을 실행합니다. runBlocking은 테스트 용도등에나 사용하지, 코루틴을 위해서는 사용하지 말라고 권장하고 있습니다. withContext : 예를들어 Dispatchers.Main으로 지정된 스코프 안에서 Dispatchers.IO가 필요한 처리를 해야할 일이 있을 수 있습니다. 이 때 Dispatchers 안에 다시 Dispatchers를 정의할 수도 있지만 withContext를 사용하면 Dispatchers를 간편하게 스위치할 수 있습니다. withContext를 이용한 스코프 전환은 OS에서 관리되므로 오버헤드가 적다고 알려져 있습니다. 1 2 3 4 5 6 7 8 9 10 suspend fun fetchDocs() { // Dispatchers.Main val result = get(\u0026#34;developer.android.com\u0026#34;) // Dispatchers.Main show(result) // Dispatchers.Main } suspend fun get(url: String) = // Dispatchers.Main withContext(Dispatchers.IO) { // Dispatchers.IO (main-safety block) /* perform network IO here */ // Dispatchers.IO (main-safety block) } // Dispatchers.Main } 코루틴 지연 delay : milisecond단위로 루틴을 잠시 대기시킵니다. Thread.sleep은 스레드 자체를 정지시키는데 반해, delay는 코루틴이 멈추지 않고 대기상태에 들어간다는 점이 다릅니다. join : Job의 실행이 끝날때까지 대기시킵니다. await : Deferred의 실행이 끝날때까지 대기시키고 결과값을 반환합니다. 코루틴 취소 코루틴 실행을 취소하는데에는 몇가지 방법이 있습니다.\ncancel : 위에서 설명한대로 job을 Cancelling (transient state)로 변화시킵니다. cancelAndJoin : job을 캔슬하고 Cancelled (final state)가 될 때까지 기다립니다. withTimeout : 제한시간을 설정하고 그때까지 처리가 끝나지 않았을 경우 블럭을 취소하고 TimeoutCancellationException을 throw합니다. withTimeoutOrNull : withTimeout을 처리중 제한시간이 경과되었을 경우 예외 대신 null을 반환합니다. 예외 처리 코루틴의 예외는 다음과 같이 정리할 수 있습니다.\nCoroutineExceptionHandler를 이용하여 코루틴 내부의 기본 catch block으로 사용할 수 있다. launch, actor : exception발생 시 바로 예외가 발생. async, produce : 중간에 exception이 발생해도 await를 만나야 비로소 exception이 발생. Job.cancel()을 제외한 다른 exception이 발생하면 부모의 코루틴까지 모두 취소시킨다. 이는 structured concurrency를 유지하기 위함으로 CoroutineExceptionHandler를 설정해도 막을 수 없다. 자식 코루틴에서 exception이 발생하면 다른 자식 코루틴 및 부모코루틴이 다 취소되버리기 때문에, 문제가 생긴 코루틴만 exception 처리할 수 있도록 하기 위해 CoroutineExceptionHandler를 설정한다. 단, CancellationException는 handler에서 무시된다. 여러개의 exception이 발생하면 가장 먼저 발생한 exception이 handler로 전달되며 나머지는 무시된다. 코루틴 사용 심플하게 정리하면 스코프는 CoroutineScope를 사용합니다. CPU 작업이냐 IO 작업이냐를 판단하여 Dispatchers를 정의하고 마지막으로 코루틴 처리후 값이 나와야 되는가 아닌가에 따라 launch나 async를 구별해서 사용하면 되겠습니다.\n이렇게 해서 코틀린의 코루틴에 대해 알아보았습니다.\n","date":"2021-06-28T22:01:50+09:00","permalink":"https://cliearl.github.io/posts/android/coroutine-principle/","title":"알기쉬운 코루틴 이론"},{"content":"이번 포스팅에서는 로또번호를 생성하는 간단한 앱을 만들어보도록 하겠습니다.\n사양 정의 버튼을 누르면 1~45 사이에서 랜덤하게 6개의 번호를 추출하고 번호에 대응하는 이미지를 화면에 표시하도록 합니다. 재미를 위해서 전체 번호의 합과, 홀짝 비율이 어떻게 되는지도 같이 화면에 표시해 주도록 하겠습니다.\n화면 디자인 drawable 폴더에는 번호순서대로 숫자와 색깔을 반영시킨 로또 공 이미지를 저장합니다. 화면에 ImageView 그룹을 추가하여 로또 공 이미지를 표시하고, TextView에는 번호합과 홀짝비율을 표시하도록 하겠습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/textView\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginBottom=\u0026#34;50dp\u0026#34; android:text=\u0026#34;로또번호 생성기\u0026#34; android:textAppearance=\u0026#34;@style/TextAppearance.AppCompat.Large\u0026#34; app:layout_constraintBottom_toTopOf=\u0026#34;@+id/linearLayout\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;LinearLayout android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/linearLayout\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; \u0026gt; \u0026lt;LinearLayout android:orientation=\u0026#34;horizontal\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;50dp\u0026#34; android:layout_height=\u0026#34;50dp\u0026#34; app:srcCompat=\u0026#34;@drawable/ball_00\u0026#34; android:id=\u0026#34;@+id/iv_game0\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;50dp\u0026#34; android:layout_height=\u0026#34;50dp\u0026#34; app:srcCompat=\u0026#34;@drawable/ball_00\u0026#34; android:id=\u0026#34;@+id/iv_game1\u0026#34; android:layout_weight=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;50dp\u0026#34; android:layout_height=\u0026#34;50dp\u0026#34; app:srcCompat=\u0026#34;@drawable/ball_00\u0026#34; android:id=\u0026#34;@+id/iv_game2\u0026#34; android:layout_weight=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;50dp\u0026#34; android:layout_height=\u0026#34;50dp\u0026#34; app:srcCompat=\u0026#34;@drawable/ball_00\u0026#34; android:id=\u0026#34;@+id/iv_game3\u0026#34; android:layout_weight=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;50dp\u0026#34; android:layout_height=\u0026#34;50dp\u0026#34; app:srcCompat=\u0026#34;@drawable/ball_00\u0026#34; android:id=\u0026#34;@+id/iv_game4\u0026#34; android:layout_weight=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;50dp\u0026#34; android:layout_height=\u0026#34;50dp\u0026#34; app:srcCompat=\u0026#34;@drawable/ball_00\u0026#34; android:id=\u0026#34;@+id/iv_game5\u0026#34; android:layout_weight=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;20dp\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;분석결과\u0026#34; android:id=\u0026#34;@+id/tv_analyze\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/generateButton\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;50dp\u0026#34; android:text=\u0026#34;로또번호 생성\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toBottomOf=\u0026#34;@+id/linearLayout\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; 로또번호 작성 파트 로또번호를 만들어내는 방법은 여러가지가 있을 수 있는데, 여기서는 1에서 45까지의 정수배열을 만들고 그걸 랜덤하게 섞은 뒤 앞에서 6개 번호만 잘라내는 방법을 사용하도록 하겠습니다.\n우선 IntArray를 써서 정수배열을 만듭니다. 이 배열을 섞기 위해서 shuffle 메소드를 사용하는데 이 때 Random 클래스의 인스턴스를 seed로 사용함으로써 섞을때마다 랜덤성이 달라지게 할 수 있습니다. 이 때 시간을 Ramdom의 소스로 사용하면 매 순간마다 변화하는 시드를 사용할 수 있습니다. 여기서는 SimpleDateFormat으로 밀리초까지 반영한 시간을 랜덤소스로 사용하도록 했습니다.\n배열을 섞었으면 slice로 앞에서 숫자 6개만을 잘라낸 뒤 sort로 정렬을 시키면 준비 완료입니다. 그리고 홀짝의 갯수를 센 뒤, 전체 숫자의 합도 sum을 이용하여 배열에 추가하여 줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 private fun createLottoNumbers(): ArrayList\u0026lt;Int\u0026gt; { val result = arrayListOf\u0026lt;Int\u0026gt;() val source = IntArray(45){it + 1} val seed = SimpleDateFormat(\u0026#34;yyyy-MM-dd\u0026#39;T\u0026#39;HH:mm:ss.SSSZ\u0026#34;, Locale.KOREA).format(Date()).hashCode().toLong() Log.d(\u0026#34;TAG\u0026#34;, seed.toString()) val random = Random(seed) source.shuffle(random) source.slice(0..5).forEach { num -\u0026gt; result.add(num) } result.sort() var evenNumberCount = 0 var oddNumberCount = 0 for (num in result) { if (num % 2 == 0) { evenNumberCount += 1 } else { oddNumberCount += 1 } } result.add(result.sum()) result.add(oddNumberCount) result.add(evenNumberCount) return result } 번호의 화면표시 파트 여기서는 위에서 만들어진 로또번호 배열을 전달받아 화면에 공 이미지를 표시합니다. 우선 getDrawableID에서 각 번호에 대응하는 공 이미지를 getIdentifier로 확인한 뒤 updateLottoBallImage로 전달합니다.\nupdateLottoBallImage에서는 전달받은 ID를 이미지뷰에 표시하고 나머지 텍스트 정보는 텍스트뷰에 표시하면 완료입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 private fun getDrawableID(number: Int): Int { val number = String.format(\u0026#34;%02d\u0026#34;, number) val string = \u0026#34;ball_$number\u0026#34; val id = resources.getIdentifier(string, \u0026#34;drawable\u0026#34;, packageName) return id } private fun updateLottoBallImage(result: ArrayList\u0026lt;Int\u0026gt;) { with(binding) { ivGame0.setImageResource(getDrawableID(result[0])) ivGame1.setImageResource(getDrawableID(result[1])) ivGame2.setImageResource(getDrawableID(result[2])) ivGame3.setImageResource(getDrawableID(result[3])) ivGame4.setImageResource(getDrawableID(result[4])) ivGame5.setImageResource(getDrawableID(result[5])) tvAnalyze.text = \u0026#34;번호합: ${result[6]} 홀:짝=${result[7]}:${result[8]}\u0026#34; } } 이렇게 해서 간단한 로또번호 생성기를 만드는 법에 대해 알아보았습니다.\n","date":"2021-06-20T21:10:32+09:00","permalink":"https://cliearl.github.io/posts/android/lotto-generator/","title":"로또번호 생성기 만들기"},{"content":"이번 포스팅에서는 단말의 인터넷 연결상태를 체크하는 법에 대해 알아보도록 하겠습니다.\n앱을 만들다보면 WIFI를 사용할 수 있는 환경에서 대용량 데이터를 다운로드하도록 하는 등의 처리를 위해 단말의 인터넷 연결상태를 체크해야 할 일이 있습니다. 이때 ConnectivityManager를 사용하면 단말이 어떤 접속환경을 통해 인터넷에 연결되어 있는지 확인할 수 있습니다.\n권한추가 인터넷에 접근하고 네트워크 상태를 가져오기 위해 AndroidManifest.xml에 다음 권한을 추가합니다.\n1 2 \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_NETWORK_STATE\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34; /\u0026gt; 네트워크 타입 확인 우선은 단말이 연결된 네트워크가 와아파이인지 셀룰러인지 확인하는 코드를 써 보겠습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private fun getNetworkType(context: Context): String { val connMgr = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.M) { val nw = connMgr.activeNetwork ?: return \u0026#34;NO_CONNECTION\u0026#34; val actNw = connMgr.getNetworkCapabilities(nw) ?: return \u0026#34;NO_CONNECTION\u0026#34; return when { actNw.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) -\u0026gt; \u0026#34;WIFI_STATE\u0026#34; actNw.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) -\u0026gt; \u0026#34;CELLULAR_STATE\u0026#34; actNw.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET) -\u0026gt; \u0026#34;ETHERNET_STATE\u0026#34; else -\u0026gt; \u0026#34;NO_CONNECTION\u0026#34; } } else { val nwInfo = connMgr.activeNetworkInfo ?: return \u0026#34;NO_CONNECTION\u0026#34; return nwInfo.typeName } } 기본은 ConnectivityManager 인스턴스를 만들고 그 인스턴스로부터 네트워크 타입을 가져오는 방식입니다. API Level 23 마시멜로우까지는 connMgr.activeNetworkInfo를 통해 NetworkInfo 인스턴스를 만든 뒤 typeName 프로퍼티로 네트워크 타입을 문자열 형태로 확인할 수 있었습니다.\n그러나 마시멜로우 이상에서는 ConnectivityManager의 activeNetwork 프로퍼티로 Network 인스턴스를 받아옵니다. 이 인스턴스를 getNetworkCapabilities로 전달하여 NetworkCapabilities의 인스턴스를 얻은 뒤 hasTransport를 실행하여 네트워크 타입을 가져오게 됩니다. 이 시점에서 접속이 확인되지 않을 경우 네트워크에 접속되지 않은 것입니다.\n네트워크 접속여부 확인 NetworkInfo 인스턴스의 isConnected 메소드를 사용하면 현재 인터넷에 접속되어있는지를 확인할 수 있습니다. 그런데 이 메소드로는 버스나 공항에서 접속할 수 있는 인증이 필요한 와이파이에 대해서는 인증이 되지 않아서 실제로는 와이파이를 사용할 수 없어도 true를 반환하게 됩니다.\n따라서 실제로 임의의 주소에 핑을 날려보는게 더 확실합니다. 구글에서는 이렇게 네트워크 접속을 확인할 때 쓰라고 Network Portal Detection 서비스를 제공하고 있는데요, 그 주소는 다음과 같습니다. http://clients3.google.com/generate_204\n이 주소로 접속에 성공하면 HTTP 204 No Content 를 반환합니다. 204 응답이 돌아오면 단말이 인터넷을 사용할 수 있는 상태라는 거지요.\n우선은 http://clients3.google.com/generate_204 에 접속하여 response code를 받아오는 함수를 작성합니다. 네트워크에 접속해야 하므로 비동기로 처리하기 위해 Thread 를 상속받도록 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private class CheckConnection(private val host: String) : Thread() { var isSuccess = false override fun run() { var urlConnection: HttpURLConnection? = null try { urlConnection = URL(host).openConnection() as HttpURLConnection urlConnection.setRequestProperty(\u0026#34;User-Agent\u0026#34;, System.getProperty(\u0026#34;http.agent\u0026#34;)) urlConnection.connectTimeout = 1000 urlConnection.connect() val responseCode = urlConnection.responseCode if (responseCode == 204) { isSuccess = true } } catch (e: Exception) { e.printStackTrace() } urlConnection?.disconnect() } } 다음은 CheckConnection을 실행시켜주면 되겠죠. 스레드를 시작하고 204 응답이 돌아왔다면 true를 반환하는 함수를 만들어줍니다. 메인스레드에서 작업이 끝날때까지 대기하도록 하기 위해 join을 추가로 실행시켜 줍니다.\n1 2 3 4 5 6 7 8 9 10 11 private fun isOnline(): Boolean { val cc = CheckConnection(\u0026#34;http://clients3.google.com/generate_204\u0026#34;) cc.start() try { cc.join() return cc.isSuccess } catch (e: Exception) { e.printStackTrace() } return false } 이렇게 해서 단말의 네트워크 상태를 체크하는 법에 대해 알아보았습니다.\n","date":"2021-06-13T21:51:49+09:00","permalink":"https://cliearl.github.io/posts/android/check-connection/","title":"단말의 인터넷 연결상태 체크하기"},{"content":"전자책을 관리해야 할 필요성이 생겨서 셀프호스팅 가능한 오픈소스 앱을 알아봤다.\n전자책 프로젝트 중 현재 활발하게 업데이트 되는 프로젝트는 다음 세개 정도 되는것 같았다.\nCalibre Ubooquity Komga 그런데 이 중 Ubooquity와 Komga는 일반서적보다는 만화책 관리가 더 메인인 것 같아서 Calibre를 선택했다.\n캘리버를 도커에 띄우기 위한 이미지가 여러가지 있는데 linuxserver.io에서 관리하는 훌륭한 linuxserver/calibre-web 이미지가 있어서 그걸 사용하기로 했다.\n캘리버-웹 설치시 문제가 하나 있는데 설치 직후 DB 로케이션 입력이 안된다는 점이다. 캘리버가 실행될려면 DB 폴더 아래에 metadata.db 파일이 있어야 되는데 파일이 없을경우 자동으로 생성되지 않게 되어 있다. 아마도 오프라인 캘리버 앱을 연동해서 쓰는 사람들을 배려해서 DB를 자동으로 초기화하지 않도록 한 것 같다.\n근데 어쨌든 처음 사용자는 metadata.db가 필요하다. 이 파일이 없으면 오프라인 앱에서 생성해서 복사하는 법이 있는데 이것보다는 설치할 때 자동으로 생성되게 하고 퍼미션도 줘버리는게 편하다.\n찾아보니 역시 깃헙에서 이슈가 열렸고 해결책도 있다.\n우선은 /books 디렉토리 아래에 /custom-cont-init.d 라는 디렉토리를 만든다. 이 안에 다음과 같은 내용의 metadata_generator.sh 파일을 생성한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #!/bin/bash FILE=/books/metadata.db PUID=1000 PGID=1000 if test -f \u0026#34;$FILE\u0026#34;; then echo \u0026#34;$FILE already exists, skipping generation.\u0026#34; else echo \u0026#34;$FILE does not exists, generating...\u0026#34; cd /app/calibre/bin calibredb restore_database --really-do-it --with-library /books echo \u0026#34;$FILE created, setting permissions...\u0026#34; chmod a+w $FILE # this is needed for uploads, you can remove it if you don\u0026#39;t want to allow uploads chown $PUID:$PGID /books echo \u0026#34;Permissions fixed, use /books as library path\u0026#34; fi profit! 부록으로 프로그래밍 관련 서적을 무료로 다운받을 수 있는 사이트를 하나 적어둔다 free-programming-books\n","date":"2021-06-11T20:55:40+09:00","permalink":"https://cliearl.github.io/posts/linux/introduce-calibre-web/","title":"전자책 관리 앱 Calibre-web 도입"},{"content":"안녕하세요 냉동코더입니다. 그간 개인사정으로 공개를 중지하고 있었던 iOS 게임제작강의를 다시 공개합니다.\n재공개되는 강의는 Swift로 iOS 2D 아케이드 게임 만들기. 그리고 Swift 5와 SpriteKit으로 만들어보는 아이폰 iOS 2D 슈팅게임입니다.\nSwift로 iOS 2D 아케이드 게임 만들기 강의는 플래피버드 게임을 만들어보는 강의인데요, 공개를 중지하던 중에도 계속 공개문의가 있던 강의라 다시 공개할 수 있게 되어 기쁜 마음입니다.\nSwift 5와 SpriteKit으로 만들어보는 아이폰 iOS 2D 슈팅게임은 무한히 반복되는 종스크롤 슈팅게임을 만드는 강의입니다.\n그리고 SpriteKit과 GameplayKit으로 만드는 인공지능 술래잡기 게임을 새롭게 공개합니다. 인프런 공개에 따라 기존 강의중 일부를 비공개로 전환하였습니다.\n모든 강의는 6월 6일까지 20퍼센트 할인하오니 많이 수강해 주시면 감사하겠습니다. 그럼 인프런에서 뵙겠습니다.\nSwift로 iOS 2D 아케이드 게임 만들기 https://www.inflearn.com/course/스위프트-ios-게임개발?inst=901ad6cd\nSwift 5와 SpriteKit으로 만들어보는 아이폰 iOS 2D 슈팅게임 https://www.inflearn.com/course/swift-spritekit-ios-슈팅게임?inst=86ebc18f\nSpriteKit과 GameplayKit으로 만드는 인공지능 술래잡기 게임 https://www.inflearn.com/course/인공지능-술래잡기-게임?inst=2a3a2d09\n","date":"2021-05-27T07:32:39+09:00","permalink":"https://cliearl.github.io/posts/etc/introduce-inflearn/","title":"인프런에서 iOS 게임만들기 강의공개를 시작하였습니다"},{"content":"이번 포스팅에서는 Assets 폴더를 사용하는 법에 대해 알아보겠습니다.\n안드로이드의 읽기전용 파일 저장폴더 앱을 만들다보면 읽기전용 파일을 앱에 저장하고 불러와서 사용해야 할 때가 있습니다. 이 때 파일은 다음 두 폴더에 저장할 수 있습니다.\nassets folder resources/raw folder 각 폴더의 특징은 다음과 같습니다.\n값 assets res/raw 파일명 자유롭게 설정 가능 a-z, 0-9, _ 만 사용가능 서브폴더 사용가능 사용불가 파일 리스팅 list()로 가능 불가능 컴파일타임 파일체크 없음 있음 XML에서 접근 불가능 가능 환경별 설정 분리 불가능 가능 간단히 정리하면 XML과 연계하여 다루어야 할 때는 res/raw 폴더를 사용하고, 그렇지 않을 경우 assets 폴더를 사용하면 될 것 같네요.\n앱 만들어보기 그럼 asset폴더를 사용해보기 위해 json 파일을 불러와서 Recyclerview에 표시하는 간단한 앱을 만들어 보겠습니다.\nRecyclerview는 RecyclerView에 View Binding 적용하기에서 작성했던 프로젝트를 참고해서 사용하겠습니다. Json 포맷을 다루어야 하므로 우선 Gson 라이브러리를 추가합니다. Gson에 대한 구체적인 설명에 대해서는 SharedPreferences를 json 포맷으로 관리하기에서 설명한 내용을 참조하시기 바랍니다.\n데이터 준비 New \u0026gt; Folder \u0026gt; Asset Folder를 선택하여 assets 폴더를 추가합니다.\n데이터는 경기데이터드림에서 제공하는 코로나바이러스 감염증 선별진료소 운영 의료기관 현황데이터를 사용하겠습니다.\nsheet 탭에서 json을 클릭하여 데이터를 다운받습니다. 다운받아보면 내용이 한줄에 모여있어 보기 불편합니다. 사용하는데는 관계 없지만 값들을 정렬하는게 보기에 좋을 것 같으니 Json Formatter 에서 파일을 정렬하고 data.json이라는 파일명을 붙여 assets 폴더에 저장합니다.\n데이터클래스 준비 데이터 파일에는 데이터기준일자, 시군명,\t의료기관명,\t의료기관 구분,\t의료기관 전화번호1,\t의료기관 전화번호2,\t소재지지번주소,\t소재지도로명주소,\tWGS84위도,\tWGS84경도 등 여러가지 탭이 있습니다.\n각 데이터는 배열 속의 데이터클래스로 관리하기 위해 데이터클래스를 만들어줍니다. 데이터클래스의 특징에 대해서는 Data class 이해하고 RecyclerView에서 사용하기강의에서 설명한 내용을 참고하시기 바랍니다.\n안드로이드 스튜디오에 Kotlin data class File from JSON 플러그인을 설치하면 json 파일을 손쉽게 데이터클래스로 변환할 수 있습니다. 플러그인을 설치한 뒤 New \u0026gt; Kotlin data class File from JSON을 선택하여 위에서 만든 json 데이터와 클래스명을 입력하면 자동으로 데이터클래스와, 그 클래스를 아이템으로 갖는 배열 클래스가 생성되는데 클래스 이름은 CoronaMed라고 하겠습니다.\nRecyclerview 구축하기 다음으로 새로 만들어진 데이터클래스의 형식에 맞게 Recyclerview와 ViewHolder의 형태를 정의해줍니다. activity_main.xml에 RecyclerView를 추가합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;androidx.recyclerview.widget.RecyclerView android:id=\u0026#34;@+id/recycler_view\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:scrollbars=\u0026#34;vertical\u0026#34; tools:listitem=\u0026#34;@layout/list_item\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; list_item.xml 파일을 만들어서 ViewHolder를 구성합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; \u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_name\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:paddingStart=\u0026#34;24dp\u0026#34; android:paddingEnd=\u0026#34;16dp\u0026#34; android:text=\u0026#34;Name\u0026#34; android:textSize=\u0026#34;20sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_type\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:paddingStart=\u0026#34;32dp\u0026#34; android:paddingEnd=\u0026#34;16dp\u0026#34; android:text=\u0026#34;type\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_phonenum\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:paddingStart=\u0026#34;32dp\u0026#34; android:paddingEnd=\u0026#34;16dp\u0026#34; android:text=\u0026#34;phonenum\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_address\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:paddingStart=\u0026#34;32dp\u0026#34; android:paddingEnd=\u0026#34;16dp\u0026#34; android:text=\u0026#34;address\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 그리고 마지막으로 Recyclerview 어댑터를 작성합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class MyRecyclerViewAdapter(private val dataset: CoronaMed) : RecyclerView.Adapter\u0026lt;MyRecyclerViewAdapter.MyViewHolder\u0026gt;() { override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MyViewHolder { val binding = ListItemBinding.inflate(LayoutInflater.from(parent.context), parent, false) return MyViewHolder(binding) } override fun onBindViewHolder(holder: MyViewHolder, position: Int) { holder.bind(dataset[position]) } override fun getItemCount(): Int { return dataset.size } class MyViewHolder(private val binding: ListItemBinding) : RecyclerView.ViewHolder(binding.root) { fun bind(data: CoronaMedItem) { with(binding) { tvName.text = data.mEDINSTNM tvType.text = data.dISTRCTDIVDTLS tvPhonenum.text = data.eMGCCENTERTELNO tvAddress.text = data.rEFINEROADNMADDR } } } } assets 폴더속 파일 불러오기 다음은 메인액티비티에서 assets 폴더속 파일을 불러오기 위한 함수를 만들어줍니다. assets 폴더에 접근하기 위해 Asset Manager 인스턴스를 생성하고 open 메소드로 파일을 오픈합니다.그리고 bufferedReader를 이용해 InputStream을 텍스트로 변환합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 private fun getJsonData(filename: String): CoronaMed? { val assetManager = resources.assets var result: CoronaMed? = null try { val inputStream = assetManager.open(filename) val reader = inputStream.bufferedReader() val gson = Gson() result = gson.fromJson(reader, CoronaMed::class.java) } catch (e:IOException) { e.printStackTrace() } return result } 나머지는 이렇게 얻어온 CoronaMed 객체를 Recyclerview 어댑터에 전달해주면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(binding.root) val testdata = getJsonData(\u0026#34;data.json\u0026#34;) binding.recyclerView.apply { layoutManager = LinearLayoutManager(context, LinearLayoutManager.VERTICAL, false) adapter = MyRecyclerViewAdapter(testdata!!) addItemDecoration(DividerItemDecoration(context, DividerItemDecoration.VERTICAL)) } } 이렇게 해서 assets 폴더에서 json 파일을 불러오는 법에 대해 알아보았습니다.\n","date":"2021-05-05T23:05:14+09:00","permalink":"https://cliearl.github.io/posts/android/assets-json-recycler/","title":"Assets 폴더에서 로딩한 json 파일 Recyclerview에 표시하기"},{"content":"이번 포스팅에서는 ViewPager2와 TabLayout을 이용해 스와이프 되는 화면을 구현해 보도록 하겠습니다.\nViewPager2를 사용하는 이유나 장점에 대해서는 ViewPager1 프로젝트를 ViewPager2 프로젝트로 변환하기 포스팅에서 다루었으니 그 내용을 참조해 주시기 바랍니다.\n플러그인 추가 우선은 뷰바인딩 사용설정 및 ViewPager2 플러그인을 추가합니다.\n1 2 3 4 5 6 7 8 9 // 뷰바인딩 사용준비 android { buildFeatures.viewBinding true } // ViewPager2 라이브러리 추가 dependencies { implementation \u0026#39;androidx.viewpager2:viewpager2:1.0.0\u0026#39; } Fragment의 레이아웃 작성 다음은 new -\u0026gt; fragment 를 선택하여 테스트용으로 사용할 프래그먼트를 만들어줍니다. 텍스트를 화면 중간에 표시하기 위해 코드를 약간 변경합니다.\n1 2 3 4 5 6 7 \u0026lt;TextView android:id=\u0026#34;@+id/textview\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;@string/hello_blank_fragment\u0026#34; android:textAppearance=\u0026#34;@style/TextAppearance.AppCompat.Large\u0026#34; /\u0026gt; Fragment 클래스 작성 기본 프래그먼트에 뷰 바인딩을 적용하고 텍스트를 표시하도록 변경합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class BlankFragment : Fragment() { private var _binding: FragmentBlankBinding? = null private val binding get() = _binding!! override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?, ): View? { // Inflate the layout for this fragment _binding = FragmentBlankBinding.inflate(inflater, container, false) return binding.root } override fun onDestroyView() { super.onDestroyView() _binding = null } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { binding.textview.text = param1 } } ViewPager2의 PagerAdapter 작성 방금 작성한 프래그먼트에 텍스트를 전해주는 ViewPager2 어댑터를 작성합니다. 여기서는 3개의 페이지를 갖도록 하겠습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 class MyPagerAdapter(fa: FragmentActivity): FragmentStateAdapter(fa) { private val NUM_PAGES = 3 override fun getItemCount(): Int = NUM_PAGES override fun createFragment(position: Int): Fragment { return when (position) { 0 -\u0026gt; { BlankFragment.newInstance(\u0026#34;Page 1\u0026#34;,\u0026#34;\u0026#34;)} 1 -\u0026gt; { BlankFragment.newInstance(\u0026#34;Page 2\u0026#34;,\u0026#34;\u0026#34;)} else -\u0026gt; { BlankFragment.newInstance(\u0026#34;Page 3\u0026#34;,\u0026#34;\u0026#34;)} } } } activity_main.xml 메인 액티비티의 화면을 구성합니다. 화면 위쪽에 ViewPager를 배치하고 나머지 공간에 AppBarLayout을 배치한 뒤 그 내부에 TabLayout을 배치합니다. 그리고 TabLayout의 app::tab~ 속성을 사용해서 색을 지정합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;androidx.viewpager2.widget.ViewPager2 android:id=\u0026#34;@+id/viewpager\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; app:layout_constraintBottom_toTopOf=\u0026#34;@+id/appBarLayout\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;com.google.android.material.appbar.AppBarLayout android:id=\u0026#34;@+id/appBarLayout\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:theme=\u0026#34;@style/Theme.AppCompat.Light.DarkActionBar\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;com.google.android.material.tabs.TabLayout android:id=\u0026#34;@+id/tabs\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34; android:background=\u0026#34;@color/white\u0026#34; app:tabIndicatorColor=\u0026#34;@color/design_default_color_primary\u0026#34; app:tabRippleColor=\u0026#34;@color/design_default_color_primary\u0026#34; app:tabSelectedTextColor=\u0026#34;@color/design_default_color_primary\u0026#34; app:tabTextColor=\u0026#34;@color/black\u0026#34; /\u0026gt; \u0026lt;/com.google.android.material.appbar.AppBarLayout\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; Mainactivity 설정 ViewPager 어댑터 클래스의 인스턴스를 만들어 ViewPager 어댑터 속성에 연결시킵니다. 그리고 TabLayoutMediator를 이용해서 TabLayout과 ViewPager를 연결합니다. 각 탭의 타이틀과 아이콘은 블럭내부에서 지정할 수 있습니다. 탭의 이름은 Title 0 형식으로 지정하고 아이콘은 벡터 이미지를 추가한 뒤 setIcon 에서 불러오도록 하였습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class MainActivity : AppCompatActivity() { private lateinit var binding: ActivityMainBinding override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) binding = ActivityMainBinding.inflate(layoutInflater) setContentView(binding.root) binding.viewpager.apply { adapter = MyPagerAdapter(context as FragmentActivity) } TabLayoutMediator(binding.tabs, binding.viewpager) { tab, position -\u0026gt; tab.text = \u0026#34;Title $position\u0026#34; when (position) { 0 -\u0026gt; tab.setIcon(R.drawable.ic_baseline_format_list_bulleted_24) 1 -\u0026gt; tab.setIcon(R.drawable.ic_baseline_map_24) 2 -\u0026gt; tab.setIcon(R.drawable.ic_baseline_info_24) } }.attach() } } PageTransformer 설정 ViewPager에서는 페이지를 변경할때 여러가지 효과를 줄 수 있습니다. 구글에서 공개하는 ZoomOutPageTransformer를 사용한다면 스크롤할때 페이지가 축소되면서 페이드아웃되고, 페이지가 중앙에 가까워지면 원래 크기로 다시 커지면서 페이드인 되는 효과를 낼 수 있습니다.\n그 외에도 여러가지 페이지 전환효과를 사용하고 싶다면 33 Viewpager2 Transformers for Your Android ui’s 페이지를 참고하세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 private const val MIN_SCALE = 0.85f private const val MIN_ALPHA = 0.5f class ZoomOutPageTransformer : ViewPager2.PageTransformer { override fun transformPage(view: View, position: Float) { view.apply { val pageWidth = width val pageHeight = height when { position \u0026lt; -1 -\u0026gt; { // [-Infinity,-1) // This page is way off-screen to the left. alpha = 0f } position \u0026lt;= 1 -\u0026gt; { // [-1,1] // Modify the default slide transition to shrink the page as well val scaleFactor = max(MIN_SCALE, 1 - abs(position)) val vertMargin = pageHeight - (1 - scaleFactor) / 2 val horzMargin = pageWidth - (1 - scaleFactor) / 2 translationX = if (position \u0026lt; 0) { horzMargin - vertMargin / 2 } else { horzMargin + vertMargin / 2 } // Scale the page down (between MIN_SCALE and 1) scaleX = scaleFactor scaleY = scaleFactor // Fade the page relative to its size. alpha = (MIN_ALPHA + (((scaleFactor - MIN_SCALE) / (1 - MIN_SCALE)) - (1 - MIN_ALPHA))) } else -\u0026gt; { // (1,+Infinity] // This page is way off-screen to the right. alpha = 0f } } } } } // MainActivity binding.viewpager.apply { setPageTransformer(ZoomOutPageTransformer()) } 이렇게 해서 ViewPager2와 TabLayout을 조합한 디자인을 구축하는 법에 대해 알아보았습니다.\n","date":"2021-05-02T22:44:04+09:00","permalink":"https://cliearl.github.io/posts/android/viewpager2-tablayout/","title":"ViewPager2와 TabLayout을 이용해 스와이프 되는 화면 구현하기"},{"content":"이번 포스팅에서는 스플래시 스크린을 만드는 법에 대해 알아보도록 하겠습니다.\n아이콘을 선택하고 앱이 구동되서 메인화면을 보여주기 전까지 로딩 시간이 필요한데 그 시간동안 보여주는 화면을 스플래시 스크린이라고 합니다. 이때 앱 아이콘과 동일한 이미지로 스플래시 스크린을 설정하면 아이콘이 튀어 나오는듯한 효과를 볼 수 있습니다.\n코딩 타임 이번 앱은 앱 아이콘을 설정하는 강의에서 만들었던 프로젝트를 변경하여 만들어 보도록 하겠습니다.\n우선은 스플래시 스크린에 표시할 이미지를 선정해야 하는데, 저는 이전에 앱 아이콘으로 사용했던 이미지를 그대로 사용하도록 하겠습니다. 이미지는 PNGRepo에서 다운로드 하실 수 있습니다.\nTiCons 안드로이드에 이미지를 추가할 때는 해상도를 고려하여야 하는데요, 예를들어 아이콘으로 사용하는 그림파일 같은 경우 hdpi부터 xxxhdpi까지 다양한 해상도가 고려되어 있습니다. 스플래시 스크린도 이렇게 다양한 해상도별로 이미지를 준비하여야 할 필요가 있습니다.\n우리가 다운받은 이미지는 파일 하나기 때문에 이 파일을 해상도별로 준비를 해 주어야 합니다. 다만 이 작업을 직접 할 필요는 없고 이미지를 변환시켜주는 사이트를 이용하면 됩니다. 저는 TiCons라는 사이트를 이용합니다.\n이 사이트의 옵션을 보면 여러가지 세팅이 있는데 Splashes, Android를 선택합니다. DPI는 mdpi부터 xxxhdpi까지 설정해 줍니다. 그리고나서 이미지를 업로드하고 Generate로 변환하면 각 해상도별 이미지를 자동으로 작성해 줍니다.\nNinePatch 이때 Splashes 탭에 Nine이라는 옵션이 있습니다. 이 옵션은 안드로이드의 NinePatch 기능을 이용하도록 하는 것입니다.\n안드로이드에서 이미지 파일을 사용할 때 OS의 필요에 따라 이미지를 늘리거나 줄이는 작업을 할 때가 있습니다. 이 때 이미지 내부에 글씨가 늘어가는 경우 확대 축소시 비율에 안맞게 내용이 깨질 수 있습니다. 그런데 NinePatch를 사용하면 내부에 정보를 담고있는, 깨지지 않아야 하는 부분은 그대로 놔두고 나머지 부분만 늘리도록 할 수 있습니다. 이것을 NinePatch image라고 하며 NinePatch image는 그림파일을 만들 때 뒤에 9라는 숫자를 붙여주면 안드로이드가 이 이미지를 나인패치 이미지로 인식하게 됩니다.\n아무튼 여기서는 NinePatch 옵션을 활성화하도록 하였습니다.\n다운로드 받은 파일을 보면 해상도별로 그림파일이 준비된 것을 확인할 수 있으므로 이 파일들을 res폴더에 복사하면 drawable 폴더 안에 background.9 폴더가 생긴것을 알 수 있습니다.\n액티비티 작성 다음은 이미지를 표시해줄 액티비티를 하나 만들겁니다. 이 액티비티는 스플래시 스크린을 보여주기만 하고 바로 메인액티비티를 불러오는 역할만을 하게 됩니다.\n우선은 스플래시 스크린으로 사용할 splash_screen.xml 파일을 작성합니다. 아까 추가해준 background 이미지를 흰색 바탕화면에 그려주는 단순한 형태입니다.\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;layer-list xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;item android:drawable=\u0026#34;@android:color/white\u0026#34; /\u0026gt; \u0026lt;item\u0026gt; \u0026lt;bitmap android:src=\u0026#34;@drawable/background\u0026#34; android:gravity=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;/item\u0026gt; \u0026lt;/layer-list\u0026gt; 다음은 액티비티에서 사용할 테마를 추가합니다. res -\u0026gt; values -\u0026gt; themes.xml을 열어 다음과 같이 style을 추가합니다. 액션바가 표시되지 않아야 하기 때문에 NoActionBar 테마를 상속한 뒤 위에서 작성한 splash_screen을 표시하도록 합니다.\n1 2 3 \u0026lt;style name=\u0026#34;SplashScreen\u0026#34; parent=\u0026#34;Theme.AppCompat.NoActionBar\u0026#34;\u0026gt; \u0026lt;item name=\u0026#34;android:windowBackground\u0026#34;\u0026gt;@drawable/splash_screen\u0026lt;/item\u0026gt; \u0026lt;/style\u0026gt; 그리고 SplashActivity.kt를 만들어 줍니다. 이 액티비티는 시작되자마자 메인액티비티를 불러오는 역할만하고 종료됩니다.\n1 2 3 4 5 6 7 8 9 10 class SplashActivity: AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val intent = Intent(this, MainActivity::class.java) startActivity(intent) finish() } } 마지막으로 AndroidManifest.xml에서 시작점을 MainActivity가 아닌 SplashActivity가 되도록 변경합니다. 이 때 SplashActivity의 테마는 themes.xml에서 추가해 준 SplashScreen으로 지정합니다.\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;activity android:name=\u0026#34;.SplashActivity\u0026#34; android:theme=\u0026#34;@style/SplashScreen\u0026#34; \u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;activity android:name=\u0026#34;.MainActivity\u0026#34; /\u0026gt; 이렇게 해서 스플래시 스크린을 작성하는 법에 대해 알아보았습니다.\n","date":"2021-04-28T21:46:44+09:00","permalink":"https://cliearl.github.io/posts/android/splashscreen/","title":"스플래쉬 스크린 설정하기"},{"content":"이번 포스팅에서는 앱에 아이콘을 설정하는 방법에 대해 알아보도록 하겠습니다.\nLegacy Icon과 Adaptive Icon 안드로이드 앱에서는 현재 두 가지 종류의 아이콘을 사용할 수 있습니다. 하나는 Legacy Icon이고 또 하나는 Adaptive Icon입니다.\nAdaptive Icon은 다양화된 기기의 해상도와 UI 디자인에 대응하기 위해 제안된 규격으로, 안드로이드는 iOS와 달리 여러 제조사에서 여러 규격의 기기를 만들기 때문에 해상도에 많은 차이가 있고, 회사마다 고유의 UI 디자인을 사용하기 때문에 앱 아이콘의 형태도 조금씩 달라지게 됩니다.\n그래서 구글에서는 Adaptive Icon이라는 규격을 제안했습니다. Adaptive Icon은 백그라운드와 포그라운드 두 개의 레이어를 정의한 뒤 기기의 요청에 따라 아이콘을 조합하여 필요한 모양으로 표시를 해 줍니다.\n출처 : https://developer.android.com/guide/practices/ui_guidelines/icon_design_adaptive\n이 Adaptive Icon은 안드로이드 8 오레오 (API Level 26)부터 지원을 하기 때문에 그 전 버전에서는 Legacy Icon을 사용하여야 합니다.\n아이콘 디자인 사양 구글에서 제안하는 아이콘 디자인시의 가이드라인은 다음과 같습니다. 여기서 모양을 정사각형으로 하고 그림자를 넣지 말라고 하는 것은 Adaptive Icon을 사용하면 이 효과를 줄 수 있기 때문입니다.\n최종크기 : 512 px - 512 px 형식 : 32비트 PNG 색상공간 : sRGB 최대 파일 크기 : 1,024 KB 모양 : 정사각형 그림자 : 없음 아이콘 속 뱃지 : 없도록 함 xml 구조 확인 안드로이드 스튜디오에서 기본앱 프로젝트를 만들면 앱 아이콘을 지정하지 않았는데도 안드로이드 머리통 형태의 앱 아이콘이 부여되는 것을 확인할 수 있습니다. AndroidManifest.xml 을 보시면\n1 2 android:icon=\u0026#34;@mipmap/ic_launcher android:roundIcon=\u0026#34;@mipmap/ic_launcher_round 항목이 있는것을 알 수 있는데 앱 아이콘은 이 항목을 이용해 지정합니다.\nmipmap/ic_launcher 폴더는 res 폴더안에 위치하고 있는대요, Adaptive Icon은 이 안에 xml 형태로 저장되고, Legacy Icon은 png형태로 저장되어 있습니다.\n예를들어 ic_launcher.xml 의 내용은 다음과 같이 되어 있습니다.\n1 2 3 4 5 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;adaptive-icon xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;background android:drawable=\u0026#34;@drawable/ic_launcher_background\u0026#34; /\u0026gt; \u0026lt;foreground android:drawable=\u0026#34;@drawable/ic_launcher_foreground\u0026#34; /\u0026gt; \u0026lt;/adaptive-icon\u0026gt; 백그라운드와 포그라운드는 drawable 폴더 안의 파일을 지정하도록 되어 있는데 내용을 보면 백그라운드 xml은 녹색 배경이고, 포그라운드 xml은 안드로이드 머리통인 것을 확인할 수 있습니다.\n아이콘 설정 그럼 여기서는 이미지를 이용해서 아이콘을 설정해 보도록 하겠습니다. 이미지는 PNGRepo의 빨간색 안드로이드 아이콘을 사용할건데요, 이 아이콘은 512x512 크기를 가지고 있기 때문에 그대로 앱에 사용할 수 있습니다.\nres 폴더에서 New -\u0026gt; Image Asset을 선택하고 Source Asset의 Path에서 그림파일을 선택합니다. 안드로이드가 사각형 안에 들어가도록 Resize에서 대충 조절해 주는데 구글에서는 그림이 70% 크기가 되도록 권장하고 있습니다. 그리고 Color 메뉴를 사용해서 백그라운드는 흰색을 선택해줍니다.\nmipmap 아래에 아이콘이 추가되었으면 AndroidManifest.xml에서 사용할 아이콘을 정해주면 끝입니다.\n이렇게 해서 앱에 아이콘을 지정하는 법에 대해 알아보았습니다.\n","date":"2021-04-28T21:46:35+09:00","permalink":"https://cliearl.github.io/posts/android/appicon/","title":"App Icon 설정하기"},{"content":"이번 포스팅에서는 ProgressBar와 AsyncTask의 사용방법에 대해 알아보도록 하겠습니다.\n들어가기 ProgressBar는 안드로이드가 어떤 작업을 진행할때 그 작업의 진행상황을 보여주는 모듈입니다. 시간이 걸리는 처리가 필요할 때 표시해주면 기다리는 유저의 거부감을 줄일 수 있습니다. 이 기능은 기존에는 ProgressDialog를 이용해서 구현했는데 다이얼로그가 표시될 때 유저의 조작을 제한한다는 문제가 있어 API level 26에서 deprecated 되고 ProgressBar로 대체되었습니다.\n메인 스레드의 관점에서 보면 ProgressBar는 처리에 긴 시간이 걸리기 때문에 메인 스레드와는 별개의 스레드에서 처리를 수행해야 할 필요가 있습니다. 별개의 스레드에서 처리를 수행하는데는 여러가지 방법이 있을 수 있는데 여기서는 AsyncTask 클래스를 이용해서 ProgressBar를 구현해 보도록 하겠습니다.\nAsyncTask란 스레드와 핸들러에 대한 구체적인 설명과 사용법은 제가 했던 다른 강의를 참조하시면 좋을 것 같습니다.\nAsyncTask는 주로 짧은 시간동안 운용되는 스레드를 더 사용하기 편하도록 만든 헬퍼 클래스입니다. 실제 사용시에는 메모리 리크등 문제가 있었기에 Android 11(API level 30) 부터 deprecated 되었으나 그래도 아직은 현역이라 할 수 있습니다.\nAsyncTask 구조 AsyncTask를 상속받는 클래스는 다음과 같이 구성합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class MyAsyncTask : AsyncTask\u0026lt;String, Int, Boolean\u0026gt;() { override fun onPreExecute() { super.onPreExecute() } override fun doInBackground(vararg p0: String?): Boolean { return true } override fun onProgressUpdate(vararg values: Int?) { super.onProgressUpdate(*values) } override fun onPostExecute(result: Boolean?) { super.onPostExecute(result) } override fun onCancelled() { super.onCancelled() } } AsyncTask\u0026lt;A, B, C\u0026gt; 안에는 세가지 데이터 타입을 정의하게 됩니다. 내용은 순서대로 다음과 같고, 이 때 값은 가변인자 형태이므로 배열 형태의 값도 사용할 수 있습니다. 또한 데이터를 전달할 필요가 없을 경우 Void로 정의를 생략할 수 있습니다.\nA : doInBackground가 메인스레드 execute에서 전달받는 값 B : doInBackground가 실행중일 때 onProgressUpdate로 전달하는 값 C : doInBackground가 종료되었을 때 onPostExecute로 전달하는 값 AsyncTask의 동작 AsyncTask의 동작은 다음과 같이 이루어지게 됩니다.\n메인 스레드에서 AsyncTask의 인스턴스를 생성하고 execute 로 실행. AsyncTask 스레드가 시작되기 직전에 onPreExcuted가 실행됨. 스레드 실행전 필요한 컴포넌트들을 로딩하는데 사용. execute 호출시 입력된 파라미터가 AsyncTask 스레드로 전달됨. doInBackground에서 AsyncTask 작업을 수행. doInBackground에서 publishProgress를 호출하면 메인스레드에서 onProgressUpdate가 호출됨. doInBackground 처리가 끝나면 메인스레드의 onPostExcute로 결과값 result를 리턴하면서 AsyncTask 스레드가 종료됨. 코드 작성 화면 구성 진행상황을 표시하는 텍스트뷰와 ProgressBar를 추가하고, AsyncTask를 시작하는 다운로드 버튼과 취소버튼을 추가합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:paddingStart=\u0026#34;30dp\u0026#34; android:paddingEnd=\u0026#34;30dp\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; \u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/textView\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;20dp\u0026#34; android:text=\u0026#34;Progress : 0\u0026#34; android:textSize=\u0026#34;20sp\u0026#34; /\u0026gt; \u0026lt;ProgressBar android:id=\u0026#34;@+id/progressBar\u0026#34; style=\u0026#34;?android:attr/progressBarStyleHorizontal\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;20dp\u0026#34; android:scaleY=\u0026#34;1\u0026#34; android:progressBackgroundTint=\u0026#34;@color/design_default_color_primary_dark\u0026#34; android:progressTint=\u0026#34;@color/design_default_color_primary\u0026#34; android:indeterminate=\u0026#34;false\u0026#34; android:progress=\u0026#34;0\u0026#34; android:max=\u0026#34;100\u0026#34; /\u0026gt; \u0026lt;LinearLayout android:orientation=\u0026#34;horizontal\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; \u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/downloadButton\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;20dp\u0026#34; android:layout_marginEnd=\u0026#34;20dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:text=\u0026#34;다운로드\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/cancelButton\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:layout_marginTop=\u0026#34;20dp\u0026#34; android:text=\u0026#34;취소\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; DownloadTask 클래스 준비 AsyncTask를 상속받는 DownloadTask 클래스를 작성합니다. 이 때 doInBackground에서는 0.1초 마다 진행률을 max값에 대해 10퍼센트씩 증가시키고 이 값을 publishProgress로 메인스레드에 전달하여 onProgressUpdate로 UI를 변경할 수 있도록 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class DownloadTask(private val binding: ActivityMainBinding) : AsyncTask\u0026lt;String, Int, String\u0026gt;() { override fun doInBackground(vararg tasks: String): String { val count = tasks.size for (i in 0 until count) { try { Thread.sleep(100) } catch (e: InterruptedException) { e.printStackTrace() } publishProgress(((i + 1) / count.toFloat() - 100).toInt()) if (isCancelled) break } return \u0026#34;Download Completed\u0026#34; } override fun onProgressUpdate(vararg values: Int?) { } override fun onPostExecute(result: String?) { } } 액티비티 처리 작성한 DownloadTask를 메인액티비티에서 사용하기 위한 코드를 작성해 줍니다. 다운로드 버튼을 클릭하면 AsyncTask 인스턴스를 만들어 실행하는데 excute에서는 vararg 입력 확인을 위해 굳이 10개의 스트링으로 이루어진 값을 전달해 주었습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class MainActivity : AppCompatActivity() { lateinit var binding: ActivityMainBinding private var downloadTask: DownloadTask? = null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) binding = ActivityMainBinding.inflate(layoutInflater) setContentView(binding.root) binding.downloadButton.setOnClickListener { downloadTask = DownloadTask(this) downloadTask?.execute(\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;6\u0026#34;, \u0026#34;7\u0026#34;, \u0026#34;8\u0026#34;, \u0026#34;9\u0026#34;, \u0026#34;10\u0026#34;) } } } 작업 중 취소 처리 [doInBackground]에서 작업중인 스레드는 메인스레드에서 cancel을 호출하여 취소할 수 있습니다. 이 경우 백그라운드 스레드 내부의 isCancelled가 true를 반환하게 되며 doInBackground가 종료된 후, onPostExecute 대신 onCancelled가 호출됩니다.\n이때 스레드 실행중에 중단해도 상관없는 작업이라면 cancel 실행시 mayInterruptIfRunning 파라메터로 true를, 스레드를 끝까지 처리하고 종료해야 할 경우라면 false를 전달해줍니다.\n이제 메인액티비티에서 취소버튼을 클릭하면 AsyncTask 작업이 취소됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // MainActivity override fun onCreate(savedInstanceState: Bundle?) { binding.cancelButton.setOnClickListener { downloadTask?.cancel(false) } } override fun onPause() { super.onPause() downloadTask?.cancel(false) } // DownloadTask override fun onCancelled() { binding.textView.text = \u0026#34;Progress : 0\u0026#34; binding.progressBar.progress = 0 } 메모리 누수 방어하기 AsyncTask의 특징 자바에서는 객체간의 관계를 다음과 같이 구분하는데, 메모리 확보를 위해 가비지 컬렉터가 작동하면 강한참조는 무시되고 약한참조를 가진 객체만 삭제되게 됩니다.\nStrong reference Soft reference Weak reference Phantom reference 여기서 만들어진 AsyncTask 객체가 액티비티를 참조하면 강한 참조를 가지게 됩니다. 그러면 가비지 컬렉터(Garbage Collector, GC)가 인스턴스를 제거하지 않게 되어 메모리 누수가 발생하게 되죠.\n또한 AsyncTask는 하나의 객체만 생성할 수 있으며 액티비티가 종료되어도 스레드 작업이 끝나지 않았을 경우 종료되지 않는다는 특징이 있습니다.\n그런데 이런 특징때문에 액티비티가 종료되고 재시작되면 스레드 객체가 액티비티 참조를 잃어버리게 되서 액티비티에 영향을 줄 수 없는 스레드만 좀비처럼 살아남아버리는 문제가 발생하게 됩니다.\nWeakreference화 하기 이러한 문제를 방지하기 위해 WeakReference를 이용해서 AsyncTask클래스가 액티비티에 대해 약한참조를 가지도록 합니다. 그러면 액티비티가 종료되었을 때 가비지 컬렉터가 AsyncTask 인스턴스를 메모리에서 해제할 수 있게 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class DownloadTask(activity: MainActivity) : AsyncTask\u0026lt;String, Int, String\u0026gt;() { private val weakReference: WeakReference\u0026lt;MainActivity\u0026gt; = WeakReference(activity) override fun doInBackground(vararg tasks: String): String { val count = tasks.size for (i in 0 until count) { try { Thread.sleep(100) } catch (e: InterruptedException) { e.printStackTrace() } publishProgress(((i + 1) / count.toFloat() - 100).toInt()) if (isCancelled) break } return \u0026#34;Download Completed\u0026#34; } override fun onProgressUpdate(vararg values: Int?) { val activity = weakReference.get() if (activity == null || activity.isFinishing) return activity.binding.textView.text = \u0026#34;Progress : ${values[0]}\u0026#34; activity.binding.progressBar.progress = values[0]!! } override fun onPostExecute(result: String?) { val activity = weakReference.get() if (activity == null || activity.isFinishing) return Toast.makeText(activity, result, Toast.LENGTH_SHORT).show() } override fun onCancelled() { val activity = weakReference.get() if (activity == null || activity.isFinishing) return activity.binding.textView.text = \u0026#34;Progress : 0\u0026#34; activity.binding.progressBar.progress = 0 } } 이렇게 해서 AsyncTask를 사용하는 법에 대해 알아보았습니다.\n","date":"2021-04-25T15:35:18+09:00","permalink":"https://cliearl.github.io/posts/android/progressbar-asynctask/","title":"ProgressBar로 AsyncTask 이해하기"},{"content":"이번 포스팅에서는 보상형 광고를 표시하는 법에 대해 알아보도록 하겠습니다. 보상형 광고란 광고를 본 댓가로 어떤 아이템이나 보상을 주는 형태의 광고를 말합니다.\n우선은 애드몹 디펜던시를 추가합니다. 현재 애드몹 라이브러리의 최신버전은 19.7.0인데요, 19.6.0과 사용법이 많이 다르기 때문에 두 방법 모두 설명하도록 하겠습니다.\nGoogle Admob Version 19.6.0 이하에서의 구현 1 2 3 dependencies { implementation \u0026#39;com.google.android.gms:play-services-ads:19.6.0\u0026#39; } AndroidManifest.xml 안에 애드몹 사이트에서 부여받는 앱 ID를 입력합니다. 여기서는 구글에서 테스트용으로 제공하는 ID를 입력하였습니다.\n1 2 3 4 5 6 7 \u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34; /\u0026gt; \u0026lt;application \u0026lt;meta-data android:name=\u0026#34;com.google.android.gms.ads.APPLICATION_ID\u0026#34; android:value=\u0026#34;ca-app-pub-3940256099942544~3347511713\u0026#34; /\u0026gt; \u0026lt;/application\u0026gt; 다음은 화면에 광고를 표시하는 버튼을 추가합니다.\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;androidx.constraintlayout.widget.ConstraintLayout \u0026lt;Button android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Show AD\u0026#34; android:id=\u0026#34;@+id/button\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintLeft_toLeftOf=\u0026#34;parent\u0026#34; app:layout_constraintRight_toRightOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; View Binding을 설정하고 애드몹 라이브러리를 초기화합니다. setRequestConfiguration을 사용해서 테스트용으로 사용할 기기에 대해서는 애드몹이 카운트하여 어뷰징으로 판단하지 않도록 제외하여 줍니다.\n광고를 불러오는 작업은 loadRewardedAd에서 수행하고 광고를 표시하는 작업은 showRewardedAd에서 수행하도록 합니다. 또한 보상값을 저장하는 reward 전역변수도 만들어 줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class MainActivity : AppCompatActivity() { private lateinit var binding: ActivityMainBinding private var mRewardedAd: RewardedAd? = null private var reward: Int = 0 override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) binding = ActivityMainBinding.inflate(layoutInflater) setContentView(binding.root) MobileAds.initialize(this) val testDeviceIds = listOf(\u0026#34;My device ID1\u0026#34;, \u0026#34;My device ID2\u0026#34;) MobileAds.setRequestConfiguration( RequestConfiguration.Builder() .setTestDeviceIds(testDeviceIds) .build() ) loadRewardedAd() binding.button.setOnClickListener { showRewardedAd() } } } 우선은 광고를 불러오는 부분을 작성하겠습니다.\nadUnitId에는 애드몹 사이트에서 제공하는 전면광고 아이디를 기입합니다. 여기서는 구글에서 제공하는 테스트 ID를 사용했습니다.\n그리고 RewardedAdLoadCallback의 인스턴스를 만들어서 loadAd에 바로 전달해줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private fun loadRewardedAd() { val adRequest = AdRequest.Builder().build() mRewardedAd = RewardedAd(this, \u0026#34;ca-app-pub-3940256099942544/5224354917\u0026#34;) mRewardedAd?.loadAd(adRequest, object : RewardedAdLoadCallback() { override fun onRewardedAdFailedToLoad(p0: LoadAdError?) { Log.d(\u0026#34;TAG\u0026#34;, p0!!.message) mRewardedAd = null } override fun onRewardedAdLoaded() { Toast.makeText(applicationContext, \u0026#34;Ad loading succeed\u0026#34;, Toast.LENGTH_SHORT).show() } }) } 다음은 광고를 보여주는 부분입니다. 광고가 잘 불러와졌는지 콜백으로 확인하고 show로 표시하면 됩니다.\n유저가 광고를 끝까지 시청하면 onUserEarnedReward가 실행되고, 보상을 p0로 전달받게 됩니다. 이 때 p0의 값은 Admob 사이트에서 지정한 type과 amount값입니다. 따라서 함수블럭 안에서 p0 값을 전달받아 기존 아이템 값에 반영되도록 하면 되는데 여기서는 텍스트뷰에 그 값을 표시하도록 하였습니다.\n그리고 RewardedAdCallback 객체를 만들어서 show에 전달해주는데 이때 onRewardedAdClosed로 광고를 닫으면 다음광고를 다시 로딩하도록 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 private fun showRewardedAd() { if (mRewardedAd != null) { if (mRewardedAd!!.isLoaded) { mRewardedAd?.show(this, object : RewardedAdCallback() { override fun onUserEarnedReward(p0: RewardItem) { Toast.makeText(applicationContext, \u0026#34;onUserEarnedReward\u0026#34;, Toast.LENGTH_SHORT).show() val rewardAmount = p0.amount val rewardType = p0.type reward += rewardAmount binding.textview.text = \u0026#34;$rewardType : $reward\u0026#34; } override fun onRewardedAdClosed() { loadRewardedAd() } override fun onRewardedAdFailedToShow(p0: AdError?) { Log.d(\u0026#34;TAG\u0026#34;, p0!!.message) mRewardedAd = null } override fun onRewardedAdOpened() { Log.d(\u0026#34;TAG\u0026#34;, \u0026#34;onRewardedAdOpened\u0026#34;) } }) } } } Google Admob Version 19.7.0 이상에서의 구현 구현은 loadRewardedAd와 showRewardedAd의 내용만 변경하면 됩니다. 우선 loadRewardedAd는 다음과 같이 변경됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private fun loadRewardedAd() { val adRequest = AdRequest.Builder().build() RewardedAd.load( this, \u0026#34;ca-app-pub-3940256099942544/5224354917\u0026#34;, adRequest, object : RewardedAdLoadCallback() { override fun onAdFailedToLoad(p0: LoadAdError) { Log.d(\u0026#34;TAG\u0026#34;, p0.message) mRewardedAd = null } override fun onAdLoaded(p0: RewardedAd) { Toast.makeText(applicationContext, \u0026#34;Ad loading succeed\u0026#34;, Toast.LENGTH_SHORT).show() mRewardedAd = p0 } } ) } 그리고 showRewardedAd는 다음과 같이 변경합니다. mRewardedAd 에 대해 null체크를 수행한 뒤 FullScreenContentCallback 프로퍼티를 작성해주고 show로 광고를 보여주면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 private fun showRewardedAd() { if (mRewardedAd != null) { mRewardedAd?.fullScreenContentCallback = object : FullScreenContentCallback() { override fun onAdDismissedFullScreenContent() { Log.d(\u0026#34;TAG\u0026#34;, \u0026#34;Ad was dismissed\u0026#34;) mRewardedAd = null loadRewardedAd() } override fun onAdFailedToShowFullScreenContent(p0: AdError?) { Log.d(\u0026#34;TAG\u0026#34;, \u0026#34;Ad failed to show.\u0026#34;) } override fun onAdShowedFullScreenContent() { Log.d(\u0026#34;TAG\u0026#34;, \u0026#34;Ad showed fullscreen content.\u0026#34;) mRewardedAd = null } } mRewardedAd?.show(this, OnUserEarnedRewardListener() { rewardItem -\u0026gt; val rewardAmount = rewardItem.amount val rewardType = rewardItem.type reward += rewardAmount binding.textview.text = \u0026#34;$rewardType : $reward\u0026#34; }) } else { Log.d(\u0026#34;TAG\u0026#34;, \u0026#34;The rewarded ad was not loaded yet\u0026#34;) } } 이렇게 해서 Google Admob 라이브러리로 앱에 보상형 광고를 표시하는 법에 대해 알아보았습니다.\n","date":"2021-04-24T21:48:55+09:00","permalink":"https://cliearl.github.io/posts/android/gadmob-rewarded/","title":"Google Admob으로 보상형 광고 표시하기"},{"content":"이번 포스팅에서는 구글 애드몹을 이용해서 전면광고를 표시하는 법에 대해 알아보도록 하겠습니다.\n우선은 애드몹 디펜던시를 추가합니다. 현재 애드몹 라이브러리의 최신버전은 19.7.0인데요, 19.6.0 버전과는 사용법이 많이 다르기 때문에 두 방법 모두 설명하도록 하겠습니다.\nGoogle Admob Version 19.6.0 이하에서의 구현 1 2 3 dependencies { implementation \u0026#39;com.google.android.gms:play-services-ads:19.6.0\u0026#39; } AndroidManifest.xml 안에 애드몹 사이트에서 부여받는 앱 ID를 입력합니다. 여기서는 구글에서 테스트용으로 제공하는 ID를 입력하였습니다.\n1 2 3 4 5 6 7 \u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34; /\u0026gt; \u0026lt;application \u0026lt;meta-data android:name=\u0026#34;com.google.android.gms.ads.APPLICATION_ID\u0026#34; android:value=\u0026#34;ca-app-pub-3940256099942544~3347511713\u0026#34; /\u0026gt; \u0026lt;/application\u0026gt; 다음은 화면에 광고를 표시하는 버튼을 추가합니다.\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;androidx.constraintlayout.widget.ConstraintLayout \u0026lt;Button android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Show AD\u0026#34; android:id=\u0026#34;@+id/button\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintLeft_toLeftOf=\u0026#34;parent\u0026#34; app:layout_constraintRight_toRightOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; View Binding을 설정하고 애드몹 라이브러리를 초기화합니다. setRequestConfiguration을 사용해서 테스트용으로 사용할 기기에 대해서는 애드몹이 카운트하여 어뷰징으로 판단하지 않도록 제외하여 줍니다.\n광고를 불러오는 작업은 loadInterstitialAd에서 수행하고 광고를 표시하는 작업은 showInterstitialad에서 수행하도록 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 private var mInterstitialAd: InterstitialAd? = null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) binding = ActivityMainBinding.inflate(layoutInflater) setContentView(binding.root) MobileAds.initialize(this) val testDeviceIds = listOf(\u0026#34;My device ID1\u0026#34;, \u0026#34;My device ID2\u0026#34;) MobileAds.setRequestConfiguration( RequestConfiguration.Builder() .setTestDeviceIds(testDeviceIds) .build() ) loadInterstitialAd() binding.button.setOnClickListener { showInterstitialad() } } 우선은 광고를 불러오는 부분을 작성하겠습니다.\nadUnitId에는 애드몹 사이트에서 제공하는 전면광고 아이디를 기입합니다. 여기서는 구글에서 제공하는 테스트 ID를 사용했습니다.\n그리고 adListener를 붙여주는데 onAdClosed로 광고를 닫으면 다음광고를 다시 로딩하도록 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 private fun loadInterstitialAd() { val adRequest = AdRequest.Builder().build() mInterstitialAd = InterstitialAd(this) mInterstitialAd?.adUnitId = \u0026#34;ca-app-pub-3940256099942544/1033173712\u0026#34; mInterstitialAd?.loadAd(adRequest) mInterstitialAd?.adListener = object : AdListener() { override fun onAdLoaded() { Toast.makeText(applicationContext, \u0026#34;Ad loading succeed\u0026#34;, Toast.LENGTH_SHORT).show() } override fun onAdFailedToLoad(p0: LoadAdError?) { Toast.makeText(applicationContext, \u0026#34;Ad loading failed\u0026#34;, Toast.LENGTH_SHORT).show() mInterstitialAd = null } override fun onAdClosed() { mInterstitialAd?.loadAd(adRequest) } } } 다음은 광고를 보여주는 부분입니다. 광고가 잘 불러와졌는지 확인하고 show로 표시하면 됩니다.\n1 2 3 4 5 6 private fun showInterstitialad() { if (mInterstitialAd != null) { if (mInterstitialAd!!.isLoaded) { mInterstitialAd?.show() } } Google Admob Version 19.7.0 이상에서의 구현 구현은 loadInterstitialAd와 showInterstitialad의 내용만 변경하면 됩니다. 우선 loadInterstitialAd는 다음과 같이 변경됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private fun loadInterstitialAd() { val adRequest = AdRequest.Builder().build() InterstitialAd.load( this, \u0026#34;ca-app-pub-3940256099942544/1033173712\u0026#34;, adRequest, object : InterstitialAdLoadCallback() { override fun onAdFailedToLoad(p0: LoadAdError) { Toast.makeText(applicationContext, \u0026#34;Ad loading failed\u0026#34;, Toast.LENGTH_SHORT).show() mInterstitialAd = null } override fun onAdLoaded(p0: InterstitialAd) { Toast.makeText(applicationContext, \u0026#34;Ad loading succeed\u0026#34;, Toast.LENGTH_SHORT).show() mInterstitialAd = p0 } } ) } 그리고 showInterstitialad는 다음과 같이 변경합니다. mInterstitialAd에 대해 null체크를 수행한 뒤 fullScreenContentCallback 프로퍼티를 작성해주고 show로 광고를 보여주면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 private fun showInterstitialad() { if (mInterstitialAd != null) { mInterstitialAd?.fullScreenContentCallback = object : FullScreenContentCallback() { override fun onAdDismissedFullScreenContent() { Log.d(\u0026#34;TAG\u0026#34;, \u0026#34;Ad was dismissed.\u0026#34;) mInterstitialAd = null loadInterstitialAd() } override fun onAdFailedToShowFullScreenContent(p0: AdError?) { Log.d(\u0026#34;TAG\u0026#34;, \u0026#34;Ad failed to show.\u0026#34;) mInterstitialAd = null } override fun onAdShowedFullScreenContent() { Log.d(\u0026#34;TAG\u0026#34;, \u0026#34;Ad showed fullscreen content\u0026#34;) } } mInterstitialAd?.show(this) } else { Log.d(\u0026#34;TAG\u0026#34;, \u0026#34;The interstitial ad was not ready yet\u0026#34;) } } 이렇게 해서 Google Admob 라이브러리로 앱에 전면광고를 표시하는 법에 대해 알아보았습니다.\n","date":"2021-04-22T20:36:18+09:00","permalink":"https://cliearl.github.io/posts/android/gadmob-interstitial/","title":"Google Admob으로 전면광고 표시하기"},{"content":"이번 포스팅에서는 SharedPreferences에 복잡한 형태의 데이터를 json 포맷으로 저장하고 불러오는 법에 대해 알아보도록 하겠습니다.\nSharedPreferences는 Key-Value 형태로 이루어진 딕셔너리를 저장하도록 설계된 저장장소인데요, 이 Value 부분에 json으로 구성된 긴 형태의 데이터를 저장함으로써 복잡한 형태의 데이터도 저장할 수가 있습니다.\n이 때 앱 안의 데이터를 json으로 Serialize하고 다시 복원하는 Deserialize를 편하게 실행하게 해 주는 Gson이라는 라이브러리가 있습니다. 이번 포스팅에서는 이 라이브러리를 활용하겠습니다.\n여기서는 Data class 이해하고 RecyclerView에서 사용하기 강의에서 만들었던 프로젝트를 수정하면서 구현해보겠습니다.\n라이브러리 추가 우선 Gson을 디펜던시에 추가합니다.\n1 2 3 dependencies { implementation \u0026#39;com.google.code.gson:gson:2.8.6\u0026#39; } 화면 구성 다음은 로딩에 사용할 플로팅버튼을 화면에 추가해줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;androidx.constraintlayout.widget.ConstraintLayout \u0026lt;com.google.android.material.floatingactionbutton.FloatingActionButton android:id=\u0026#34;@+id/button_load\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginEnd=\u0026#34;20dp\u0026#34; android:layout_marginBottom=\u0026#34;20dp\u0026#34; android:clickable=\u0026#34;true\u0026#34; android:focusable=\u0026#34;true\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:srcCompat=\u0026#34;@android:drawable/ic_menu_add\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; Key 준비 SharedPreferences에서는 데이터를 다룰때 키를 사용하므로 그때 사용할 키를 정의해줍니다. 평범하게 SharedPreferences를 이용하는 경우에는 각 밸류마다 서로다른 키를 지정해야하므로 많은 키를 지정해야 하는데 여기서는 모든 데이터를 뭉뚱그려서 하나의 키에 저장할 것이므로 데이터용 키는 하나만 만들면 됩니다.\n1 2 3 4 companion object { private const val KEY_PREFS = \u0026#34;shared_preferences\u0026#34; private const val KEY_DATA = \u0026#34;monster_data\u0026#34; } savePref() 작성 다음은 데이터를 저장하는 함수를 만듭니다. 이미 SharedPreferences로 앱 설정값 저장하고 불러오기강의에서 설명했던 방식과 유사한데요, gson을 사용하면 gson 인스턴스를 만들고, 그 인스턴스를 이용해서 데이터를 json으로 변환하는 작업이 추가됩니다. Recyclerview 어댑터 안의 데이터는 private를 떼어서 다른 클래스에서도 접근할수 있도록 합니다.\n1 2 3 4 5 6 7 8 9 private fun savePref() { val sharedPreferences = getSharedPreferences(KEY_PREFS, Context.MODE_PRIVATE) val editor = sharedPreferences.edit() val gson = Gson() val json = gson.toJson(rvAdapter.dataSet) editor.putString(KEY_DATA, json) editor.apply() Log.d(\u0026#34;debug\u0026#34;, \u0026#34;Data saved\u0026#34;) } loadPref() 함수 작성 이번엔 데이터를 불러오는 함수를 만듭니다. 기존의 방법과 역시 동일한데, TypeToken을 적용해서 데이터를 복원하는 부분이 추가되었습니다. json으로 SharedPreferences에 저장하는 순간 데이터가 가지고 있는 타입정보가 모두 사라지기 때문에 데이터를 복원하면서 타입정보를 다시 부여하기 위해 타입토큰을 사용합니다. 여기서는 \u0026lt;\u0026lt;ArrayList\u0026lt;Monster\u0026gt;\u0026gt;라는 타입을 만들어서 데이터에 부여해 줍니다. 그리고 Recyclerview 어댑터 안의 데이터는 변경가능하도록 var 로 변경해줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private fun loadPref() { val sharedPreferences = getSharedPreferences(KEY_PREFS, Context.MODE_PRIVATE) if (sharedPreferences.contains(KEY_DATA)) { val gson = Gson() val json = sharedPreferences.getString(KEY_DATA, \u0026#34;\u0026#34;) try { val typeToken = object : TypeToken\u0026lt;ArrayList\u0026lt;Monster\u0026gt;\u0026gt;() {}.type rvAdapter.dataSet = gson.fromJson(json, typeToken) } catch (e: JsonParseException) { e.printStackTrace() } Log.d(\u0026#34;debug\u0026#34;, \u0026#34;Data loaded\u0026#34;) } } 함수 실행 다음은 메인액티비티 안에서 savePref와 loadPref를 실행시키면 됩니다. loadPref를 실행하고 어댑터에 데이터 변경을 알려주면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 override fun onCreate(savedInstanceState: Bundle?) { binding.buttonLoad.setOnClickListener { loadPref() rvAdapter.notifyItemChanged(0, rvAdapter.dataSet.size) } } override fun onStop() { super.onStop() savePref() } 이렇게 SharedPrefenrences와 Gson을 이용해서 복잡한 데이터를 json으로 저장하고 불러오는 법에 대해 알아보았습니다.\n","date":"2021-04-22T20:33:39+09:00","permalink":"https://cliearl.github.io/posts/android/sharedpreferneces-gson/","title":"SharedPreferences를 json 포맷으로 관리하기"},{"content":"이번 포스팅에서는 구글 애드몹 라이브러리를 이용해서 앱에 배너광고를 표시하는 법에 대해 알아보도록 하겠습니다.\n우선은 build.gradle에 애드몹 라이브러를 추가해줍니다.\n1 2 3 dependencies { implementation \u0026#39;com.google.android.gms:play-services-ads:19.7.0\u0026#39; } 다음은 AndroidManifest.xml에 인터넷 접근권한을 부여하고 애드몹 ID 정보를 추가합니다. 애드몹 ID는 구글 애드몹 사이트에 가입하고 자신의 앱을 등록하면 받을 수 있습니다. 여기서는 Mobile Ads SDK (Android)에서 테스트를 할때 사용하라고 주는 값을 사용하였습니다.\n1 2 3 4 5 6 7 \u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34;/\u0026gt; \u0026lt;application \u0026lt;meta-data android:name=\u0026#34;com.google.android.gms.ads.APPLICATION_ID\u0026#34; android:value=\u0026#34;ca-app-pub-3940256099942544~3347511713\u0026#34; /\u0026gt; \u0026lt;/application\u0026gt; 다음은 화면 xml에 광고를 표시하기 위한 AdView를 추가합니다. 배너 사이즈는 이미 정해진 리스트 중에서 고를 수 있는데 여기서는 SMART_BANNER를 선택했습니다.\n그리고 adUnitId는 구글 애드몹 사이트에서 각 앱에 대해 배너광고를 추가했을 때 생기는 ID를 넣으면 됩니다. 여기서는 역시 구글에서 제공하는 테스트 ID를 사용했습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;com.google.android.gms.ads.AdView android:id=\u0026#34;@+id/adView\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; app:adSize=\u0026#34;SMART_BANNER\u0026#34; app:adUnitId=\u0026#34;ca-app-pub-3940256099942544/6300978111\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; 다음은 메인액티비티를 설정합니다. 뷰바인딩을 설정해주고 showBannerAd라는 함수를 만든 뒤 그 안에서 광고를 불러오는 처리를 해 줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 private fun showBannerAd() { // 애드몹 초기화 MobileAds.initialize(this) {} // 테스트용 기기를 등록하여 광고 카운팅을 제외하도록 처리 val testDeviceIds = listOf(\u0026#34;My device ID1\u0026#34;, \u0026#34;My Device ID2\u0026#34;) MobileAds.setRequestConfiguration( RequestConfiguration.Builder() .setTestDeviceIds(testDeviceIds) .build() ) mAdView = binding.adView // 인터넷에서 광고를 불러옴 val bannerAdRequest = AdRequest.Builder().build() // 광고를 배너에 표시 mAdView.loadAd(bannerAdRequest) mAdView.adListener = object : AdListener() { // 광고 로딩이 성공했을때 처리 override fun onAdLoaded() { Toast.makeText(applicationContext, \u0026#34;Banner Ad loaded\u0026#34;, Toast.LENGTH_SHORT).show() } // 광고 로딩이 실패했을때 처리 override fun onAdFailedToLoad(p0: LoadAdError?) { Toast.makeText(applicationContext, \u0026#34;Banner Ad loading failed\u0026#34;, Toast.LENGTH_SHORT).show() } } } 마지막으로 사용되지 않는 배너리소스를 정리해줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 override fun onPause() { mAdView.pause() super.onPause() } override fun onResume() { super.onResume() mAdView.resume() } override fun onDestroy() { mAdView.destroy() super.onDestroy() } 이렇게 해서 앱에 구글 애드몹으로 배너광고를 표시하는 법에 대해 알아보았습니다.\n","date":"2021-04-21T22:17:58+09:00","permalink":"https://cliearl.github.io/posts/android/gadmob-banner/","title":"Google Admob으로 배너광고 표시하기"},{"content":"이번 포스팅에서는 SharedPreferences를 사용하는 법에 대해 알아보도록 하겠습니다.\n데이터를 앱에 저장하는 방법 데이터를 앱에 저장하는 방법에는 크게 세가지가 있습니다.\n파일 I/O (내부 또는 외부 저장소) 접근 권한을 획득하고 파일을 열었다 닫았다 하는 수고가 필요함 관계형 데이터베이스 SQLite 등을 이용해 복잡한 관계형 데이터를 저장할 수 있음 간단한 데이터를 저장할거라면 구축과 관리에 많은 시간과 노려이 요구됨 SharedPreference Key/Value 형태로 이용함 내부적으로는 XML 파일로 저장됨 파일을 열고 닫을 필요 없이 핸들러를 만들어서 간편하게 사용가능함 SharedPreferences는 보통 복잡한 데이터를 기록하기보다는, 게임의 환경설정이라든지 그런 단순한 내용을 저장하는데 적절한 저장공간이라고 생각하면 됩니다. 그래서 이번에는 SharedPreferences를 사용해서 게임설정값을 저장하고 복원하는 앱을 만들어보도록 하겠습니다.\nSharedPreferences 사용법 getSharedPreferences(KEY, MODE)로 핸들러를 받아옴 MODE에는 MODE_PRIVATE, MODE_WORLD_READABLE, MODE_WORLD_WRITABLE, MODE_MULTI_PROCESS 가 있다 작성한 앱에서만 접근 가능하게 하는 MODE_PRIVATE 를 사용 데이터 기록 에디터를 써서 기록할 데이터를 메모리에 올림 commit 혹은 apply로 파일에 기록 화면 구성 위에서부터 순서대로 화면의 요소를 구성하는 여러가지 종류의 버튼을 배치하여 값을 변화시킬수 있도록 구성하였습니다. 앱이 처음 실행되었을 때 표시되는 기본값도 여기서 설정해줍니다. 그리고 마지막으로 SAVE버튼과 LOAD 동작을 하는 버튼 두개도 배치합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/textView\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginStart=\u0026#34;16dp\u0026#34; android:layout_marginTop=\u0026#34;50dp\u0026#34; android:layout_marginEnd=\u0026#34;16dp\u0026#34; android:text=\u0026#34;Game Settings\u0026#34; android:textSize=\u0026#34;30sp\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/textView2\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginStart=\u0026#34;16dp\u0026#34; android:layout_marginTop=\u0026#34;40dp\u0026#34; android:layout_marginEnd=\u0026#34;16dp\u0026#34; android:text=\u0026#34;Graphic Quality\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toBottomOf=\u0026#34;@+id/textView\u0026#34; /\u0026gt; \u0026lt;RadioGroup android:id=\u0026#34;@+id/radio_graphics\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginStart=\u0026#34;16dp\u0026#34; android:layout_marginTop=\u0026#34;20dp\u0026#34; android:layout_marginEnd=\u0026#34;16dp\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:checkedButton=\u0026#34;@id/radioButton_medium\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toBottomOf=\u0026#34;@+id/textView2\u0026#34;\u0026gt; \u0026lt;RadioButton android:id=\u0026#34;@+id/radioButton_low\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Low\u0026#34; /\u0026gt; \u0026lt;RadioButton android:id=\u0026#34;@+id/radioButton_medium\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Medium\u0026#34; /\u0026gt; \u0026lt;RadioButton android:id=\u0026#34;@+id/radioButton_high\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;High\u0026#34; /\u0026gt; \u0026lt;/RadioGroup\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/textView3\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginStart=\u0026#34;16dp\u0026#34; android:layout_marginTop=\u0026#34;40dp\u0026#34; android:layout_marginEnd=\u0026#34;16dp\u0026#34; android:text=\u0026#34;Music Volume\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toBottomOf=\u0026#34;@+id/radio_graphics\u0026#34; /\u0026gt; \u0026lt;SeekBar android:id=\u0026#34;@+id/seekBar_music\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginStart=\u0026#34;16dp\u0026#34; android:layout_marginTop=\u0026#34;20dp\u0026#34; android:layout_marginEnd=\u0026#34;16dp\u0026#34; android:max=\u0026#34;100\u0026#34; android:progress=\u0026#34;50\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toBottomOf=\u0026#34;@+id/textView3\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/textView4\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginStart=\u0026#34;16dp\u0026#34; android:layout_marginTop=\u0026#34;40dp\u0026#34; android:layout_marginEnd=\u0026#34;16dp\u0026#34; android:text=\u0026#34;SFX Volume\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toBottomOf=\u0026#34;@+id/seekBar_music\u0026#34; /\u0026gt; \u0026lt;SeekBar android:id=\u0026#34;@+id/seekBar_sfx\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginStart=\u0026#34;16dp\u0026#34; android:layout_marginTop=\u0026#34;20dp\u0026#34; android:layout_marginEnd=\u0026#34;16dp\u0026#34; android:max=\u0026#34;100\u0026#34; android:progress=\u0026#34;50\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toBottomOf=\u0026#34;@+id/textView4\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/textView5\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginStart=\u0026#34;16dp\u0026#34; android:layout_marginTop=\u0026#34;40dp\u0026#34; android:layout_marginEnd=\u0026#34;16dp\u0026#34; android:text=\u0026#34;Enable Vertical Sync\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toBottomOf=\u0026#34;@+id/seekBar_sfx\u0026#34; /\u0026gt; \u0026lt;androidx.appcompat.widget.SwitchCompat android:id=\u0026#34;@+id/switch_vsync\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginStart=\u0026#34;16dp\u0026#34; android:layout_marginTop=\u0026#34;30dp\u0026#34; android:layout_marginEnd=\u0026#34;16dp\u0026#34; android:checked=\u0026#34;true\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toBottomOf=\u0026#34;@+id/seekBar_sfx\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button_save\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;70dp\u0026#34; android:text=\u0026#34;SAVE\u0026#34; app:layout_constraintEnd_toStartOf=\u0026#34;@+id/button_load\u0026#34; app:layout_constraintHorizontal_bias=\u0026#34;0.5\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toBottomOf=\u0026#34;@+id/textView5\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button_load\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;70dp\u0026#34; android:text=\u0026#34;LOAD\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintHorizontal_bias=\u0026#34;0.5\u0026#34; app:layout_constraintStart_toEndOf=\u0026#34;@+id/button_save\u0026#34; app:layout_constraintTop_toBottomOf=\u0026#34;@+id/textView5\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; 버튼에 클릭리스너 설정 View Binding을 적용하고 SAVE 버튼을 눌렀을 때는 savePref, LOAD 버튼을 눌렀을때는 loadPref를 실행하도록 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class MainActivity : AppCompatActivity() { private lateinit var binding: ActivityMainBinding override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) binding = ActivityMainBinding.inflate(layoutInflater) setContentView(binding.root) binding.buttonSave.setOnClickListener { savePref() } binding.buttonLoad.setOnClickListener { loadPref() } } private fun savePref() { } private fun loadPref() { } } 접근키 작성 SharedPreferences는 Key-Value 형태로 값을 저장하고 불러오기 때문에 이 때 사용할 Key 값을 companion object로 준비해서 편하게 사용할 수 있도록 준비합니다.\n1 2 3 4 5 6 7 companion object { private const val KEY_PREFS = \u0026#34;game_settings\u0026#34; private const val KEY_GRAPHIC = \u0026#34;graphic_quality\u0026#34; private const val KEY_MUSIC = \u0026#34;music_volume\u0026#34; private const val KEY_SFX = \u0026#34;sfx_volume\u0026#34; private const val KEY_VSYNC = \u0026#34;vertical_sync\u0026#34; } savePref 작성 데이터를 저장하는 부분을 작성합니다. 핸들러를 만들고 Editor 객체를 만들어서 put 함수로 Key-Value 쌍을 저장하도록 했습니다. 버튼의 값은 개체가 가진 프로퍼티로 가져올 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 private fun savePref() { val sharedPreferences = getSharedPreferences(KEY_PREFS, Context.MODE_PRIVATE) val editor = sharedPreferences.edit() editor.putInt(KEY_GRAPHIC, binding.radioGraphics.checkedRadioButtonId) editor.putInt(KEY_MUSIC, binding.seekBarMusic.progress) editor.putInt(KEY_SFX, binding.seekBarSfx.progress) editor.putBoolean(KEY_VSYNC, binding.switchVsync.isChecked) editor.apply() Toast.makeText(applicationContext, \u0026#34;Game settings has saved\u0026#34;, Toast.LENGTH_SHORT).show() } loadPref() 작성 저장된 데이터를 불러오는 부분을 작성합니다. 저장할때와 마찬가지로 핸들러를 만들고 저장할때 사용한 키와 동일한 키를 사용해서 get함수로 값을 불러온 뒤 그 값을 버튼에 반영합니다. 이 때 contains를 사용해서 SharedPreferences 데이터가 존재하는지를 우선 확인하고 작업을 수행하도록 했습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private fun loadPref() { val sharedPreferences = getSharedPreferences(KEY_PREFS, Context.MODE_PRIVATE) if (sharedPreferences.contains(KEY_GRAPHIC)) { val graphicValue = sharedPreferences.getInt(KEY_GRAPHIC, 0) val musicValue = sharedPreferences.getInt(KEY_MUSIC, 50) val sfxValue = sharedPreferences.getInt(KEY_SFX, 50) val vsyncValue = sharedPreferences.getBoolean(KEY_VSYNC, true) binding.radioGraphics.check(graphicValue) binding.seekBarMusic.progress = musicValue binding.seekBarSfx.progress = sfxValue binding.switchVsync.isChecked = vsyncValue Toast.makeText(applicationContext, \u0026#34;Game settings has loaded\u0026#34;, Toast.LENGTH_SHORT).show() } 이렇게 SharedPreferences를 써서 앱의 데이터를 저장하고 불러오는 법에 대해 알아보았습니다.\n","date":"2021-04-20T21:35:43+09:00","permalink":"https://cliearl.github.io/posts/android/sharedpreferences-basic/","title":"SharedPreferences로 앱 설정값 저장하고 불러오기"},{"content":"이번 포스팅에서는 RecyclerView에 Swipe, Drag, Touch 동작을 연결하는 법에 대해 알아보도록 하겠습니다.\n이번에 만들어볼 앱에서는 ViewHolder를 스와이프하면 삭제가 되고, 잡고 끌면 위아래로 ViewHolder를 이동할 수 있으며, ViewHolder를 터치하면 그 내용이 변하는 동작을 수행하도록 하겠습니다.\n여기서는 제가 RecyclerView에 View Binding 적용하기 강의에서 만들었던 Recyclerview 앱을 수정하는 방식으로 구현해보겠습니다.\n리팩토링 우선 View Binding을 사용하도록 설정을 추가합니다.\n1 2 3 android { buildFeatures.viewBinding true } 메인액티비티에서 만들어주던 dataSet은 초기화시 데이터를 바로 입력하도록 하고 Recyclerview 어댑터 안쪽으로 이동시켜서 받아오는 파라미터를 삭제합니다.\n1 2 3 4 5 6 7 class RecyclerViewAdapter: RecyclerView.Adapter\u0026lt;RecyclerViewAdapter.ViewHolder\u0026gt;() { private val dataSet: ArrayList\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; = arrayListOf\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;().apply { for (i in 0..99) { add(listOf(\u0026#34;$i th main\u0026#34;, \u0026#34;$i th sub\u0026#34;)) } } } 메인액티비티의 Recyclerview 프로퍼티를 정하는 부분은 with로 묶어줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 class MainActivity : AppCompatActivity() { private val rvAdapter = RecyclerViewAdapter() override fun onCreate(savedInstanceState: Bundle?) { with(binding) { with(recyclerView) { layoutManager = LinearLayoutManager(context, LinearLayoutManager.VERTICAL, false) adapter = rvAdapter addItemDecoration(DividerItemDecoration(context, DividerItemDecoration.VERTICAL)) } } } } 데이터 조작함수 추가 데이터를 조작하는 함수를 Recyclerview 안에 다음과 같이 추가합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class RecyclerViewAdapter: RecyclerView.Adapter\u0026lt;RecyclerViewAdapter.ViewHolder\u0026gt;() { // ViewHolder 포지션을 받아 그 위치의 데이터를 삭제하고 notifyItemRemoved로 어댑터에 갱신명령을 전달 fun removeData(position: Int) { dataSet.removeAt(position) notifyItemRemoved(position) } // 두 개의 ViewHolder 포지션을 받아 Collections.swap으로 첫번째 위치와 두번째 위치의 데이터를 교환 fun swapData(fromPos: Int, toPos: Int) { Collections.swap(dataSet, fromPos, toPos) notifyItemMoved(fromPos, toPos) } // 선택한 ViewHolder 포지션의 데이터 내용을 바꾸도록 함 fun setData(position: Int) { dataSet[position] = listOf(\u0026#34;main viewholder touched!\u0026#34;, \u0026#34;sub viewholder touched!\u0026#34;) notifyItemChanged(position) } } 스와이프와 드래그 기능 붙이기 안드로이드에서는 Recyclerview에 입력되는 스와이프와 드래그 동작을 감지하는 ItemTouchHelper.SimpleCallback 클래스가 이미 준비되어 있으니 이걸 사용하겠습니다. 이 콜백함수는 다음과 같이 정의하면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 val itemTouchCallback = object : ItemTouchHelper.SimpleCallback ( ItemTouchHelper.UP or ItemTouchHelper.DOWN, ItemTouchHelper.LEFT ){ override fun onMove( recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder, target: RecyclerView.ViewHolder ): Boolean { val fromPos: Int = viewHolder.adapterPosition val toPos: Int = target.adapterPosition rvAdapter.swapData(fromPos, toPos) return true } override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) { rvAdapter.removeData(viewHolder.layoutPosition) } } ItemTouchHelper(itemTouchCallback).attachToRecyclerView(binding.recyclerView) 우선 ItemTouchHelper.SimpleCallback의 인스턴스를 만들어 ItemTouchHelper의 attachToRecyclerView로 Recyclerview와 연결시켜주면 스와이프와 드래그 동작을 인식할 수 있게 됩니다.\n초기화할때 인식할 드래그 방향을 dragDirs, 스와이프 방향을 swipeDirs로 정해주는데 여기서는 드래그 방향은 위, 아래. 그리고 스와이프 방향은 왼쪽만 인식하도록 하였습니다.\nonSwiped에서는 스와이프가 일어날 때 데이터를 삭제하는 동작을 정의합니다. 터치한 ViewHolder 위치를 어댑터에 전달하여 removeData를 실행합니다.\nonMove에서는 드래그가 일어날 때 두 ViewHolder의 데이터를 교환하는 동작을 정의합니다. 드래그가 시작되었을 때 ViewHolder의 위치와 이동이 완료된 후의 ViewHolder의 위치를 각각 fromPos, toPos로 정의하고 swapData에 넘겨주어 데이터를 교환하게 합니다. 이때 스크롤 동작과 헷갈리지 않게 하기 위해서 ViewHolder를 드래그하기 위해서는 롱터치를 해야 합니다.\n이때 onSwiped에서는 layoutPosition을 사용했고, onMove에서는 adapterPosition을 사용했습니다. 스와이프를 할 때 ViewHolder의 위치는 고정되어 있지만 드래그를 할때는 ViewHolder의 위치가 계속 변하게 됩니다. adapterPosition은 전체 Recyclerview 안에서 위치를 가져오는 속성이고 layoutPosition은 고정된 ViewHolder의 위치를 가져오는 속성입니다.\nViewHolder에 드래그 가능 여부를 알리는 이미지 표시 현재는 ViewHolder가 데이터만 표시되고 있어서 이 ViewHolder를 드래그 할수 있는지 바로 알수 있는 방법이 없습니다. 그래서 ViewHolder 오른쪽에 햄버거 마크를 넣어서 드래그 할 수 있는 ViewHolder라는 표시를 해 주도록 하겠습니다.\n아이콘은 Vector Asset 메뉴에서 추가하고 LinearLayout과 FrameLayout을 섞어서 ViewHolder 모양을 수정했습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:paddingStart=\u0026#34;20dp\u0026#34; android:paddingEnd=\u0026#34;20dp\u0026#34; android:gravity=\u0026#34;center_vertical\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;9\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Main TextView\u0026#34; android:textSize=\u0026#34;24sp\u0026#34; android:padding=\u0026#34;5dp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_sub\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Sub TextView\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; android:padding=\u0026#34;5dp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;FrameLayout android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;30dp\u0026#34; android:layout_height=\u0026#34;30dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:src=\u0026#34;@drawable/ic_baseline_reorder_24\u0026#34; /\u0026gt; \u0026lt;/FrameLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; 스와이프시 백그라운드 설정하기 다음으로 스와이프를 할때 미끄러져 나간 ViewHolder 아래에 Canvas 클래스를 이용해 작성한 빨간색 비트맵 이미지와 휴지통 아이콘을 표시되도록 하겠습니다. 이것을 위해서는 ItemTouchHelper.SimpleCallback의 onChildDraw를 사용합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 override fun onChildDraw( c: Canvas, recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder, dX: Float, dY: Float, actionState: Int, isCurrentlyActive: Boolean ) { val icon: Bitmap // actionState가 SWIPE 동작일 때 배경을 빨간색으로 칠하는 작업을 수행하도록 함 if (actionState == ItemTouchHelper.ACTION_STATE_SWIPE) { val itemView = viewHolder.itemView val height = (itemView.bottom - itemView.top).toFloat() val width = height / 4 val paint = Paint() if (dX \u0026lt; 0) { // 왼쪽으로 스와이프하는지 확인 // ViewHolder의 백그라운드에 깔아줄 사각형의 크기와 색상을 지정 paint.color = Color.parseColor(\u0026#34;#ff0000\u0026#34;) val background = RectF(itemView.right.toFloat() + dX, itemView.top.toFloat(), itemView.right.toFloat(), itemView.bottom.toFloat()) c.drawRect(background, paint) // 휴지통 아이콘과 표시될 위치를 지정하고 비트맵을 그려줌 // 비트맵 이미지는 Image Asset 기능으로 추가하고 drawable 폴더에 위치하도록 함 icon = BitmapFactory.decodeResource(resources, R.drawable.ic_menu_delete) val iconDst = RectF(itemView.right.toFloat() - 3 - width, itemView.top.toFloat() + width, itemView.right.toFloat() - width, itemView.bottom.toFloat() - width) c.drawBitmap(icon, null, iconDst, null) } } super.onChildDraw( c, recyclerView, viewHolder, dX, dY, actionState, isCurrentlyActive ) } 터치 조작 정의하기 Recyclerview 어댑터 안에 정의한 ViewHolder 클래스에 클릭 리스너를 붙여주면 ViewHolder의 터치를 인식할 수 있습니다. 그럴려면 ViewHolder가 사용하는 list_item.xml에서 레이아웃에 id를 부여해줘야 합니다.\n1 2 3 \u0026lt;LinearLayout android:id=\u0026#34;@+id/vhLayout\u0026#34; \u0026gt; \u0026lt;/LinearLayout\u0026gt; 그리고 클릭 리스너를 붙여서 Snackbar로 터치한 위치를 보여주고 setData 함수가 실행되도록 합니다. 이때 setData는 Recyclerview 안의 함수이므로 ViewHolder 클래스에서 접근을 할 수가 없습니다. 그래서 ViewHolder를 inner classs로 변경하여줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class RecyclerViewAdapter: RecyclerView.Adapter\u0026lt;RecyclerViewAdapter.ViewHolder\u0026gt;() { inner class ViewHolder(private val binding: ListItemBinding) : RecyclerView.ViewHolder(binding.root) { fun bind(data:List\u0026lt;String\u0026gt;) { binding.tvMain.text = data[0] binding.tvSub.text = data[1] binding.vhLayout.setOnClickListener { Snackbar.make(it, \u0026#34;Item $layoutPosition touched!\u0026#34;, Snackbar.LENGTH_SHORT).show() setData(layoutPosition) } } } } ViewHolder 터치시 애니메이션 추가 현재는 ViewHolder를 터치했을 때 내용이 바뀌도록 하긴 했지만 정확히 어떤 ViewHolder를 터치한건지에 대한 표시가 나타나지 않습니다. 하지만 xml에 selectableItemBackground 속성을 정의하면 터치한 ViewHolder를 주목시키는 효과를 추가할 수 있습니다.\n1 2 3 \u0026lt;LinearLayout android:background=\u0026#34;?attr/selectableItemBackground\u0026#34;\u0026gt; \u0026lt;/LinearLayout\u0026gt; 이렇게 해서 Recyclerview에 스와이프, 드래그, 터치 동작에 대한 응답을 설정하는 법에 대해 알아보았습니다.\n","date":"2021-04-18T22:40:04+09:00","permalink":"https://cliearl.github.io/posts/android/recyclerview-touch/","title":"RecyclerView를 Swipe, Drag, Touch하기"},{"content":"이번 포스팅에서는 Recyclerview를 사용하는 법에 대해 알아보도록 하겠습니다.\nRecyclerview의 특징 Recyclerview는 화면에 리스트 형식의 데이터를 표시하기 위해서 사용하는 모듈입니다. 보통 화면에 리스트뷰를 표시할수 있게 하는 ListView는 예를들어 데이터가 10개 있을 경우 데이터를 표시하기 위한 ViewHolder가 10개 필요합니다. 그러나 Recyclerview는 ViewHolder를 6개만 만들고 화면에는 5개를 표시한 후 화면 바깥으로 1번 ViewHolder가 빠져나가면 7번 ViewHolder로 변경해서 재사용합니다. 그래서 자원을 더 아낄 수 있게 되는 것이죠.\n또 데이터는 Recyclerview Adapter를 통해 ViewHolder에 들어가게 되는데 ViewHolder에 데이터 1을 넣어서 표현했을 경우, ViewHolder는 그대로 놔두고 데이터 2를 넣는 식으로 ViewHolder를 재활용해서 사용할 수 있습니다. 그래서 Recyclerview라는 이름이 붙게 된 것이죠.\nRecyclerview 구현 라이브러리 추가 우선은 Recyclerview를 사용하기 위한 라이브러리를 추가합니다.\n1 2 3 dependencies { implementation \u0026#39;androidx.recyclerview:recyclerview:1.1.0\u0026#39; } 화면 구성 다음은 화면에 Recyclerview 모듈을 추가합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;androidx.recyclerview.widget.RecyclerView android:id=\u0026#34;@+id/recycler_view\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:scrollbars=\u0026#34;vertical\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; ViewHolder 화면구성 다음으로 ViewHolder의 화면을 구성합니다. ViewHolder는 LinearLayout에 TextView 2개를 쌓은 단순한 구조로 정의했습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Main TextView\u0026#34; android:textSize=\u0026#34;24dp\u0026#34; android:padding=\u0026#34;5dp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_sub\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Sub TextView\u0026#34; android:textSize=\u0026#34;18dp\u0026#34; android:padding=\u0026#34;5dp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Recyclerview 어댑터 작성 다음은 RecyclerView.Adapter 클래스를 상속받는 Recyclerview Adapter를 작성합니다. 외부에서 전달받을 데이터는 dataSet이라고 정의했습니다.\n그리고 ViewHolder 클래스를 작성합니다. 여기서는 외부에서 전달받은 데이터를 ViewHolder 화면의 텍스트뷰와 연결하는 작업을 bind함수로 정의합니다.\nonCreateViewHolder에서 ViewHolder클래스에 list_item으로 inflate한 객체를 넘겨준 ViewHolder를 작성하여 반환합니다. onBindViewHolder에서는 ViewHolder 클래스의 bind함수로 작성된 ViewHolder와 전달받은 개별 데이터를 연결합니다. getItemCount에서는 전달받은 데이터의 전체길이를 넘겨주어 어댑터가 ViewHolder를 얼마나 만들어야 할지를 결정하게 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class RecyclerViewAdapter(private val dataSet: ArrayList\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;): RecyclerView.Adapter\u0026lt;RecyclerViewAdapter.ViewHolder\u0026gt;() { override fun onCreateViewHolder( parent: ViewGroup, viewType: Int ): ViewHolder { val view = LayoutInflater.from(parent.context).inflate(R.layout.list_item, parent, false) return ViewHolder(view) } override fun onBindViewHolder(holder: ViewHolder, position: Int) { holder.bind(dataSet[position]) } override fun getItemCount(): Int { return dataSet.size } class ViewHolder(view: View): RecyclerView.ViewHolder(view) { private val tvMain: TextView = view.tv_main private val tvSub: TextView = view.tv_sub fun bind(data:List\u0026lt;String\u0026gt;) { tvMain.text = data[0] tvSub.text = data[1] } } } 데이터셋 준비 다음으로 메인액티비티에서 Recyclerview로 넘겨줄 데이터셋을 만듭니다. String을 두개 포함한 배열을 100개 가지는 리스트의 리스트 형식으로 작성하였습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class MainActivity : AppCompatActivity() { private val dataSet: ArrayList\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; = arrayListOf() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) addData() } private fun addData() { for (i in 0..99) { dataSet.add(listOf(\u0026#34;$i th main\u0026#34;, \u0026#34;$i th sub\u0026#34;)) } } } Recyclerview와 Adapter 연결 마지막으로 Recyclerview와 Adapter를 연결해줍니다. Recyclerview 안에서 ViewHolder를 어떻게 정렬할지 결정하는 LayoutManager 프로퍼티를 정의하는데 여기서는 LinearLayoutManager를 사용하였습니다. 그 외로 GridLayoutManager나 StaggeredGridLayoutManager를 사용할 수도 있습니다.\n그리고 위에서 만들어 준 RecyclerViewAdapter를 초기화하여 adapter 프로퍼티에 반영해줍니다.\naddItemDecoration 속성에 DividerItemDecoration.HORIZONTAL을 전달하면 각 ViewHolder 사이에 구분선을 표시할 수도 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class MainActivity : AppCompatActivity() { private val dataSet: ArrayList\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; = arrayListOf() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) addData() recycler_view.layoutManager = LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false) // recycler_view.layoutManager = GridLayoutManager(this, 2) recycler_view.adapter = RecyclerViewAdapter(dataSet) recycler_view.addItemDecoration(DividerItemDecoration(this, DividerItemDecoration.HORIZONTAL)) } private fun addData() { for (i in 0..99) { dataSet.add(listOf(\u0026#34;$i th main\u0026#34;, \u0026#34;$i th sub\u0026#34;)) } } } 이렇게 해서 Recyclerview를 사용하는 법에 대해 알아보았습니다.\n","date":"2021-04-17T22:43:43+09:00","permalink":"https://cliearl.github.io/posts/android/recyclerview-implement/","title":"앱에서 RecyclerView 사용하기"},{"content":"이번 포스팅에서는 RecyclerView에 View Binding을 적용하는 법에 대해 알아보도록 하겠습니다.\nView Binding을 사용해야 하는 이유나 그 장점에 대해서는 findViewById 대신 View Binding 사용하기 포스팅과 유튜브 강의를 참조하시고 이번 포스팅에선 변환하는 방법에 대해서만 설명하도록 하겠습니다.\n이번 포스팅에서 변환에 사용한 프로젝트는 앱에서 RecyclerView 사용하기 포스팅에서 작성한 것을 사용하도록 하겠습니다.\n코드 작성 View Binding 활성화 우선은 gradle에서 kotlin-android-extensions 플러그인을 삭제하고 View Binding을 활성화합니다.\n1 2 3 4 5 6 7 plugins { - id \u0026#39;kotlin-android-extensions\u0026#39; } android { + buildFeatures.viewBinding true } 메인액티비티 수정 다음은 메인액티비티를 수정해줍니다. View Binding을 활성화하는 순간 생기는 ActivityMainBinding 클래스를 초기화하여 binding이라는 인스턴스로 사용합니다. 기존의 RecyclerView의 프로퍼티는 binding.recyclerView로 접근하여 설정합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class MainActivity : AppCompatActivity() { private lateinit var binding: ActivityMainBinding private val dataSet: ArrayList\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; = arrayListOf() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) - setContentView(R.layout.activity_main) - addData() - - recycler_view.layoutManager = LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false) -// recycler_view.layoutManager = GridLayoutManager(this, 2) - - recycler_view.adapter = RecyclerViewAdapter(dataSet) - recycler_view.addItemDecoration(DividerItemDecoration(this, DividerItemDecoration.HORIZONTAL)) + binding = ActivityMainBinding.inflate(layoutInflater) + setContentView(binding.root) + addData() + binding.recyclerView.layoutManager = LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false) + binding.recyclerView.adapter = RecyclerViewAdapter(dataSet) + binding.recyclerView.addItemDecoration(DividerItemDecoration(this, DividerItemDecoration.VERTICAL)) } private fun addData() { for (i in 0..99) { dataSet.add(listOf(\u0026#34;$i th main\u0026#34;, \u0026#34;$i th sub\u0026#34;)) } } } Recyclerview 어댑터 수정 onCreateViewHolder에서 뷰를 만들 때 ListItemBinding 클래스로 만들어지는 binding 인스턴스를 사용하도록 변경하여줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class RecyclerViewAdapter(private val dataSet: ArrayList\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;): RecyclerView.Adapter\u0026lt;RecyclerViewAdapter.ViewHolder\u0026gt;() { override fun onCreateViewHolder( parent: ViewGroup, viewType: Int ): ViewHolder { - val view = LayoutInflater.from(parent.context).inflate(R.layout.list_item, parent, false) - return ViewHolder(view) + val binding = ListItemBinding.inflate(LayoutInflater.from(parent.context), parent, false) + return ViewHolder(binding) } override fun onBindViewHolder(holder: ViewHolder, position: Int) { holder.bind(dataSet[position]) } override fun getItemCount(): Int { return dataSet.size } } ViewHolder 수정 기존의 ViewHolder에서는 뷰를 받아와서 정의하고 그걸 데이터와 연결하는 작업이 필요했는데, View Binding에서는 binding 인스턴스가 생성되는순간 자동으로 뷰를 binding의 프로퍼티로 접근할 수 있기 때문에 이 코드가 필요없게 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class RecyclerViewAdapter(private val dataSet: ArrayList\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;): RecyclerView.Adapter\u0026lt;RecyclerViewAdapter.ViewHolder\u0026gt;() { - class ViewHolder(view: View): RecyclerView.ViewHolder(view) { - private val tvMain: TextView = view.tv_main - private val tvSub: TextView = view.tv_sub - - fun bind(data:List\u0026lt;String\u0026gt;) { - tvMain.text = data[0] - tvSub.text = data[1] - } - } + class ViewHolder(private val binding: ListItemBinding) : RecyclerView.ViewHolder(binding.root) { + fun bind(data:List\u0026lt;String\u0026gt;) { + binding.tvMain.text = data[0] + binding.tvSub.text = data[1] + } } } 이렇게 해서 RecyclerView에 View Binding을 적용하는 방법에 대해 알아보았습니다.\n","date":"2021-04-17T22:43:04+09:00","permalink":"https://cliearl.github.io/posts/android/viewbinding-recyclerview/","title":"RecyclerView에 View Binding 적용하기"},{"content":"이번 포스팅에서는 프로젝트 안에 작성된 ViewPager1 모듈을 ViewPager2 모듈로 변환하는 법에 대해 알아보도록 하겠습니다.\n안드로이드 라이브러리가 androidx로 바뀌는 과정에서 ViewPager 라이브러리도 업그레이드 해달라는 요구가 꽤 많았습니다. 그래서 구글에서는 ViewPager2 라이브러리를 개발했습니다.\nViewPager2의 특징 구글에서 설명하는 ViewPager2의 [장점]((https://developer.android.com/training/animation/vp2-migration)은 다음과 같습니다.\nVertical scrolling : 세로스크롤 Right-to-left support : 페이지를 오른쪽에서 왼쪽으로 정렬 modifiable Fragment collenctions : 프래그먼트의 변화를 동적으로 반영 가능 DiffUtil : Recyclerview의 DiffUtil을 사용 가능 ViewPager1 라이브러리는 더이상 관리되지 않음 ViewPager2로 변환 여기서는 기존에 ViewPager를 써서 좌우로 스와이프되는 화면 만들기 강의에서 작성했던 ViewPager1 프로젝트를 변환하는 방식으로 구현해 보도록 하겠습니다.\n우선은 ViewPager2 라이브러리를 추가합니다.\n1 2 3 dependencies { implementation \u0026#39;androidx.viewpager2:viewpager2:1.0.0\u0026#39; } 다음은 xml에서 viewpager 모듈을 viewpager2로 바꾸면서 orientation 이라는 속성도 추가해주는데요 이 때 값을 vertical로 주면 세로로 스크롤할 수 있게 됩니다. 또 인디케이터도 viewpager2에 대응하는 CircleIndicator3로 변경하여 줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;me.relex.circleindicator.CircleIndicator3 android:id=\u0026#34;@+id/indicator\u0026#34; android:layout_height=\u0026#34;48dp\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; app:ci_drawable=\u0026#34;@drawable/black_radius\u0026#34; app:ci_height=\u0026#34;7dp\u0026#34; app:ci_width=\u0026#34;7dp\u0026#34; app:ci_margin=\u0026#34;4dp\u0026#34; /\u0026gt; \u0026lt;androidx.viewpager2.widget.ViewPager2 android:id=\u0026#34;@+id/viewpager\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 다음은 어댑터를 변환하여 줍니다. ViewPager2의 어댑터는 FragementStateAdapter를 상속받습니다. 그리고 getCount라는 함수 이름을 getItemCount로 변경합니다. 마지막으로 getItem 함수이름은 createFragment로 변경합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class CustomPagerAdapter(fa: FragmentActivity): FragmentStateAdapter(fa) { private val PAGENUMBER = 4 override fun getItemCount(): Int { return PAGENUMBER } override fun createFragment(position: Int): Fragment { return when (position) { 0 -\u0026gt; TestFragment.newInstance(R.raw.img00, \u0026#34;test 00\u0026#34;) 1 -\u0026gt; TestFragment.newInstance(R.raw.img01, \u0026#34;test 01\u0026#34;) 2 -\u0026gt; TestFragment.newInstance(R.raw.img02, \u0026#34;test 02\u0026#34;) 3 -\u0026gt; TestFragment.newInstance(R.raw.img03, \u0026#34;test 03\u0026#34;) else -\u0026gt; TestFragment.newInstance(R.raw.img00, \u0026#34;page00\u0026#34;) } } } 마지막으로 ViewPager와 어댑터를 다음과 같이 연결하여 줍니다. vpAdapter의 형은 FragmentStateAdapter이고 this로 액티비티를 전달받도록 변경하면 완료입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 class MainActivity : AppCompatActivity() { private var vpAdapter: FragmentStateAdapter? = null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) vpAdapter = CustomPagerAdapter(this) viewpager.adapter = vpAdapter indicator.setViewPager(viewpager) } } 이렇게 해서 ViewPager모듈을 ViewPager2로 전환하는 법에 대해 알아보았습니다.\n","date":"2021-04-17T18:38:59+09:00","permalink":"https://cliearl.github.io/posts/android/viewpager2-convert/","title":"ViewPager1 프로젝트를 ViewPager2 프로젝트로 변환하기"},{"content":"이번 포스팅에서는 ViewPager를 써서 화면을 좌우로 스와이프할 수 있는 앱을 만들어 보겠습니다.\nViewPager는 페이지를 만들어놓고 유저가 좌우로 스와이프 함으로써 각 페이지를 전환할 수 있게 하는 모듈입니다. 예를들어 페이지 1,2,3을 준비하고 이 페이지들을 ViewPager 어댑터에 전달합니다. 어댑터는 페이지를 순서대로 배열하고 페이지 2를 표시합니다. 페이지 1과 3은 화면 바깥의 좌우로 배치한 뒤 스와이프를 하면 현재 페이지를 밀어내고 화면 밖에서 대기하는 페이지가 ViewPager 화면으로 들어오게 됩니다.\n화면 구성 우선은 화면을 구성하겠습니다. 화면에는 현재 어떤 페이지인지를 보여주는 인디케이터를 설치하고 나머지 영역을 ViewPager로 지정합니다. 인디케이터는 CircleIndicator라는 외부 라이브러리를 이용하겠습니다.\n1 2 3 dependencies { implementation \u0026#39;me.relex:circleindicator:2.1.6\u0026#39; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;me.relex.circleindicator.CircleIndicator android:id=\u0026#34;@+id/indicator\u0026#34; android:layout_height=\u0026#34;48dp\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; app:ci_drawable=\u0026#34;@drawable/black_radius\u0026#34; app:ci_height=\u0026#34;7dp\u0026#34; app:ci_width=\u0026#34;7dp\u0026#34; app:ci_margin=\u0026#34;4dp\u0026#34; /\u0026gt; \u0026lt;androidx.viewpager.widget.ViewPager android:id=\u0026#34;@+id/viewpager\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; CircleIndicator를 사용시 인디케이터로 사용할 마크를 ci_drawable 특성으로 지정해 주어야 하는데 여기서는 drawable 폴더 안에 black_radius.xml 파일을 추가해서 지정해 주었습니다.\n1 2 3 4 5 6 7 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;shape xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:shape=\u0026#34;oval\u0026#34;\u0026gt; \u0026lt;solid android:color=\u0026#34;@android:color/black\u0026#34;/\u0026gt; \u0026lt;/shape\u0026gt; 프래그먼트 작성 다음은 페이지를 만드는데 사용할 프래그먼트를 작성해줍니다. TestFragment라는 이름의 빈 프래그먼트를 하나 만들고 다음과 같이 이미지뷰와 텍스트뷰를 가지는 화면을 만들어줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.TestFragment\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/imageView\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; app:layout_constraintBottom_toTopOf=\u0026#34;@+id/textView\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintHorizontal_bias=\u0026#34;0.5\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; tools:src=\u0026#34;@tools:sample/avatars\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/textView\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;TextView\u0026#34; android:textAppearance=\u0026#34;@style/TextAppearance.AppCompat.Large\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintHorizontal_bias=\u0026#34;0.5\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toBottomOf=\u0026#34;@+id/imageView\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; TestFragment 클래스의 내용은 기본적으로 만들어지는 코드를 조금만 바꾸어주겠습니다. 외부에서 전달되는 image와 text 값을 newInstance에서 번들형태로 초기화한후 onCreate에서 값을 부여해줍니다. onCreateView에서 화면을 만들고 onViewCreated에서 이미지뷰와 텍스트뷰를 표시하도록 하였습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class TestFragment : Fragment() { private var image: Int? = null private var text: String? = null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) arguments?.let { image = it.getInt(\u0026#34;image\u0026#34;, 0) text = it.getString(\u0026#34;text\u0026#34;, \u0026#34;\u0026#34;) } } override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { return inflater.inflate(R.layout.fragment_test, container, false) } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) imageView.setImageResource(image!!) textView.text = text } companion object { fun newInstance(image: Int, text: String) = TestFragment().apply { arguments = Bundle().apply { putInt(\u0026#34;image\u0026#34;, image) putString(\u0026#34;text\u0026#34;, text) } } } } ViewPager 어댑터 작성 및 연결 다음으로는 ViewPager Adapter를 만들어줍니다. 별개 클래스이지만 내용이 복잡하지 않으므로 메인액티비티 클래스 안에 만들어줍니다. 어댑터는 FragmentStatePagerAdapter 혹은 FragmentStateAdapter를 상속받아야 하는데 페이지가 많을 경우에는 자원을 동적으로 관리해 주는 FragmentStatePagerAdapter가 적절하고 페이지수가 적다면 FragmentStateAdapter를 사용하면 됩니다. 전체 페이지수는 4개이고 getItem에서 페이지를 선택했을 때 반환할 프래그먼트를 지정해줍니다. 이때 프래그먼트에 전달할 내용을 어댑터 안에서 지정해줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class MainActivity : AppCompatActivity() { class CustomPagerAdapter(fm: FragmentManager): FragmentStatePagerAdapter(fm, BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) { private val PAGENUMBER = 4 override fun getCount(): Int { return PAGENUMBER } override fun getItem(position: Int): Fragment { return when (position) { 0 -\u0026gt; TestFragment.newInstance(R.raw.img00, \u0026#34;test 00\u0026#34;) 1 -\u0026gt; TestFragment.newInstance(R.raw.img01, \u0026#34;test 01\u0026#34;) 2 -\u0026gt; TestFragment.newInstance(R.raw.img02, \u0026#34;test 02\u0026#34;) else -\u0026gt; TestFragment.newInstance(R.raw.img03, \u0026#34;test 03\u0026#34;) } } } } 마지막으로 메인액티비티에서 ViewPager와 어댑터를 연결하고, 인디케이터와 ViewPager를 연결하면 작성 완료입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 class MainActivity : AppCompatActivity() { private var vpAdapter: FragmentStatePagerAdapter? = null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) vpAdapter = CustomPagerAdapter(supportFragmentManager) viewpager.adapter = vpAdapter indicator.setViewPager(viewpager) } } 이렇게해서 ViewPager를 사용하는 법에 대해 알아보았습니다.\n","date":"2021-04-17T18:38:46+09:00","permalink":"https://cliearl.github.io/posts/android/viewpager-swipe/","title":"ViewPager를 써서 좌우로 스와이프되는 화면 만들기"},{"content":"이번 포스팅에서는 View Binding을 사용하는 법에 대해 알아보도록 하겠습니다.\nKotlin Android Extensions의 지원 중단 안드로이드 스튜디오에서는 뷰를 만들고 그 뷰를 불러오기 위해서 findViewById를 사용합니다. 이 때 kotlin-android-extensions 플러그인을 사용하면 이 함수의 사용을 생략하고 간편하게 코드를 작성할 수 있습니다.\n문제는 서로 다른 xml파일을 만들었을 때 Id를 동일하게 사용할 수 있기 때문에 코드에서 헷갈릴 수 있다는 문제가 있습니다. 그래서 구글에서는 안드로이드 스튜디오 4.1부터 kotlin-android-extensions의 지원을 중단하고 View Binding을 사용하도록 안내하고 있습니다.\nView Binding의 구조 View Binding을 프로젝트에서 사용하도록 설정하면 각 레이아웃 xml 파일에 대해 ViewBinding 클래스를 상속받는 개별 binding class가 자동으로 생성됩니다. 이 때 클래스 이름은 레이아웃 파일 이름을 파스칼 표기법으로 변환하고 Binding 접미사를 추가합니다.\n그리고나서 onCreate 안에서 View Binding 클래스에 인스턴스를 생성하면 뷰의 Id를 인스턴스의 프로퍼티로 사용할 수 있게 됩니다.\nView Binding의 장점 구글에서 설명하는 View Binding의 장점은 두가지가 있습니다. 하나는 Null-safe로, 서로 다른 레이아웃에 대해 같은 ID를 가진 뷰를 정확히 구분할 수 있게 됩니다. 만약 Id를 참조할 수 없을 경우 @Nullable로 만들어 아예 사용할 수 없게 막습니다. 두번째는 Type-safe로, findViewById를 사용할 경우 뷰에 잘못된 타입을 지정할 수 있다는 문제가 있는데, View Binding에서는 그런 문제가 발생하지 않는다는 특징이 있습니다.\nfindViewById 사용상의 문제 안드로이드 스튜디오의 Create new project에서 Basic Activity를 만들어서 View Binding 환경을 구현해 보겠습니다. 우선은 findViewById를 사용할 때 어떤 문제가 발생하는지 보여드리겠습니다.\nkotlin-android-extensions 플러그인을 적용한 뒤, fragment_first.xml, fragment_second.xml의 텍스트뷰 Id를 동일하게 지정해줍니다.\n이 상태에서 FirstFragment.kt에서 텍스트뷰를 사용하면 연결된 xml이 자동으로 임포트 되는데, 코드만 봐서는 이게 fragment_first.xml에서 온 코드인지 fragment_second.xml에서 온 것인지 알 수가 없습니다.\n참조한 뷰가 한개일 때는 import 파트를 보면 출처를 알 수 있지만 사용하는 뷰가 많아지면 어떤 뷰가 어떤 import를 참조한 것인지 한눈에 파악하는 것이 매우 어려워지게 되는 문제가 있습니다.\nActivity에 View Binding 적용 다음과 같이 gradle에서 View Binding을 활성화하면 모든 레이아웃 xml 파일에 대해 바인딩클래스가 생성됩니다.\n1 2 3 android { buildFeatures.viewBinding true } 우선은 메인액티비티에 적용해보겠습니다. 자동으로 생성된 ActivityMainBinding 타입의 binding 전역변수를 준비하고 onCreate 에서 inflate시킵니다.\n그러면 View Binding을 사용할 수 있게 되므로 기존에 R.layout.activity_main를 전달하던 setContentView에 binding.root를 전달합니다. 또 findViewById를 사용하던 setSupportActionBar에 전달하는 값도 binding.toolbar로 변경합니다. 플로팅버튼은 binding.fab로 사용할 수 있습니다.\n참고로 onCreateOptionsMenu, onOptionsItemSelected 안의 내용은 findViewById()가 아니라 findItem()이라는 메소드를 사용하는것이기 때문에 View Binding으로 대체를 할 수 없습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class MainActivity : AppCompatActivity() { private lateinit var binding: ActivityMainBinding override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // setContentView(R.layout.activity_main) // setSupportActionBar(findViewById(R.id.toolbar)) // // findViewById\u0026lt;FloatingActionButton\u0026gt;(R.id.fab).setOnClickListener { view -\u0026gt; // Snackbar.make(view, \u0026#34;Replace with your own action\u0026#34;, Snackbar.LENGTH_LONG) // .setAction(\u0026#34;Action\u0026#34;, null).show() // } binding = ActivityMainBinding.inflate(layoutInflater) setContentView(binding.root) setSupportActionBar(binding.toolbar) binding.fab.setOnClickListener { view -\u0026gt; Snackbar.make(view, \u0026#34;Replace with your own action\u0026#34;, Snackbar.LENGTH_LONG).setAction(\u0026#34;Action\u0026#34;, null).show() } } override fun onCreateOptionsMenu(menu: Menu): Boolean { // Inflate the menu; this adds items to the action bar if it is present. menuInflater.inflate(R.menu.menu_main, menu) return true } override fun onOptionsItemSelected(item: MenuItem): Boolean { // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. return when (item.itemId) { R.id.action_settings -\u0026gt; true else -\u0026gt; super.onOptionsItemSelected(item) } } } Fragment에 View Binding 적용 다음은 Fragment에 View Binding을 적용해 보겠습니다. Fragment에서 사용할 때는 _binding과 binding 변수 두개를 만들어줍니다. _binding은 Fragment를 사용하지 않을 때 자원을 반환할 수 있도록 Nullable 형태로 준비합니다. 그리고 실제로 사용하는 binding은 _binding이 초기화 되었을 때 get()으로 값을 가져오도록 합니다.\nFragment의 라이프사이클을 고려해 _binding을 onCreateView 안에서 초기화하면 binding이 자동으로 생성됩니다. 그러면 binding.root를 뷰로 반환하여주고, onViewCreated에서는 binding의 프로퍼티로써 텍스트뷰와 버튼을 사용하면 됩니다.\n마지막으로 onDestroyView에서는 Fragment가 어떠한 이유로 파괴될 때 _binding을 null로 만들어서 자원을 반환하도록 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class FirstFragment : Fragment() { private var _binding : FragmentFirstBinding? = null private val binding get() = _binding!! override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { // Inflate the layout for this fragment // return inflater.inflate(R.layout.fragment_first, container, false) _binding = FragmentFirstBinding.inflate(inflater, container, false) return binding.root } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) // view.findViewById\u0026lt;Button\u0026gt;(R.id.button_first).setOnClickListener { // findNavController().navigate(R.id.action_FirstFragment_to_SecondFragment) // } binding.textview.text = \u0026#34;first fragment text\u0026#34; binding.buttonFirst.setOnClickListener { findNavController().navigate(R.id.action_FirstFragment_to_SecondFragment) } } override fun onDestroyView() { super.onDestroyView() _binding = null } } SecondFragment의 내용은 FirstFragment와 동일하므로 생략하겠습니다. 이렇게 해서 프로젝트의 액티비티와 Fragement에 View Binding을 적용하는 법에 대해 알아보았습니다.\n","date":"2021-04-17T18:38:23+09:00","permalink":"https://cliearl.github.io/posts/android/apply-viewbinding/","title":"findViewById 대신 View Binding 사용하기"},{"content":"이번 포스팅에서는 앱에 표시되는 ActionBar와 StatusBar를 감추는 법에 대해 알아보도록 하겠습니다.\n화면에 보시면 타이틀이 표시되는 창을 TitleBar 혹은 ActionBar라고 합니다. StatusBar는 화면 맨 위에 배터리나 와이파이 연결상태등을 보여주는 부분을 가리킵니다. 이 ActionBar와 StatusBar는 디자인적으로 필요가 없을 경우 표시되지 않게 할 수 있는데요, 그 방법을 알아보겠습니다.\nActionBar 삭제 ActionBar 표시를 없애는 방법은 몇가지가 있습니다. 우선은 테마를 이용하는 방법입니다. res-\u0026gt;value-\u0026gt;theme.xml 파일을 열어 상속받도록 parent에 설정한 테마 중 NoActionBar가 붙은 테마를 사용하면 액션바가 표시되지 않게 됩니다.\n두번째는 테마 속성을 사용하는 방법입니다. 테마는 편집을 할 수도 있기 때문에 상속받는 테마는 그대로 두고 타이틀바 속성만 다음과 같이 비활성화해 줍니다.\n1 2 3 4 5 6 \u0026lt;resources xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34;\u0026gt; \u0026lt;style\u0026gt; \u0026lt;item name=\u0026#34;windowActionBar\u0026#34;\u0026gt;false\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;windowNoTitle\u0026#34;\u0026gt;true\u0026lt;/item\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;/resources\u0026gt; 마지막으로 액티비티에서 ActionBar를 없애는 방법입니다. ActionBar의 참조를 가져와서 hide명령을 실행하기 위해 다음과 같이 코드를 추가하여 줍니다.\n1 2 3 4 5 6 7 class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { val actionBar: ActionBar? = supportActionBar actionBar?.hide() } } StatusBar 삭제 StatusBar는 다음과 같이 themes.xml의 속성을 해제시켜서 표시되지 않게 할 수 있습니다.\n1 2 3 4 5 \u0026lt;resources xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34;\u0026gt; \u0026lt;style\u0026gt; \u0026lt;item name=\u0026#34;android:windowFullscreen\u0026#34;\u0026gt;false\u0026lt;/item\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;/resources\u0026gt; 두번째 방법은 액티비티에서 설정하는 방법입니다. theme에서 한 설정을 코드로 해준다고 생각하시면 됩니다.\n1 2 3 4 5 6 class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { window.setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN) } } 이렇게 해서 ActionBar와 StatusBar의 표시를 없애는 방법에 대해 알아보았습니다.\n","date":"2021-04-16T20:05:22+09:00","permalink":"https://cliearl.github.io/posts/android/hide-titlebar/","title":"앱에서 ActionBar, StatusBar 감추기"},{"content":"이번 포스팅에서는 앱에서 음악을 재생하는 방법에 대해 알아보도록 하겠습니다.\n여기서는 MediaPlayer 클래스를 이용하여 음악을 재생하는 앱을 만들어 볼 건데요, 플레이버튼을 누르면 음악이 재생되고, 포즈를 누르면 일시정지가 되며, 다시 누르면 음악이 시작이 되게 됩니다. 그리고 스탑버튼을 누르면 정지가 되고 플레이버튼을 누르면 음악이 처음부터 시작되게 됩니다.\n음악파일 단순재생 프로젝트에서 실행할 음악파일은 res -\u0026gt; raw 폴더 안에 복사해줍니다. 저는 다음 사이트에서 다운받은 파일을 사용하겠습니다. https://maoudamashii.jokersounds.com/archives2/bgm_maoudamashii_orchestra02.html\n그러면 메인 액티비티에서 재생을 해보겠습니다\n1 2 3 4 5 6 7 8 9 10 11 class MainActivity : AppCompatActivity() { private var mediaPlayer: MediaPlayer? = null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) mediaPlayer = MediaPlayer.create(this, R.raw.bgm) mediaPlayer?.start() } } 음악이 실행이 되는데 문제는 앱이 백그라운드로 넘어가도 음악이 계속 실행이 되게 됩니다. 이걸 막기 위해서는 메인액티비티의 onStop에서 리소스를 해제해 주면 됩니다.\n1 2 3 4 5 override fun onStop() { mediaPlayer?.release() mediaPlayer = null super.onStop() } 기능버튼 작성 다음은 Play, Pause, Stop 기능을 하는 버튼을 만들어 보겠습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/playButton\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;play\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toStartOf=\u0026#34;@+id/pauseButton\u0026#34; app:layout_constraintHorizontal_bias=\u0026#34;0.5\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/pauseButton\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;pause\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toStartOf=\u0026#34;@+id/stopButton\u0026#34; app:layout_constraintHorizontal_bias=\u0026#34;0.5\u0026#34; app:layout_constraintStart_toEndOf=\u0026#34;@+id/playButton\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/stopButton\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;stop\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintHorizontal_bias=\u0026#34;0.5\u0026#34; app:layout_constraintStart_toEndOf=\u0026#34;@+id/pauseButton\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; 각 버튼에 기능 부여 다음은 이 버튼들에 클릭리스너로 동작을 지정해줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class MainActivity : AppCompatActivity() { private var mediaPlayer: MediaPlayer? = null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) playButton.setOnClickListener { if (mediaPlayer == null) { mediaPlayer = MediaPlayer.create(this, R.raw.bgm_maoudamashii_orchestra02) } mediaPlayer?.start() } pauseButton.setOnClickListener { if (mediaPlayer?.isPlaying == true) { mediaPlayer?.pause() } else { mediaPlayer?.start() } } stopButton.setOnClickListener { mediaPlayer?.stop() mediaPlayer = null } } override fun onStop() { super.onStop() mediaPlayer?.release() mediaPlayer = null } } 플레이버튼은 미디어플레이어를 초기화하고 재생을 시작합니다. 이때 중복동작을 막기 위해서 객체가 null일때만 초기화하고 재생하도록 하였습니다. 포즈버튼은 현재 플레이중인지 확인하고 플레이중이면 pause, 그렇지 않으면 start를 실행하도록 합니다. 마지막으로 스탑버튼은 객체를 해방하고 null로 만들어 다시 재생할수 있게 준비합니다.\n이렇게 MediaPlayer 클래스를 사용해서 음악을 재생하는 법에 대해 알아보았습니다.\n","date":"2021-04-15T18:37:51+09:00","permalink":"https://cliearl.github.io/posts/android/use-mediaplayer/","title":"안드로이드 앱에서 음악 재생하기"},{"content":"이번 포스팅에서는 안드로이드 스튜디오에서 앱의 빌드속도를 빠르게 할 수 있는 여러가지 설정들에 대해 알아보도록 하겠습니다.\n구글에서는 빌드속도를 최적화하는 여러가지 방법들에 대해 정리하여 소개했고 유튜브에서도 공개하고 있습니다. 오늘은 이 내용을 정리해 보겠습니다.\n최신버전의 Gradle 사용 우선은 최신버전의 Gradle을 사용하는게 중요합니다. 모듈에 대한 build.gradle 파일에서 사용하는 코틀린의 버전이나, 그래들 플러그인의 버전을 정할 수 있게 되어 있습니다. 버전내역을 보시면 플러그인이 업데이트 될 수록 빌드를 빠르게 하는 기술이 적용되기 때문에, 버전을 항상 최신버전으로 유지하는게 중요합니다.\nGradle 버전은 안드로이드 스튜디오에서 앱을 생성할 때 최신버전으로 생성이 되기 때문에 새로 생성하는 프로젝트에 대해서는 신경 쓸 필요가 없지만, 과거에 작성한 프로젝트의 경우에는 이 빌드플러그인을 가능한 최신 버전으로 업데이트해서 사용하시는걸 추천합니다.\n개발시 서로 다른 빌드세팅 사용 다음은 개발할 때 서로 다른 빌드세팅을 사용하는 겁니다.\n빌드 그래들 파일에 보시면 buildTypes 블럭이 있는데, 디버그를 위한 debug 블럭과 릴리즈를 위한 release 블럭을 나누어서 사용할 수 있습니다.\n릴리즈 블럭 안에는 실제 릴리즈를 할 때 수행할 내용이 들어가게 됩니다. 여기에 디버그 블럭을 추가합니다.\n예를들어 릴리즈시에는 코드의 암호화를 설정해야 하는데 디버그에서는 적용할 필요가 없으므로 설정을 구분해서 빌드를 할 수 있습니다.\nmultidex 사용하지 않음 자바 코드는 실행환경에 의존하지 않는 바이트코드로 컴파일 되어 자바 가상머신(JVM)이 실행되는 환경이라면 어디서나 동일하게 실행할 수 있습니다. 구글에서는 라이센스 문제를 피하기 위해 JVM 대신 Dalvik VM을 만들었고 이 DVM에서 돌리기 위해 자바 바이트코드를 DEX(Dalvik Executable)로 변환하여 사용하도록 했습니다.\n그런데 DVM을 사용하다보니 여러가지 문제가 있어서 새로 개발한 것이 ART VM입니다. 차이점을 간단하게 정리해 보면 다음과 같습니다.\nDalvik VM 32비트만 지원. JIT(Just In Time) 컴파일러 사용. 실행할 때 마다 필요한 컴파일을 수행하므로 설치파일이 작고 CPU, 메모리 사용이 높아 배터리 소모량이 큼. Android RunTime(ART) VM 32, 64 비트 지원. AOT(Ahead On Time) 컴파일러 사용. 설치시 모든 컴파일 작업을 수행해 놓으므로 설치파일이 크고 설치가 느리지만 실행중 자원소모량은 JIT보다 적어 배터리 효율이 높다. GC 효율이 향상됨. 킷캣 KitKat 버전부터 지원이 시작되었으며 롤리팝 Lolipop 버전 이후는 AOT 컴파일러가 기본으로 적용됨 누가 Nougat 버전 부터 JIT와 AOT를 모두 탑재하여 최초 설치시에는 JIT으로 컴파일 해 설치시간과 용량을 줄이고, 차후 기기를 사용하지 않을 때나 충전 중일 경우 컴파일을 조금씩 하여, 자주 사용되는 앱을 AOT 방식으로 전환하는 방식으로 바뀜. 단일 DEX(Dalvik Executable) 에서 사용가능한 함수의 최대개수는 65536개입니다. 이 개수를 넘으면 처리를 위해 multidex를 도입해야 하는데 API Level 21 롤리팝 미만에서는 멀티덱스 처리가 느린 Dalvik 런타임이 사용됩니다. 그러나 API 21 이상에서는 ART 런타임을 사용하기 때문에 빌드속도가 빨라집니다. 그것을 위해서는 minSDKVersion을 21로 설정하면 됩니다.\nAPI level 21이면 안드 OS로 따지면 5.0인데 보통은 4.4 킷캣까지 대응하시는 경우도 있지만 저 개인적으로는 큰 문제가 없다면 5.0 대응을 추천드립니다.\n복수의 APK 생성기능 비활성화 안드로이드 앱은 화면 해상도에 따라 서로 다른 앱이 각각 만들어지게 됩니다. 그래서 APK 파일이 크다면 abi/화면 해상도별로 APK 파일을 나누어 앱 용량을 줄일수가 있습니다.\n어차피 테스트를 하는 과정에서는 기능을 확인하는게 중요하기 때문에 다른 해상도에 대해 빌드를 생략해서 속도를 빠르게 할 수 있습니다. gradle에서 다음과 같이 코드를 쓰면 됩니다.\n1 2 splits.abi.enable = false splits.density.enable = false 패키징 리소스 최소화 앞에서는 특정 해상도에 대해서만 빌드하도록 설정을 했는데, 앱에 보시면 언어별로도 각각 앱이 만들어지게 되어 있습니다. 그래서 테스트 해야하는 언어 이외에는 빌드를 안하도록 설정을 할 수 있는데요, 예를들어 영어, 일본어, 독일어, 한국어에 대응하도록 만들었다면 기능확인을 위해 한국어 앱만 빌드를 하게 할 수 있습니다.\n1 2 3 4 5 6 7 8 defaultConfig{ applicationVariants.all { variant -\u0026gt; if (variant.buildType.name == \u0026#34;debug\u0026#34;) { variant.mergedFlavor.resourceConfiguration.clear() variant.mergedFlavor.resourceConfiguration.add(\u0026#34;ko\u0026#34;) } } } 빌드가 디버그면 설정을 다 없애버리고 한국어만 추가한다는 내용인데요, 참고로 현재 빌드가 디버그인지 릴리즈인지는 화면 왼쪽에 Build Variants 탭을 열어서 확인할 수 있습니다.\n패키징 리소스는 resConfig라는 기능을 이용해 간단하게 구현할 수도 있는데 그럴려면 productFlavor 블럭을 추가로 만들어서 다음과 같이 사용하면 됩니다. resConfig는 buildTypes 안에서는 사용할 수 없기 때문입니다. productFlavor의 구체적인 사용방법에 대해서는 Create a build variant for development를 참고하세요.\n1 2 3 4 5 productFlavors{ dev { resConfigs \u0026#34;ko\u0026#34;, \u0026#34;xxxhdpi\u0026#34; } } PNG 크런칭 비활성화 안드로이드에서 PNG 파일이 포함되면 PNG 파일을 압축하는 기능이 실행되는데요, 이 기능은 debug 빌드에서는 기본적으로 사용이 중지되기 때문에 신경 쓸 필요가 없습니다. 다만 release 빌드에서도 기능사용을 중지시키고 싶다면 코드를 다음과 같이 쓰면 됩니다.\n1 2 3 4 5 buildTypes{ release { crunchPngs false } } 필요없는 변경하지 않기 앱이 처음 실행되는 시작점의 역할을 하는 manifest 파일이 있습니다. 그런데 manifest를 변경하면 빌드가 처음부터 다시 이루어지게 됩니다.\n그런데 버전넘버와 버전코드를 변경하면 마니페스트 파일도 변경되어 앱이 처음부터 다시 빌드가 되기 때문에 테스트 시에는 이 값을 숫자로 고정하여 사용하는 것도 빌드를 빠르게 할 수 있는 방법이 될 수 있습니다.\n오류리포팅 기능 사용안함 안드로이드 앱에서는 Crashlytics 보고서를 자동으로 작성하도록 되어있습니다. 이 기능을 다음과 같이 비활성화 시켜 줍니다.\n1 2 3 debug{ ext.enableCrashlytics false } 라이브러리 버전 라이브러리를 사용할 때 버전을 x.x+ 형식으로 지정할 경우 x.x대의 최신버전을 사용하라는 뜻입니다. 그런데 이 경우 24시간마다 최신버전을 웹에서 확인하게 되기 때문에 빌드시간이 증가하게 됩니다. 따라서 라이브러리의 버전을 정확히 정해주면 빌드시간을 줄일 수 있습니다.\n1 2 3 4 dependencies { - compile \u0026#39;com.android.support:appcompat-v7:26.+\u0026#39; + compile \u0026#39;com.android.support:appcompat-v7:26.0.0-alpha1\u0026#39; } 이렇게 해서 안드로이드 스튜디오에서 빌드속도를 빠르게하는 여러가지 방법에 대해 알아보았습니다.\n","date":"2021-04-12T19:35:46+09:00","permalink":"https://cliearl.github.io/posts/android/fast-build/","title":"앱 빌드속도 빠르게 하기"},{"content":"이번 포스팅에서는 앱에서 움직이는 GIF를 표시하는 법에 대해 알아보도록 하겠습니다.\n안드로이드에서 이미지를 보여줄때는 화면을 구성하는 xml파일에 ImageView를 올리고 그 이미지뷰에 그림파일을 삽입해주면 됩니다. 이 때 그림파일은 drawable 폴더에 넣어주며 파일이름은 영문소문자 + 언더바로만 구성합니다.\nImageView로 이미지 표시 이미지를 표시하기 위해서는 다음과 같이 imageView의 setImageResource 메소드를 사용합니다. 그런데 이 때 크기가 너무 큰 그림파일은 넣을 수 없고, 움직이는 GIF는 첫번째 프레임만 표시된다는 문제가 있습니다.\n1 imageView.setImageResource(R.drawable.sample00) Glide 사용 하지만 Glide라는 외부 라이브러리를 사용하면 이런 문제를 해결할 수 있습니다.\n이렇게 이미지를 표시하는 라이브러리로는 square의 Picasso나 facebook에서 만든 Fresco도 있습니다.\n특징을 간단하게 설명하자면 picasso는 가벼운 대신 비교적 느리고, glide는 빠르고 사용하기 편하며 fresco는 빠르지만 사용법이 좀 복잡하다는 특징이 있습니다.\n아무튼 사용법은 다음과 같이 간단합니다. with에 액티비티나 프래그먼트를 넣고 load 로 이미지를 호출하면 되는데, load 안에는 로컬 파일뿐만 아니라 웹 이미지도 넣을 수 있습니다.\n1 2 3 4 implementation \u0026#39;com.github.bumptech.glide:glide:4.11.0\u0026#39; // 메인액티비티 Glide.with(this).load(R.raw.sample01).into(imageView) 이렇게 해서 Glide를 사용하는 법에 대해 알아보았습니다.\n","date":"2021-04-08T20:40:50+09:00","permalink":"https://cliearl.github.io/posts/android/imageplugin-glide/","title":"Glide로 앱에서 움직이는 GIF 표시하기"},{"content":"이번 포스팅에서는 날짜와 시간을 다루는 법에 대해 알아보도록 하겠습니다.\n안드로이드의 날짜 라이브러리 날짜를 다루기 위해서는 일반적으로 날짜객체를 만들고 그 날짜객체를 자기가 필요로 하는 양식에 맞춰서 표현하도록 하면 되는데요, 이때 사용할 수 있는 날짜 패턴은 다음 표와 같이 여러가지가 있습니다.\nDate and Time Pattern Result \u0026ldquo;yyyy.MM.dd G \u0026lsquo;at\u0026rsquo; HH:mm:ss z\u0026rdquo; 2001.07.04 AD at 12:08:56 PDT \u0026ldquo;EEE, MMM d, \u0026lsquo;\u0026lsquo;yy\u0026rdquo; Wed, Jul 4, \u0026lsquo;01 \u0026ldquo;h:mm a\u0026rdquo; 12:08 PM \u0026ldquo;hh \u0026lsquo;o\u0026rsquo;\u0026lsquo;clock\u0026rsquo; a, zzzz\u0026rdquo; 12 o\u0026rsquo;clock PM, Pacific Daylight Time \u0026ldquo;K:mm a, z\u0026rdquo; 0:08 PM, PDT \u0026ldquo;yyyyy.MMMM.dd GGG hh:mm aaa\u0026rdquo; 02001.July.04 AD 12:08 PM \u0026ldquo;EEE, d MMM yyyy HH:mm:ss Z\u0026rdquo; Wed, 4 Jul 2001 12:08:56 -0700 \u0026ldquo;yyMMddHHmmssZ\u0026rdquo; 010704120856-0700 \u0026ldquo;yyyy-MM-dd\u0026rsquo;T\u0026rsquo;HH:mm:ss.SSSZ\u0026rdquo; 2001-07-04T12:08:56.235-0700 \u0026ldquo;yyyy-MM-dd\u0026rsquo;T\u0026rsquo;HH:mm:ss.SSSXXX\u0026rdquo; 2001-07-04T12:08:56.235-07:00 \u0026ldquo;YYYY-\u0026lsquo;W\u0026rsquo;ww-u\u0026rdquo; 2001-W27-3 코드 작성 java.util.Date 그럼 우선은 java.util.Date 라이브러리를 이용해서 날짜객체를 만들어 보겠습니다.\n1 2 3 4 5 val utilDate = Date() println(utilDate.toString()) // 출력 Wed Apr 07 06:48:15 UTC 2021 다음은 이 객체의 표현패턴을 바꿔보겠습니다.\n1 2 3 4 5 6 val utilDate = Date() val formatType = SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;) println(formatType.format(utilDate)) // 출력 2021-04-07 06:49:17 java.time 그런데 이 java.util.Date라는 라이브러리는 API level 1 부터 추가된 오래된 라이브러리라 여러 문제도 많고 해서 시간관련 문제를 많이 개선한 java.time 라이브러리를 사용하는 것을 권해드립니다.\n날짜객체를 만든 뒤 포매터로 표시형식을 조정하는 것은 동일합니다.\n1 2 3 4 5 6 7 val date = LocalDateTime.now() val dtf = DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;) val nowString = date.format(dtf) println(nowString) // 출력 2021-04-07 06:57:21 Joda-Time 그런데 문제는 java.time이 API level 26에서 새로 추가된 라이브러리이기 때문에 오레오 미만의 기기에서는 시간을 대응하는 코드를 추가로 준비해야 한다는 점입니다.\n이런 경우에 사용할 수 있는 Joda-Time이라는 라이브러리가 있습니다. Joda-Time은 현재 active하게 개발되진 않지만 API level 26 미만에서 정확한 시간을 사용하기에 적절한 라이브러리입니다.\njava.time과 공유하여 사용하기 위해서는 다음과 같이 안드로이드 버전을 확인하고 버전에 맞는 라이브러리로 timeDate 객체를 만들어주면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // gradle에 추가 implementation \u0026#39;joda-time:joda-time:2.10.10\u0026#39; val timeDate: String if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.O) { val date = LocalDateTime.now() val dtf = DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;) val nowString = date.format(dtf) timeDate = nowString } else { val date = org.joda.time.LocalDateTime.now() val dtf = DateTimeFormat.forPattern(\u0026#34;yyyy-MM-dd\u0026#39;T\u0026#39;HH:mm:ss\u0026#34;) val jodatime = dtf.parseDateTime(date.toString()) val nowString = dtf.print(jodatime) timeDate = nowString } 두 날짜 사이의 차이 계산하기 그러면 다음은 2000년 1월 1일부터 오늘까지 경과한 날수를 계산해보겠습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 val period: Int if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.O) { val startDate = LocalDate.of(2000, 1, 1) val todayDate = LocalDate.now() val differenceDate = startDate.until(todayDate, ChronoUnit.DAYS) + 1 period = differenceDate.toInt() } else { val startDate = org.joda.time.LocalDate(2000, 1, 1) val todayDate = org.joda.time.LocalDate.now() val differenceDate = Days.daysBetween(startDate, todayDate).days + 1 period = differenceDate } 이렇게 해서 날짜와 시간을 다루는 법에 대해 알아보았습니다.\n","date":"2021-04-07T20:32:54+09:00","permalink":"https://cliearl.github.io/posts/android/date-and-time/","title":"Date and Time 다루기"},{"content":"이번 포스팅에서는 Data class를 사용하는 법에 대해 알아보도록 하겠습니다.\nData class의 특징 toString 코틀린에서 클래스를 만들 때는 자바의 클래스 스펙에 따라서 toString, equals, hashCode라는 메소드를 구현해주어야 합니다. 우선 Person이라는 클래스를 만들고 그 인스턴스를 출력해 보겠습니다. 그러면 Person@랜덤 이라는 값이 출력이 되게 됩니다.\n1 2 3 4 5 6 7 class Person(var name: String, var age: Int, var sex: String) val person1 = Person(\u0026#34;Alice\u0026#34;, 20, \u0026#34;Female\u0026#34;) println(person1) // 출력값 org.jetbrains.kotlin.idea.scratch.generated.ScratchFileRunnerGenerated$ScratchFileRunnerGenerated$Person@b6587368 이제 클래스의 toString을 다음과 같이 오버라이드 해주면 랜덤값이 아니라 클래스가 가진 프로퍼티값을 보여주게 됩니다.\n1 2 3 4 5 6 override fun toString(): String { return \u0026#34;Person(name=$name, age=$age, sex=$sex)\u0026#34; } // 출력값 Person(name=Alice, age=20, sex=Female) equals equals는 같은 클래스로부터 인스턴스를 만들었을 때, 클래스 내부의 프로퍼티가 일치하면 같은 인스턴스로 취급할지를 판정하는 메소드입니다. 예를 들어 다음과 같은 인스턴스를 만들어 보면, 두 인스턴스는 동일하지 않다는 판정이 나오게 됩니다.\n1 2 3 4 5 6 val person2 = Person(\u0026#34;Bob\u0026#34;, 22, \u0026#34;Male\u0026#34;) val person3 = Person(\u0026#34;Bob\u0026#34;, 22, \u0026#34;Male\u0026#34;) println(person2 == person3) // 출력값 false 이제 equals를 다음과 같이 오버라이드 해줍니다. 비교대상이 되는 인스턴스를 받아서 그게 null이거나 Person 클래스가 아닐 경우엔 false를 반환하지만, 인스턴스의 프로퍼티가 일치하게 되면 동일한 객체라는 판정을 받게 됩니다.\n1 2 3 4 5 6 7 8 override fun equals(other: Any?): Boolean { if (other == null || other !is Person) return false return name == other.name \u0026amp;\u0026amp; age == other.age \u0026amp;\u0026amp; sex == other.sex } // 출력값 true hashCode hashCode는 인스턴스의 해시값을 정의하는 메소드입니다. 이 부분을 정의하지 않으면 equals의 값이 동일하더라도 서로 다른 객체가 되어버립니다.\n1 2 3 4 5 val person4 = hashSetOf(Person(\u0026#34;Alice\u0026#34;, 20, \u0026#34;Female\u0026#34;)) println(person4.contains(Person(\u0026#34;Alice\u0026#34;, 20, \u0026#34;Female\u0026#34;))) // 출력값 false 그래서 hashCode를 정의하여 동일한 프로퍼티를 가질 경우 동일한 해시값을 갖도록 합니다.\n1 2 3 4 5 6 override fun hashCode(): Int { return name.hashCode() - 1234 + age - sex.hashCode() } // 출력값 true copy copy는 이미 존재하는 인스턴스의 파라미터만을 바꿔서 새로운 객체를 만들어주는 메소드입니다. 이때 복사는 얕은복사로 이루어집니다.\n1 2 val person5 = Person(\u0026#34;Bob\u0026#34;, 22, \u0026#34;Male\u0026#34;) val person6 = person5.copy(name = \u0026#34;Alice\u0026#34;) // Person(name=Alice, age=22, sex=Male) data class 그런데 그냥 프로퍼티만을 가지는 단순한 클래스의 경우 이런 것들을 다 정의해주는 행위가 번거로운 일이기 때문에, 코틀린에서는 Data class라고 하는 새로운 클래스를 준비했습니다. Data class를 사용하면 위에 언급한 메소드를 자동으로 정의하여 주기 때문에 다음과 같이 간단하게 클래스를 만들수 있게 됩니다.\n사용하는 법은 매우 간단한데요, class 앞에 data라는 접두어를 붙여주기만 하면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 data class Person(var name: String, var age: Int, var sex: String) val person1 = Person(\u0026#34;Alice\u0026#34;, 20, \u0026#34;Female\u0026#34;) println(person1) // Person(name=Alice, age=20, sex=Female) val person2 = Person(\u0026#34;Bob\u0026#34;, 22, \u0026#34;Male\u0026#34;) val person3 = Person(\u0026#34;Bob\u0026#34;, 22, \u0026#34;Male\u0026#34;) println(person2 == person3) // true val person4 = hashSetOf(Person(\u0026#34;Alice\u0026#34;, 20, \u0026#34;Female\u0026#34;)) println(person4.contains(Person(\u0026#34;Alice\u0026#34;, 20, \u0026#34;Female\u0026#34;))) // true RecyclerView의 데이터를 data class로 정의하기 그럼 data class를 RecyclerView에 적용해 보도록 하겠습니다.\n여기서는 몬스터의 이름, 종족, 레벨, 그리고 몬스터의 능력치, 만난적이 있는지에 대한 Boolean값을 클래스가 가지도록 하고 그것을 Recyclerview에서 보여주도록 할 건데요, 기존에 다른 필요로 인해 만들어 두었던 RecyclerView를 Swipe, Drag, Touch하기 강의에서 작성했던 앱을 수정하면서 구현해보도록 하겠습니다.\n우선은 몬스터 클래스를 하나 만들어 줍니다. 프로퍼티는 가능한 여러가지의 타입을 가지도록 했습니다. 종족은 선택하기 편하도록 enum을 도입했습니다.\n1 2 3 4 5 6 7 8 9 10 11 data class Monster( val name: String, val race: Race, val level: Int, val stats: List\u0026lt;Int\u0026gt;, val encount: Boolean ) enum class Race { Zombie, Human, Goblin, Dragon } 그리고 기존의 list_item.xml에서 두 개였던 텍스트뷰의 개수를 늘려줍니다. 위에서부터 순서대로 몬스터 클래스의 프로퍼티를 보여주도록 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:paddingStart=\u0026#34;20dp\u0026#34; android:paddingEnd=\u0026#34;20dp\u0026#34; android:id=\u0026#34;@+id/vhLayout\u0026#34; android:background=\u0026#34;?attr/selectableItemBackground\u0026#34; android:gravity=\u0026#34;center_vertical\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;9\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_name\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Monster name\u0026#34; android:textSize=\u0026#34;24sp\u0026#34; android:padding=\u0026#34;3dp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_race\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Race\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_level\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Level\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_stats\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Stats\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_encount\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Encount\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;FrameLayout android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;30dp\u0026#34; android:layout_height=\u0026#34;30dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:src=\u0026#34;@drawable/ic_baseline_reorder_24\u0026#34; /\u0026gt; \u0026lt;/FrameLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; 다음은 RecyclerView Adapter에서 사용하는 데이터셋의 타입을 바꾸고 다른 메소드들도 변화시킵니다. 기존의 setData는 필요없어졌기 때문에 삭제하고, ViewHolder에서 데이터와 텍스트뷰를 바인딩하는 부분도 바뀐 타입에 맞도록 수정해 줍니다. 그리고 데이터를 추가하는 기능을 가진 addData 메소드를 추가해줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class RecyclerViewAdapter: RecyclerView.Adapter\u0026lt;RecyclerViewAdapter.ViewHolder\u0026gt;() { private val dataSet: ArrayList\u0026lt;Monster\u0026gt; = arrayListOf() fun removeData(position: Int) { dataSet.removeAt(position) notifyItemRemoved(position) } fun swapData(fromPos: Int, toPos: Int) { Collections.swap(dataSet, fromPos, toPos) notifyItemMoved(fromPos, toPos) } fun addData(name: String, race: Race, level: Int, stats: List\u0026lt;Int\u0026gt;, encount: Boolean) { dataSet.add(Monster(name, race, level, stats, encount)) notifyItemInserted(dataSet.size) } override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder { val binding = ListItemBinding.inflate(LayoutInflater.from(parent.context), parent, false) return ViewHolder(binding) } override fun onBindViewHolder(holder: ViewHolder, position: Int) { holder.bind(dataSet[position]) } override fun getItemCount(): Int { return dataSet.size } inner class ViewHolder(private val binding: ListItemBinding) : RecyclerView.ViewHolder(binding.root) { fun bind(data:Monster) { binding.tvName.text = \u0026#34;Name: ${data.name}\u0026#34; binding.tvRace.text = \u0026#34;Race: ${data.race}\u0026#34; binding.tvLevel.text = \u0026#34;Level: ${data.level}\u0026#34; binding.tvStats.text = \u0026#34;HP: ${data.stats[0]} / MP: ${data.stats[1]} / Exp: ${data.stats[2]}\u0026#34; binding.tvEncount.text = \u0026#34;Encounted: ${data.encount}\u0026#34; binding.vhLayout.setOnClickListener { Snackbar.make(it, \u0026#34;Item $layoutPosition touched!\u0026#34;, Snackbar.LENGTH_SHORT).show() } } } } 마지막으로 addData 메소드로 MainActivity에서 데이터값을 만들어주면 됩니다.\n1 2 3 4 5 6 7 8 9 override fun onCreate(savedInstanceState: Bundle?) { ... rvAdapter.addData(\u0026#34;타일런트\u0026#34;, Race.Zombie, 10, listOf(100,10,50), false) rvAdapter.addData(\u0026#34;조커\u0026#34;, Race.Human, 23, listOf(200,20,100), false) rvAdapter.addData(\u0026#34;그렘린\u0026#34;, Race.Goblin, 2, listOf(10,1,5), true) rvAdapter.addData(\u0026#34;리오레우스\u0026#34;, Race.Dragon, 2500, listOf(10000,1000,50000), false) rvAdapter.addData(\u0026#34;사우론\u0026#34;, Race.Human, 100, listOf(1000,200,1000),false) rvAdapter.addData(\u0026#34;리바이어던\u0026#34;, Race.Dragon, 50, listOf(2000,250,10000), true) } 이렇게 해서 data class의 특징을 이해하고, RecyclerView에서 활용하는 법에 대해 알아보았습니다.\n","date":"2021-04-06T21:34:00+09:00","permalink":"https://cliearl.github.io/posts/android/dataclass-recyclerview/","title":"Data class 이해하고 RecyclerView에서 사용하기"},{"content":"이번 포스팅에서는 프로젝트의 빌드넘버를 자동으로 증가시키는 법에 대해 알아보도록 하겠습니다.\n버전넘버와 빌드넘버 버전넘버 소프트웨어의 기능이 변할때마다 그것을 구분하기 위해서 버전넘버를 사용하는데요, 일반적인 규칙은 1.0.0 과 같이 세자리로 결정을 합니다.\n첫째자리는 뒤로 되돌릴 수 없는 수준의 큰 변경이 있을때, 둘째자리는 여러가지 새로운 기능이 추가되었을 때 증가를 시키고, 셋째자리는 기능이 추가되지는 않지만 버그가 수정되었을 때 증가를 시킵니다.\n그래서 첫째자리는 메이저 버전, 둘째자리는 마이너 버전, 셋째자리는 패치버전이라고 하는 이름이 있습니다.\n다만 이것은 꼭 지켜야 하는 규칙은 아니고, 날짜를 버전넘버로 사용하는 소프트웨어도 있습니다.\n빌드넘버 빌드넘버란 어떤 버전을 출시할 때 여러번 반복해서 빌드를 할 때마다 숫자를 증가시키는 방법으로 사용하는 숫자인데요, 그러니까 버전넘버가 동일하다고 해도 여러가지 서로다른 빌드넘버를 가질 수 있습니다.\n그래서 빌드를 수행할 때마다 어쨌든 변화가 있어야 되는데, 일반적으로는 증가시키는 형식으로 빌드넘버를 사용을 하구요, 보통은 이 빌드넘버를 일반 사용자가 알 필요가 없기 때문에 이걸 보여주지는 않지만, 개중에는 보여주는 소프트웨어도 있습니다. 윈도우같은 경우는 이 빌드넘버를 프로그램 안에서 확인할 수도 있습니다.\n그런데 이 빌드넘버는 빌드를 수행할 때 하나씩 증가를 시켜야 하는데 안드로이드 스튜디오에서는 이걸 자동으로 증가시켜주지 않기 때문에 이 부분을 자동으로 증가시켜주는 기구를 프로젝트에 적용하는 법에 대해 설명하도록 하겠습니다.\n프로그램 작성 app 레벨의 gradle에서 빌드넘버는 versionCode가 됩니다. 그래서 빌드를 한 번 할 때마다 versionCode는 증가가 되야 하구요, versionName은 기능 추가가 있을때마다 그때그때 개발자가 필요에 의해서 증가를 시켜주면 되겠죠.\n1 2 3 4 5 6 android { defaultConfig { versionCode 1 versionName \u0026#34;1.0\u0026#34; } } 이 versionCode와 versionName을 프로그램 안에서 표시할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 class MainActivity : AppCompatActivity() { private val versionNumber = BuildConfig.VERSION_NAME.replace(\u0026#34;\u0026#39;\u0026#34;, \u0026#34;\u0026#34;) private val versionBuild = BuildConfig.VERSION_CODE override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) textView.text = \u0026#34;App Version: $versionNumber ($versionBuild)\u0026#34; } } 하지만 verionCode를 빌드할때마다 증가시켜주는건 귀찮기 때문에 이 부분을 자동으로 증가시켜주는 기구를 만들어 볼 겁니다.\n일단은 앱 안에 version.properties라는 파일을 만들고 이 파일 안에서 버전넘버와 빌드넘버를 관리할 겁니다.\n1 2 VERSION_NUMBER=\u0026#39;1.0.0\u0026#39; VERSION_BUILD=1 그다음은 app 레벨의 gradle에서 version.properties에 있는 값을 불러와서 빌드넘버를 1 증가시키고 그걸 저장하는 코드를 작성합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 android { // 저장된 값을 불러오는 부분 def versionPropsFile = file(\u0026#39;version.properties\u0026#39;) def versionBuild def versionNumber if (versionPropsFile.canRead()) { def versionProps = new Properties() versionProps.load(new FileInputStream(versionPropsFile)) versionBuild = versionProps[\u0026#39;VERSION_BUILD\u0026#39;].toInteger() versionNumber = versionProps[\u0026#39;VERSION_NUMBER\u0026#39;].toString() } else { throw new FileNotFoundException(\u0026#34;Could not read version.properties!\u0026#34;) } // 읽어온 빌드넘버를 증가시키는 부분 ext.autoIncrementBuildNumber = { if (versionPropsFile.canRead()) { def versionProps = new Properties() versionProps.load(new FileInputStream(versionPropsFile)) versionBuild = versionProps[\u0026#39;VERSION_BUILD\u0026#39;].toInteger() + 1 versionProps[\u0026#39;VERSION_BUILD\u0026#39;] = versionBuild.toString() versionProps.store(versionPropsFile.newWriter(), null) } else { throw new FileNotFoundException(\u0026#34;Could not read version.properties!\u0026#34;) } } // 함수를 실행시키는 부분 gradle.taskGraph.whenReady { taskGraph -\u0026gt; if (taskGraph.hasTask(assembleDebug)) { autoIncrementBuildNumber() } else if (taskGraph.hasTask(assembleRelease)) { autoIncrementBuildNumber() } } compileSdkVersion 29 // 수정한 내용을 앱에 반영해 줌 defaultConfig { applicationId \u0026#34;com.example.autobuildnum\u0026#34; minSdkVersion 21 targetSdkVersion 29 versionCode versionBuild versionName versionNumber testInstrumentationRunner \u0026#34;androidx.test.runner.AndroidJUnitRunner\u0026#34; } } 이제 빌드를 할때마다 빌드넘버가 자동으로 증가하게 됩니다.\n","date":"2021-04-06T19:24:59+09:00","permalink":"https://cliearl.github.io/posts/android/autoset-buildnumber/","title":"프로젝트의 빌드넘버 자동증가 시키기"},{"content":"이번 포스팅에서는 ProgressDialog와 Thread 사용법에 대해 알아보도록 하겠습니다.\nProgressDialog란 ProgressDialog는 안드로이드가 어떤 작업을 진행할때 그 작업의 진행상황과 부가적인 문장을 팝업창으로 보여주는 모듈입니다. 시간이 걸리는 파일 다운로드나 복사를 수행할 때 이런창을 띄워주면 기다리는데 유저의 거부감을 줄일 수 있습니다.\nProgressDialog는 다이얼로그가 표시되는 동안 유저가 다른 조작을 못하게 된다는 이유로 Android 8.0(API level 26)부터는 deprecated 되고 대신 ProgressBar를 사용하도록 권장하고 있습니다.\n\u0026hellip;만, ProgressDialog는 Thread를 설명하는데 좋은 예제이기 때문에 여기서는 ProgressDialog를 구현하면서 Thread에 대해 이해해 보도록 하겠습니다\n스레드란 컴퓨터 하드에 저장된 프로그램을 실행하면 운영체제는 프로그램을 메모리에 로딩하고 실행시킵니다. 이 때 메모리로 올라가 실행되고 있는 프로그램을 프로세스라고 합니다. 그리고 프로세스 안에서 실행되는 여러가지 작업 흐름을 각각 스레드라고 합니다.\n안드로이드로 예를 들면 스마트폰 안에 저장된 유튜브앱은 프로그램이고 앱을 실행시키면 메모리에 유튜브 프로세스가 새로 하나 생성됩니다. 유튜브에는 앱을 보고있는 동안 계속 메뉴화면을 표시하는 스레드가 생기고 동영상을 선택했을 때 유튜브 서버에서 동영상을 다운로드하는 또 하나의 스레드가 생기게 되는 식입니다.\n안드로이드에서 앱을 실행했을 때 처음으로 시작되는 스레드를 메인 스레드라고 합니다. 메인 스레드는 화면을 표시하고 버튼이나 텍스트뷰에 대한 조작이 이루어졌을 때 그 처리를 담당합니다.\n이 때 예를들어 ProgressDialog로 1초에 10%씩 증가하는 다운로드 진행상황을 표시한다고 합시다. 0% 를 표시하고 1초 후에 10%, 2초후에 20%.. 를 표시해야 하는거죠.\n그런데 메인 스레드에서 이 처리를 하게되면 진행상황을 표시하지 않는 1초의 인터벌시간동안 메인스레드가 멈춰서 1초동안 기다리고 있어야 합니다. 그 동안 UI처리는 수행할 수 없게 되죠.\n그래서 ProgressDialog의 처리는 메인스레드와는 별개로 동작하는 백그라운드 스레드를 추가로 만들어서 구현하게 됩니다.\n프로그램 작성 그럼 버튼을 터치하면 진행율이 0.2초당 10%씩 증가하는 ProgressDialog를 만들어 보면서 Thread를 구현해 보겠습니다.\nView binding 처리 View Binding 처리를 해 줍니다.\n1 2 3 4 5 build.gradle android { buildFeatures.viewBinding true } ProgressDialog 준비 메인액티비티 안에 ProgressDialog용 전역변수를 만들어줍니다.\n1 private lateinit var progressDialog: ProgressDialog 버튼을 터치했을때 다이얼로그가 표시되게 할 것이므로 버튼의 클릭리스너 안에서 ProgressDialog를 설정합니다.\n1 2 3 4 5 6 7 progressDialog = ProgressDialog(this) progressDialog.max = 100 progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL) progressDialog.setTitle(\u0026#34;Download Task\u0026#34;) progressDialog.setMessage(\u0026#34;Please wait, we are downloading your files...\u0026#34;) progressDialog.setCancelable(false) progressDialog.show() 스레드와 핸들러 한 프로세스 안에서 여러개의 스레드를 사용하게 되면 서로다른 스레드가 버튼이나 텍스트뷰 등의 UI 컴포넌트에 동시에 접근하는 문제가 생길 수 있습니다. 안드로이드에서는 이것을 막기 위해 처리흐름 중간에 Looper와 Handler를 끼워 넣었습니다.\n스레드는 수행해야 할 UI 작업이 발생하면 Message 또는 Runnable을 만들어내고 이걸 Message queue에 담습니다. Looper는 무한히 루프를 돌며 Message queue속의 객체를 핸들러에 전달합니다. Handler는 메시지를 받으면 운영체제가 정해주는 타이밍에 따라 UI조작을 수행하게 되므로 UI요소에 대한 동시접근을 막을 수 있게 됩니다.\n핸들러 구현 스레드에서 사용할 핸들러 객체는 다음과 같이 만들어 줍니다. handleMessage 메소드를 오버라이드하여 그 안에 수행할 UI작업을 작성하면 됩니다.\n1 2 3 4 5 6 val handler: Handler = object : Handler() { override fun handleMessage(msg: Message) { super.handleMessage(msg) progressDialog.incrementProgressBy(10) } } 코틀린에서 스레드 사용 코틀린에서 스레드를 사용하는 방법은 Thread 클래스를 상속받아 스레드를 직접 구현하는 법, 그리고 Runnable 인터페이스로 구현하는 법이 있습니다. 여기서는 스레드 클래스를 변경할 필요가 없기 때문에 간편하게 구현할 수 있는 Runnable 인터페이스를 사용하겠습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 Thread { try { while (progressDialog.progress \u0026lt;= progressDialog.max) { Thread.sleep(200) handler.sendMessage(handler.obtainMessage()) if (progressDialog.progress == progressDialog.max) { progressDialog.dismiss() } } } catch (e: Exception) { e.printStackTrace() } }.start() 쓰레드에서는 매 루프마다 현재 progress 값을 체크하고 그 값이 최대값보다 작으면 핸들러에 메시지를 보냅니다. 이 때 Thread.sleep을 이용해 0.2초 간격으로 스레드를 정지시킵니다.\n메모리 리크 방어하기 메인 루퍼 이용하기 이렇게 해서 프로그레스다이얼로그를 구현하였습니다. 그런데 핸들러 객체에 하이라이트 된 부분을 보면 This Handler class should be static or leaks might occur 라는 경고가 표시됩니다. 앞에서 설명했듯이 모든 스레드는 각자의 개별 Looper를 가지게 됩니다. 그런데 핸들러가 백그라운드 스레드에 의해 만들어진 루퍼를 사용할 경우, 메시지큐에 메시지가 남아있으면 액티비티가 종료되도 죽지않고 살아있게 됩니다. 그래서 메모리누수가 일어날 수 있다는 경고가 발생하는 것입니다.\n그래서 핸들러가 백그라운드 스레드의 Looper가 아닌 메인 스레드의 Looper를 사용하게 하면 핸들러의 수명은 액티비티가 종료될 때 같이 종료되게 되므로 경고메시지가 사라지게 됩니다. 그렇게 하기 위해서는 핸들러를 만들 때 메인 스레드의 루퍼를 전달해주면 됩니다.\n1 2 3 4 5 6 val handler: Handler = object : Handler(Looper.getMainLooper()) { override fun handleMessage(msg: Message) { super.handleMessage(msg) progressDialog.incrementProgressBy(10) } } 그러면 메모리 리크 경고가 사라진 것을 알 수 있습니다.\n약한참조 이용하기 메모리 리크는 핸들러 클래스를 새로 만들어 주는 방식을 통해 방지할 수도 있습니다.\n자바에서는 객체간의 관계를 다음과 같이 구분하는데, 메모리 확보를 위해 가비지 컬렉터가 작동하면 강한참조는 무시되고 약한참조를 가진 객체만 삭제되게 됩니다.\nStrong reference Soft reference Weak reference Phantom reference 현재 구현한 코드대로라면 핸들러가 메인액티비티에 대해 강한참조를 가지게 되므로 액티비티가 종료되어도 핸들러 객체에 대해 가비지 컬렉터가 작동하지 않게 되어 메모리 리크가 발생하게 됩니다.\n따라서 메모리 리크를 방지하기 위해서는 핸들러를 메인 액티비티에 대한 참조를 가지지 않는 정적 클래스로 만들면 됩니다.\n핸들러 정적 클래스화 코틀린에서 만들어지는 클래스는 기본적으로 static 이므로 핸들러 클래스를 다음과 같이 만들어서 사용하면 됩니다.\n1 2 3 4 5 6 7 val handler = MyHandler() private class MyHandler() : Handler() { override fun handleMessage(msg: Message) { } } 클래스 약한참조화하기 그런데 정적인 핸들러 클래스를 만들었지만 우리가 사용할 핸들러는 액티비티의 progressDialog를 참조하여야 하므로 다시 참조가 생기게 됩니다, 따라서 WeakReference 를 이용해서 이를 약한참조로 만들어 줍니다.\n1 2 3 4 5 6 7 8 9 10 11 private class MyHandler(activity: MainActivity?) : Handler() { private val weakReference: WeakReference\u0026lt;MainActivity\u0026gt; = WeakReference(activity) override fun handleMessage(msg: Message) { val activity = weakReference.get() if (activity == null || activity.isFinishing) return activity.progressDialog.incrementProgressBy(10) } } 이렇게 하면 핸들러를 약한 참조로 하면서 액티비티의 참조를 가져올 수 있습니다. 이렇게 ProgressDialog를 구현해 보면서 Thread에 대해 이해해 보았습니다.\n","date":"2021-04-05T22:20:49+09:00","permalink":"https://cliearl.github.io/posts/android/progressdialog-thread/","title":"ProgressDialog로 Thread와 Handler 이해하기"},{"content":"패스워드 매니저는 웹브라우저에서 아이디와 패스워드를 자동으로 넣어주는 프로그램입니다.\n들어가기 저는 패스워드 매니저로 LastPass를 사용하고 있었습니다. 과거에 해킹당한 적도 있었지만 그 이후 큰 이슈가 없었고 사용하기 편해서 계속 사용하고 있었습니다.\n크롬, 파이어폭스, 사파리, 엣지, 오페라 등의 여러 브라우저에서 작동하며 안드로이드, iOS, 윈도우, 맥을 지원하고 터치ID도 대응하기 때문에 여러 장치사이에서 동기화하며 잘 사용하고 있었습니다\u0026hellip;만 LastPass의 무료이용자에 대한 정책이 2021년 3월 16일부터 변경 되었습니다.\n그 내용은 컴퓨터 혹은 모바일 기기 둘 중 하나에서만 자유롭게 사용하게 할 것이고 양쪽 모두에서 사용하고 싶다면 한달에 3달러인 프리미엄 플랜에 가입해야 한다는 것 입니다. 그 덕분에 LastPass 파이어폭스 플러그인은 별점 테러를 먹고 있는 중입니다.\n성능이 나쁘지 않은것도 있었지만 LastPass의 가장 큰 장점 중 하나는 무료로 사용이 가능하다는 점이었기 때문에 갈아탈 때가 된 것 같다는 생각이 들었습니다.\n이것저것 찾아봤는데 복수의 기기에서 무료로 이용할 수 있게 해주는 자비로운 서비스는 존재하지 않았고, 거의 대부분이 서비스를 유료플랜으로 제공하고 있었습니다.\nLastpass 대체서비스 서비스 무료 플랜 파폭 플러그인 Bitwarden 모든 기기, 암호 무제한 있음 Dashlane 기기 한대, 암호 50개 없음 LastPass 기기 한 종류, 암호 무제한 있음 NordPass 모든 기기, 암호 무제한 있음 Roboform 기기 한대, 암호 무제한 있음 이 중 모든기기에서 사용 가능한건 Bitwarden과 NordPass인데 NordPass는 파이어폭스 플러그인의 평이 그리 좋지 않습니다. 거기다 이 서비스도 언제 유료화 할지 모르니 오픈소스로 개발되는 Bitwarden을 사용하기로 결정했습니다. 파이어폭스 플러그인의 평도 좋고 인터넷에서의 평도 나쁘지 않은것 같습니다.\nBitwarden Bitwarden의 경우 세 가지 사용방법이 있습니다\n공식 홈페이지에 가입하여 사용. Bitwarden에서 공개하는 코드를 개인용 서버에 Docker로 올려서 사용. 공식 도커이미지는 요구하는 서버 스펙이 높습니다. 그래서 이 것을 저사양 서버에서도 돌아가도록 개인이 개수한 vaultwarden이라는 것이 있는데 이걸 도커로 사용. 개인이 쓸 거면 vaultwarden 를 사용하는것만으로 아마 충분하겠지만 역시 개인 프로젝트는 언제 어떤식으로 중단될 지 알 수 없고 그 경우 관리상 여러가지 곤란한 점이 생길 수 있습니다.\n현재로서는 소스를 퍼블릭 공개하고 있는 Bitwarden 회사가 나의 패스워드를 함부로 다루지 않을 것이라는 믿음을 가져보기로 했고 그렇다면 보안의 관점에서 볼 때 개인용 NAS에 보관하는 것 보다는 회사 서버에 보관하는 것이 더 낫다고 생각해서 공식 홈페이지에 가입하여 서비스를 사용해 보기로 했습니다.\n또 공식서버에서 운용하다가 뭔가 맘에 안드는 점이 있다면 그때가서 개인 NAS로 옮겨도 될 것 같네요.\n","date":"2021-03-24T23:03:54+09:00","permalink":"https://cliearl.github.io/posts/etc/password-manager/","title":"패스워드 매니저 교체기"},{"content":"지금까지 사용하던 녹음환경을 개선하였습니다.\n들어가기 지금까지는 음성녹음을 위해 애플 이어팟을 맥북에 연결하여 마이크로 사용하고 있었습니다. 핸즈프리인것 치고는 마이크 성능이 나쁘지 않았는데요, 최근 맥북에서 녹음할 때 드라이버 충돌이 있었는지 목욕탕에서 녹음하는것처럼 소리가 울리는 문제가 발생했기에 새로 마이크를 들이기로 했습니다.\n컨셉은 20만원대에서 믹서없이 사용할 수 있는 USB 콘덴서마이크였습니다.\n검토한 마이크들 NT-USB https://ko.rode.com/microphones/nt-usb 워낙 평도 좋고 가성비도 좋아서 눈여겨보고있던 마이크였는데 최근에 가격이 좀 올랐습니다. NT-USB Mini NT-USB에 비하면 해상도가 24비트로 더 높고 연결단자가 USB-C라는 장점이 있으나 팝필터가 내장이라는 점이 별로였네요. 다만 유튜브에서 찾아보니 음질은 나쁘지 않았습니다. Blue Yeti X https://www.bluemic.com/ko-kr/products/yeti-x/ 스펙도 훌륭하고 녹음패턴도 4가지나 가지고 있어 게스트를 두고 녹음하는 것도 가능하다. 소리크기에 LED가 반응하는것도 이쁘고 유튜브에서 청음해보니 음질도 좋은 편이다. 마이크 컨트롤용 앱도 잘 만들어놓은것 같았다. AT-2020USB+ https://www.audio-technica.com/en-us/at2020usb 실 사용기를 보면 폴라패턴이 좀 넓은듯한데 그래도 훌륭한 마이크인것 같다. 그래서 구입한 장비 (뒷광고 아닙니다!) RODE NT-USB 여러가지 비교포인트는 있었는데 마이크별로 극적인 차이는 없었습니다. 결국 바다씨의 speechless를 듣고 NT-USB를 구입해버렸습니다\u0026hellip; 흠\u0026hellip; 아리스노보 UMA-RF03 리플렉션 필터 https://smartstore.naver.com/arsnovo/products/4609145421 환경개선 비교 20만원대 마이크를 2만5천원짜리 핸즈프리와 비교하는것은 이어팟에 너무 가혹한 일이지만 한번 비교를 해보겠습니다.\n우선은 화이트노이즈가 개선되었습니다. 이어팟은 목소리 자체는 비교적 깨끗하게 잡아주지만, 화이트노이즈가 꽤 큰편인데 로데로 교체하면서 화이트노이즈가 많이 사라졌습니다.\n이어팟이 옷과 부딪힐때 나는 잡음이 사라졌습니다. 타이핑이나 마우스를 조작하다보면 이어팟의 볼륨조절버튼이 옷에 부딪히면서 바스락거리는 잡음이 수음되곤 했는데 마이크를 암 스탠드에 거치하고 책상과 이격시키면서 옷에서 나는 잡음을 잡았습니다. 또 키보드를 두드릴 때와 마우스를 들었다놨다 할때 책상에 전해지는 소음도 억제할 수 있게 되었습니다.\n반향음을 억제할 수 있게 되었습니다. 기존에는 무료로 대여할 수 있는 녹음실에서 녹음을 했었는데 이 방은 방음처리가 잘 되어 있어서 외부에서 들어오는 잡음이나 반향음을 신경 쓸 필요가 없었습니다. 그런데 코로나로 녹음실을 사용할 수 없게 되면서 집에서 녹음했더니 반향음이 있었습니다. 하지만 이번에 마이크를 구매하면서 같이 구입한 리플렉션필터 덕분인지 반향음이 잘 잡히게 되었습니다.\n목소리를 모니터링할수 있게 되었습니다. 이어팟으로 녹음할 때는 어디서 소음이 잡히는지 내 목시리가 어떻게 녹음되고 있는지 알 길이 없었습니다. 하지만 마이크의 모니터링단자에서 목소리를 확인하면서 녹음하니 노이즈가 들어가거나 입이 마이크에서 좀 떨어져있구나 하는 것들을 실시간으로 확인할 수 있어서 작업이 수월해졌습니다.\n마이크 성능이 좋다보니 ASMR도 됩니다. 마지막으로 서정시 한편을 읽으며 마치겠습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 어둠에다크에서 죽음의데스를 느끼며 서쪽에서 불어오는 바람의윈드를 맞았다. 그것은 운명의데스티니. 그는 인생의 라이프를 끝내기 위해 디엔드. 모든것을 옭아매는 폭풍같은 스톰에서 벗어나기 위해 결국 자신 스스로를 죽음에데스로 몰아갔다. 후에 전설의 레전드로써 기억에 메모리- 기적에미라클 길이길이 가슴속의하트에 기억될 리멤버. 끝에 Fin ","date":"2021-03-22T18:44:42+09:00","permalink":"https://cliearl.github.io/posts/etc/changemic/","title":"녹음용 마이크 교체기"},{"content":"이번 포스트에서는 작성된 코드의 교열을 보는 방법에 대해 알아보도록 하겠습니다.\n들어가기 우리가 작성하는 코드는 기본적으로는 컴퓨터에게 명령을 내리기 위한 것이고 그 명령은 각 언어의 문법에 따라 작성되어져야 합니다.\n코틀린에서 상수 두 개를 만들고 그 상수를 더하는 명령은 다음과 같이 쓸 수 있습니다.\n1 2 3 4 val a = 3 val b = 4 val c = a + b println(c) 자 그럼 이번엔 코드 안에서 띄어쓰기의 방식을 다르게 해보겠습니다.\n1 2 3 4 val a= 3 val b = 4 val c= a+ b println(c) 각 줄마다 띄어쓰기의 방식이 다르다고 해도 컴퓨터는 코드를 문제없이 컴파일 할 수 있습니다. 그럼 코드를 이렇게 써도 문제없이 작동하니 괜찮은걸까요?\n내가 작성한 코드를 내 동료가 검토할 수도 있고, 몇 년후 내가 더 이상 코드를 관리하지 않게 되었을 때 내 후임이 코드를 읽어야 할 일이 생길 수 있습니다. 또 다음주쯤에 내 스스로가 내가 작성한 코드를 다시 읽어야 할 일도 생길 수 있죠.\n코드는 나와 컴퓨터의 대화이기도 하지만, 나와 다른 사람과의 대화이기도 합니다. 따라서 컴파일이 되게 문법을 맞추는 것 뿐만 아니라, 사람이 보기 좋도록 코드의 구조도 이쁘게 만드는 것이 좋습니다.\n프로그래머들 사이에서는 코드가 이쁘다고 느끼게 하는 어느정도 일반적으로 받아들여지는 정도의 수준이 있고 이걸 정리한 것을 코드 컨벤션이라고 합니다.\nktlint 코드 컨벤션의 형태는 언어별로 다른데 코틀린의 경우 다음과 같은 규약이 정의되어 있습니다.\nKotlin style guide Coding conventions 이 수많은 규약들을 머리에 넣어두고 잘 지킬 수 있다면 문제가 없겠지만 실제 코딩을 하다보면 이런 것들을 모두 신경쓰면서 코드를 쓸 수가 없습니다. 그래서 각 언어에는 린트 혹은 린터라고 불리는 도구가 있습니다.\n린트는 과거에 C언어의 소스코드를 검사하기 위해 만들어진 유틸리티의 이름인데요. 현재는 동일한 작업을 하는 도구들을 모두 린트라고 부르고 있습니다.\n코틀린의 대표적인 린트 툴로는 ktlint, detekt 등이 있는데요, 이번 영상에서는 복잡한 설정을 하지 않고 편하게 사용할 수 있는 ktlint의 사용법에 대해 설명하도록 하겠습니다.\nktlint는 다음과 같은 컨벤션 오류를 체크하고 자동으로 컨벤션에 맞게 코드를 수정해주는 기능이 있습니다\nhttps://ktlint.github.io/#rules 실제로는 이것뿐만 아니라 체크되는 더 많은 룰이 있습니다.\nhttps://github.com/pinterest/ktlint#standard-rules ktlint 사용법 ktlint는 그 자체를 프로젝트에 삽입해서 사용해도 되지만 래퍼 라이브러리를 사용하면 더 간편하게 사용할 수 있습니다. ktlint의 래퍼는 여러가지가 있는데 여기서는 커밋이 활발하게 이루어지는 ktlint-gradle을 사용하겠습니다.\n우선 라이브러리를 project 레벨의 gradle에 플러그인으로 추가합니다.\n1 2 3 4 5 6 7 8 9 10 11 buildscript {...} plugins { id \u0026#34;org.jlleitschuh.gradle.ktlint\u0026#34; version \u0026#34;10.0.0\u0026#34; } allProjects {...} subprojects { apply plugin: \u0026#34;org.jlleitschuh.gradle.ktlint\u0026#34; } 이렇게 설정하면 모든 프로젝트의 task에 다음과 같은 작업이 추가됩니다. 추가된 task들은 오른쪽 메뉴의 gradle에서 확인가능하며 그 외 모든 task의 리스트는 링크에서 확인 가능합니다.\nloadKtlintReporters - preloads KtLint Reporters runKtlintCheckOverKotlinScripts - runs actual lint check over project Kotlin script files ktlintKotlinScriptCheck - generates reports and prints issues into Gradle console based on lint check found errors. This task execution depends on loadKtlintReporters and runKtlintCheckOverKotlinScripts tasks execution outputs runKtlintFormatOverKotlinScripts - tries to format according to the code style project Kotlin script files ktlintKotlinScriptFormat - generate reports and prints issues into Gradle console based on found non-formattable errors. This task execution depends on loadKtlintReporters and runKtlintFormatOverKotlinScripts tasks execution outputs ktlintCheck - checks all SourceSets and project Kotlin script files ktlintFormat - tries to format according to the code style all SourceSets Kotlin files and project Kotlin script files task가 추가되었으면 터미널에서 실행합니다.\n1 2 ./gradlew ktlintCheck // 로 틀린부분을 체크받고 ./gradlew ktlintFormat // 로 자동수정을 할 수 있습니다. ktlintcheck를 수동으로 수행하는 것이 귀찮다면 다음 명령으로 커밋할때마다 ktlintcheck가 실행되게 할 수 있습니다.\n1 ./gradlew addKtlintCheckGitPreCommitHook ktlint를 이용해서 코드 컨벤션에 맞는 코드를 생산하는 법에 대해 알아보았습니다. 중요한 것은 코드 컨벤션을 지키지 않아도 컴파일은 정상적으로 수행되지만, 이 코드를 언젠가 다시 읽게 될 나와 다른 사람을 위해 코드 컨벤션을 지켜야 한다는 점입니다.\n","date":"2021-03-21T18:07:38+09:00","permalink":"https://cliearl.github.io/posts/android/use-ktlint/","title":"ktlint로 코틀린 코딩 컨벤션 검토하기"},{"content":"기술블로그 엔진을 Hexo에서 Hugo로 바꾸어 보았다.\nHexo에 Icarus 태그를 씌우고 도커에 올려서 잘 쓰고 있었는데 내가 사용한 도커 이미지는 업뎃이 안된다는 문제가 있었다. https://github.com/spurin/docker-hexo\n그래서 비슷한 엔진인 Hugo를 찾아보았는데 Hugo의 도커 이미지는 관리가 잘 되고 있었다. https://hub.docker.com/r/klakegg/hugo/\n근데 이상하게도 이 이미지를 비롯한 모든 hugo의 도커 이미지는 내 시놀로지 환경에서 실행이 안됐다. 짜증나기도 하고 이왕 이렇게 된거 로컬에서 실행하기로 했다. 맥북에서 하면 brew를 사용하기 때문에 업뎃도 쉬워서 관리가 편하다. hexo가 brew로 관리가 안된다는 점도 hugo로 온 이유중에 하나. Go를 쓰니까 빠르다는 점은 그렇게까진 다가오지 않았다.\nhugo 초기화 1 2 $ brew install hugo // hugo를 인스톨 $ hugo new site [생성할 폴더 이름] 깃 준비 1 2 3 4 5 6 $ cd cliearl.github.io $ git init $ git remote add origin [https://hugo 원본파일을 보관할 저장소] $ git submodule add [https://hugo가 생성한 사이트를 업로드할 저장소] public $ git submodule add [테마 깃주소.git] themes/zzo $ git submodule update --init --recursive // 테마가 업데이트 될 경우 반영 글 작성 후 확인 1 2 $ hugo new posts/test.md // 새로운 글 작성 $ hugo server // 만들어진 정적사이트를 localhost:1313에 띄워줌 페이지 작성 후 업로드 1 2 3 4 5 $ hugo -t [테마이름] // 정적사이트 생성 $ cd public $ git add . $ git commit -m \u0026#34;deploy updates\u0026#34; $ git push origin main 커밋 자동화 스크립트 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #!/bin/bash echo -e \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\u0026#34; # Build the project. hugo -t zzo # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin main # Come Back up to the Project Root cd .. # blog 저장소 Commit \u0026amp; Push git add . msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; git push origin master 검색엔진에 등록 Google Search Console Google Search Console에 접속 속성 추가 후 URL 접두어에서 github.io 주소 입력 HTML파일로 확인 선택 -\u0026gt; 파일 다운로드 hugo의 public 폴더에 복사하면 루트에 업로드 됨 소유권 확인됨 config.toml 수정 1 2 3 4 5 6 7 # 로봇 검색 허용 enableRobotsTXT = true # 사이트맵 작성 [sitemap] changefreq = \u0026#34;daily\u0026#34; filename = \u0026#34;sitemap.xml\u0026#34; 서치콘솔에 등록 Sitemaps 메뉴에서 \u0026hellip;/sitemap.xml을 등록.\n","date":"2021-03-04T22:24:02+09:00","permalink":"https://cliearl.github.io/posts/linux/hugo-blog/","title":"Hexo에서 Hugo로 블로그 엔진 변경"},{"content":"내가 사용하는 파이어폭스 플러그인을 정리해 보았다.\nAuto Tab Discard https://addons.mozilla.org/ko/firefox/addon/auto-tab-discard/\n안보고 있는 탭을 자동으로 정리해서 메모리 사용량을 줄여줌. Bitwarden https://addons.mozilla.org/ko/firefox/addon/bitwarden-password-manager/\n패스워드 매니저. Clear Cache https://addons.mozilla.org/en-US/firefox/addon/clearcache/\n캐시삭제 버튼을 만들어 줌. Dark Reader https://addons.mozilla.org/ko/firefox/addon/darkreader/\n모든 웹사이트에 다크모드를 적용하여 어둡게 보이도록 함. Download Filename Encoding https://addons.mozilla.org/ko/firefox/addon/download-filename-encoding/\n다운로드하는 파일명이 언어 인코딩 때문에 깨지는 것을 방지. Download Manager (S3) https://addons.mozilla.org/ko/firefox/addon/s3download-statusbar/\n다운로드 진행상황을 상태표시줄에 표시해줌. DownThemAll! https://addons.mozilla.org/ko/firefox/addon/downthemall/\n대량의 파일을 다운로드해주는 관리자. Enhancer for YouTube https://addons.mozilla.org/ko/firefox/addon/enhancer-for-youtube/\n유튜브 영상의 반복, 고정등 여러가지 기능을 추가해 줌. Flagfox https://addons.mozilla.org/ko/firefox/addon/flagfox/\n현재 접속중인 서버의 위치를 국기로 표시해 줌. Gesturefy https://addons.mozilla.org/ko/firefox/addon/gesturefy/\n마우스 제스처로 브라우저를 조작할 수 있게 함. Google search link fix https://addons.mozilla.org/ko/firefox/addon/google-search-link-fix/\n구글을 통해 검색한 사이트의 링크를 복사할 때 구글 리퍼러가 붙는것을 막아줌. Happy Right-Click https://addons.mozilla.org/ko/firefox/addon/%E5%BF%AB%E4%B9%90%E5%8F%B3%E9%94%AE/\n마우스 오른쪽 버튼이 막혀있는 사이트를 풀어줌. Imagus https://addons.mozilla.org/ko/firefox/addon/imagus/\n이미지나 동영상에 커서를 갖다 대었을 때 호버링으로 크게 보여줌. ImTranslator https://addons.mozilla.org/ko/firefox/addon/imtranslator/\n팝업 형태로 번역기를 사용할 수 있게 해줌. Open With https://addons.mozilla.org/ko/firefox/addon/open-with/\n현재 보고있는 웹페이지를 다른 브라우저로 띄워줌. Print Edit WE https://addons.mozilla.org/ko/firefox/addon/print-edit-we/\n웹 페이지에서 자신이 원하는 부분만 잘라내서 프린트하도록 도와줌. Quick Dial https://addons.mozilla.org/ko/firefox/addon/quick-dial/\n시작 페이지에 자주가는 웹사이트를 버튼형태로 표시해 줌. Toolbar Clock https://addons.mozilla.org/ko/firefox/addon/toolbar-clock/\n상태표시줄에 아날로그 시계를 표시해 줌. Top and Bottom scroll buttons https://addons.mozilla.org/ko/firefox/addon/top-and-bottom-scroll-buttons/\n사이트의 맨 위 / 맨 아래로 이동하는 버튼을 표시. uBlock Origin https://addons.mozilla.org/ko/firefox/addon/ublock-origin/\n자원을 덜 먹는다고 선전하는 광고차단기. Undo Close Tab https://addons.mozilla.org/ko/firefox/addon/undoclosetabbutton/\n최근에 닫은 탭을 다시 여는 버튼을 표시. View Image https://addons.mozilla.org/ko/firefox/addon/view-image/\n구글에서 이미지를 검색할 때 이미지 보기 버튼을 추가함. Wappalyzer https://addons.mozilla.org/ko/firefox/addon/wappalyzer/\n현재 보는 중인 사이트애 적용된 웹 기술을 보여줌. weAutoPagerize https://addons.mozilla.org/ko/firefox/addon/weautopagerize/\n현재 보고있는 페이지의 다음 페이지를 미리 읽어서 현재 페이지에 연결시켜줌. Zoom Page WE https://addons.mozilla.org/ko/firefox/addon/zoom-page-we/\n페이지 줌을 편하게 할 수 있는 버튼을 추가함. Zotero Connector https://www.zotero.org/download/\n서지정보 관리 프로그램인 Zotero와 브라우저를 연동시켜 줌. ","date":"2021-02-02T02:11:13+09:00","permalink":"https://cliearl.github.io/posts/etc/firefox-plugin/","title":"내가 사용하는 Firefox Plugin"},{"content":"윈도우, Mac, 스마트폰에서 모두 사용할 수 있는 메모 앱을 찾아봤다. 마크다운 포맷을 사용할 수 있으면서 메모를 디렉토리로 관리할 수 있을 것이 조건이었다.\n스탠드얼론 앱 iOS 메모 앱 https://support.apple.com/ko-kr/HT205773\n아이폰을 사용하고 있기에 처음에는 아이폰의 메모 앱을 사용해 봤으나 별 기능도 없고 아이클라우드환경은 윈도우 환경에서 싱크할 수가 없다는 한계가 있었다.\nGoogle Keep https://apps.apple.com/us/app/google-keep-notes-and-lists/id1029207872\n구글 생태계에서 사용할 수 있는 메모 앱. 워드프로세서로 사용하는 느낌이 아닌 포스트잇 같은 느낌으로 사용한다. 개인적 용도와는 맞지않아서 패스함.\nSynology Note Station https://www.synology.com/en-us/dsm/feature/note_station\n시놀로지를 운영할 경우 사용할 수 있는 솔루션. 디렉토리 구성으로 되어있고 필기도 할 수 있는데 초기 로그인 화면이 크게 나타나는게 팬시하지 않고 데이터 싱크가 느리다.\njoplin https://github.com/laurent22/joplin\niOS, 안드로이드, 윈도우, Mac, 리눅스에서 사용할 수 있는 앱을 제공하며 DB는 webdav로 싱크할 수 있다. 메모는 디렉토리로 관리할 수 있다. 오픈소스로 활발하게 업데이트가 이루어진다. 딱 하나 단점은 웹앱이 없어서 브라우저에서 접근이 안된다는 것.\n웹 앱 오픈소스이며 액티브하게 갱신되고 도커이미지가 있는 것을 기준으로 하여 실제로 써본 것들만을 소개한다.\nTrillium Notes https://github.com/zadam/trilium\n자바스크립트로 만들어진 앱. 마크다운 스크립트를 입력하면 실시간으로 화면에 반영되는 위지위그 방식. 메모를 디렉토리 기준으로 관리하며 글만이 아니라 관계도도 그릴 수 있고 암튼 사용할 수 있는 문서형태가 다양하다.\nBookStack https://github.com/BookStackApp/BookStack\nPHP와 라라벨로 만들어진 앱. 메모를 서고와 서가형태로 관리하는데 개인적으로는 이 부분이 직관적으로 느껴지지 않아서 적응하지 못했다.\nWiki.js https://github.com/Requarks/wiki\nNode.js로 만들어진 앱. 메모를 디렉토리 구조로 관리하며 퍼포먼스도 나쁘지 않아 현재 주력으로 사용중.\n","date":"2021-01-16T13:18:57+09:00","permalink":"https://cliearl.github.io/posts/etc/finding-note-app/","title":"노트 앱 정착기"},{"content":"내가 사용하는 VS Code의 settings.json 내용\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 { \u0026#34;files.autoSave\u0026#34;: \u0026#34;afterDelay\u0026#34;, \u0026#34;editor.fontSize\u0026#34;: 18, \u0026#34;editor.fontFamily\u0026#34;: \u0026#34;\u0026#39;Fira Code\u0026#39;, \u0026#39;Noto Sans CJK KR\u0026#39;\u0026#34;, \u0026#34;editor.fontLigatures\u0026#34;: false, \u0026#34;editor.renderWhitespace\u0026#34;: \u0026#34;boundary\u0026#34;, \u0026#34;editor.wordWrap\u0026#34;: \u0026#34;on\u0026#34;, \u0026#34;editor.wrappingIndent\u0026#34;: \u0026#34;indent\u0026#34;, \u0026#34;editor.rulers\u0026#34;: [ 100, 120 ], \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;git.autofetch\u0026#34;: true, \u0026#34;git.confirmSync\u0026#34;: false, \u0026#34;git.postCommitCommand\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;python.formatting.provider\u0026#34;: \u0026#34;black\u0026#34;, \u0026#34;python.languageServer\u0026#34;: \u0026#34;Microsoft\u0026#34;, \u0026#34;python.linting.pylintEnabled\u0026#34;: false, \u0026#34;python.linting.pylintPath\u0026#34;: \u0026#34;pylint\u0026#34;, \u0026#34;terminal.integrated.shell.windows\u0026#34;: \u0026#34;C:\\\\WINDOWS\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe\u0026#34;, \u0026#34;code-runner.runInTerminal\u0026#34;: true, \u0026#34;code-runner.executorMap\u0026#34;: { \u0026#34;javascript\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;php\u0026#34;: \u0026#34;php\u0026#34;, \u0026#34;python\u0026#34;: \u0026#34;$pythonPath -u $fullFileName\u0026#34;, \u0026#34;perl\u0026#34;: \u0026#34;perl\u0026#34;, \u0026#34;ruby\u0026#34;: \u0026#34;ruby\u0026#34;, \u0026#34;go\u0026#34;: \u0026#34;go run\u0026#34;, \u0026#34;html\u0026#34;: \u0026#34;\\\u0026#34;C:\\\\Program Files (x86)\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe\\\u0026#34;\u0026#34;, \u0026#34;java\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; javac $fileName \u0026amp;\u0026amp; java $fileNameWithoutExt\u0026#34;, \u0026#34;c\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; gcc $fileName -o $fileNameWithoutExt \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026#34;, \u0026#34;cpp\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; g++ -std=c++14 $fileName -o $fileNameWithoutExt \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026#34; }, \u0026#34;editor.suggestSelection\u0026#34;: \u0026#34;first\u0026#34;, \u0026#34;vsintellicode.modify.editor.suggestSelection\u0026#34;: \u0026#34;automaticallyOverrodeDefaultValue\u0026#34;, } ","date":"2020-12-14T15:21:53+09:00","permalink":"https://cliearl.github.io/posts/etc/vscode-settings-json/","title":"내가 사용하는 VS Code settings.json"},{"content":"VS Code에 파이썬 가상환경 설정하고 사용하는 법에 대해 정리했다.\nvenv 환경 작성 작업폴더를 연 뒤 터미널에서 다음 값 입력 1 $ python3 -m venv .venv 상태표시줄의 파이썬을 눌러 (\u0026rsquo;.venv\u0026rsquo;)인 python을 선택\n다음 명령어로 가상환경을 활성화 후 패키지 설치\n1 2 3 4 5 //윈도우 .venv\\\\scripts\\\\activate // macOS source .venv/bin/activate code-runner를 실행하기 위한 settings.json 설정 1 2 3 4 5 // 윈도우 \u0026#34;python.pythonPath\u0026#34;: \u0026#34;blahblah\\\\.venv\\\\Script\\\\python.exe\u0026#34;, // macOS \u0026#34;python.pythonPath\u0026#34;: \u0026#34;.venv/bin/python\u0026#34;, ","date":"2020-12-13T15:37:00+09:00","permalink":"https://cliearl.github.io/posts/etc/python-virtualenv-settings/","title":"VSCODE에서 Python VirtualEnv 환경설정하기"},{"content":"시놀로지에서 도커 이미지를 업데이트하는 법에 대해 정리하였다.\n도커패널 \u0026gt; 컨테이너 \u0026gt; 업데이트할 컨테이너 선택후 [작업 -\u0026gt; 중지]\n도커패널 \u0026gt; 레지스트리 \u0026gt; 업데이트할 이미지 찾아서 [다운로드]\n(이전 다운로드 받은 이미지(image) 삭제 하지 않아도 됨)\n도커패널 \u0026gt; 업데이트할 컨테이너 선택후 [작업 -\u0026gt; 지우기]\n(이전 설정은 지워지지 않음)\n도커패널 \u0026gt; 업데이트할 컨테이너 선택후 [작업 -\u0026gt; 시작점]\n","date":"2020-11-23T02:55:00+09:00","permalink":"https://cliearl.github.io/posts/linux/synology-docker-update/","title":"Synology에서 Docker Image 업데이트하기"},{"content":"내가 사용하는 VS Code의 extension에 대해 정리해보았다.\nActive File In StatusBar https://marketplace.visualstudio.com/items?itemName=RoscoP.ActiveFileInStatusBar 현재 편집하고 있는 파일의 위치를 상태바에 표시. C/C++ https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools C/C++ 지원 Code Runner https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner 코드 실행을 도와줌. settings.json에 다음 내용을 추가. 1 2 3 4 5 6 7 8 9 10 11 12 \u0026#34;code-runner.executorMap\u0026#34;: { \u0026#34;javascript\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;php\u0026#34;: \u0026#34;php\u0026#34;, \u0026#34;python\u0026#34;: \u0026#34;$pythonPath -u $fullFileName\u0026#34;, \u0026#34;perl\u0026#34;: \u0026#34;perl\u0026#34;, \u0026#34;ruby\u0026#34;: \u0026#34;ruby\u0026#34;, \u0026#34;go\u0026#34;: \u0026#34;go run\u0026#34;, \u0026#34;html\u0026#34;: \u0026#34;\\\u0026#34;C:\\\\Program Files (x86)\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe\\\u0026#34;\u0026#34;, \u0026#34;java\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; javac $fileName \u0026amp;\u0026amp; java $fileNameWithoutExt\u0026#34;, \u0026#34;c\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; gcc $fileName -o $fileNameWithoutExt \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026#34;, \u0026#34;cpp\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; g++ -std=c++14 $fileName -o $fileNameWithoutExt \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026#34; }, CodeMap https://marketplace.visualstudio.com/items?itemName=oleg-shilo.codemap 탐색창에 파일 속 클래스나 함수구조를 보여줌 Excel Viewer https://marketplace.visualstudio.com/items?itemName=GrapeCity.gc-excelviewer View Excel spreadsheets and CSV files within Visual Studio Code workspaces. Git Graph https://marketplace.visualstudio.com/items?itemName=mhutchie.git-graph View a Git Graph of your repository, and perform Git actions from the graph. indent-rainbow https://marketplace.visualstudio.com/items?itemName=oderwat.indent-rainbow This extension colorizes the indentation in front of your text alternating four different colors on each step. Some may find it helpful in writing code for Nim or Python. Kotlin Language https://marketplace.visualstudio.com/items?itemName=mathiasfrohlich.Kotlin Kotlin language support for VS Code LaTeX Workshop https://marketplace.visualstudio.com/items?itemName=James-Yu.latex-workshop Boost LaTeX typesetting efficiency with preview, compile, autocomplete, colorize, and more. Maintained Swift Development Environment https://marketplace.visualstudio.com/items?itemName=vknabel.vscode-swift-development-environment New home of Swift Development Environment for VS Code Markdown All in One https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one All you need to write Markdown (keyboard shortcuts, table of contents, auto preview and more) PlantUML https://marketplace.visualstudio.com/items?itemName=jebbs.plantuml Rich PlantUML support for Visual Studio Code. Path Autocomplete https://marketplace.visualstudio.com/items?itemName=ionutvmi.path-autocomplete Provides path completion for visual studio code. Python https://marketplace.visualstudio.com/items?itemName=ms-python.python IntelliSense (Pylance), Linting, Debugging (multi-threaded, remote), Jupyter Notebooks, code formatting, refactoring, unit tests, and more. Settings Sync https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync Synchronize Settings, Snippets, Themes, File Icons, Launch, Keybindings, Workspaces and Extensions Across Multiple Machines Using GitHub Gist. Todo Tree https://marketplace.visualstudio.com/items?itemName=Gruntfuggly.todo-tree Show TODO, FIXME, etc. comment tags in a tree view Visual Studio IntelliCode https://marketplace.visualstudio.com/items?itemName=VisualStudioExptTeam.vscodeintellicode AI-assisted development vscode-icons https://marketplace.visualstudio.com/items?itemName=robertohuertasm.vscode-icons Icons for Visual Studio Code ","date":"2020-10-20T05:27:00+09:00","permalink":"https://cliearl.github.io/posts/etc/vscode-extensions/","title":"내가 사용하는 VS Code Extensions"},{"content":"도커로 Hexo 블로그를 만들고 github.io 주소로 접속하도록 해 보았다.\n개인적으로 사용하고 있는 텍큐 블로그가 있는데 기술관련 내용을 쓰기는 너무 불편하고 오래되기도 해서 마크다운으로 사용할 수 있는 블로그 툴을 찾아봤다.\n처음엔 입출력 속도만 개선해보려고 PHP 버전을 5.6에서 7.3으로 올려봤는데 텍큐가 너무 오래되다보니 패치를 해도 잘 안돌아가고 해서 v7로 올리는 건 포기.\n그 다음으로는 업뎃 잘되는 워드프레스에 텍스트큐브의 블로그 내용을 다 옮기고 기술내용도 거기서 다 같이 쓸려고 했다. 그래서 TTXML Importer로 데이터를 옮겨봤는데 글만 옮겨지고 그외 카운터 정보같은건 옮길 수가 없었다.\n어차피 블로그를 깔끔하게 옮길 수 없다면 기술블로그 전용 툴을 쓰자 해서 찾은게 Ghost인데 얘는 카테고리나 사이드바 기능이 부족해서 탈락시켰다.\n그 다음으로 찾은 선택지는 정적 사이트 생성기를 이용하는 거였다. 마크다운 쓰기도 좋고, github.io 주소도 사용할 수 있으니 괜찮아보였다. 그래서 찾아보니 Jekyll에는 맘에 드는 스킨이 없어서 Hexo에 Icarus라는 테마를 붙여 써보기로 했다.\n근데 정적 사이트 생성기는 소스를 로컬에 보관하고 github.io로 퍼블리시하는 구조라, 모든 컴퓨터에 Hexo 소스를 보관할 필요가 있다. 이건 너무 바보같아서 Hexo 소스는 도커로 웹에 띄우고 이놈으로부터 github.io에 퍼블리싱하는 방법을 쓰기로 했다. 굳이 따지면 웹에 띄운 시점에서 바로 접속이 가능하니 굳이 퍼블리시를 할 필요는 없는거긴 한데 사이트를 매번 변환하는것보다는 당연히 변환된 저장소에 접속하는 편이 빠르고 무엇보다 github.io 주소를 쓰는 편이 더 geek하기 때문에 사용하기로 했다.\n그래서 이 포스트에서는 리눅스 서버에 도커로 Hexo를 띄우고, Hexo-admin 플러그인으로 퍼블리시한 파일을 github.io에 deploy하여 최종적으로는 유저명.github.io로 정적 블로그를 구축하는 법을 설명한다.\ngithub repository 생성 https://docs.github.com/en/free-pro-team@latest/github/working-with-github-pages/creating-a-github-pages-site 깃헙에 유저명.github.io라는 저장소 생성 이때 속성은 Public, Initialize this repository with a README를 선택 생성된 저장소의 settings → GitHub Pages → Theme Chooser 에서 테마를 아무거나 하나 골라주면 블로그가 가동됨 Your site is published at https://유저명.github.io/ 메시지가 뜨면 접속가능하게 된거임 도커 이미지 선정 https://github.com/spurin/docker-hexo Hexo와 관리용 Hexo-admin이 포함되어 있는 이미지 icarus 테마 셋업 1 2 3 4 5 6 7 8 # ssh로 접속 sudo su - docker ps # 현재 실행중인 컨테이너 확인 docker exec -it xxxxxxxxxxxx /bin/bash # 컨테이너에 접속 git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus # 테마 의존성 패키지 일괄설치 npm install --save bulma-stylus@0.8.0 hexo-renderer-inferno@^0.1.3 hexo-component-inferno@^0.10.1 inferno@^7.3.3 inferno-create-element@^7.3.3 # _config.yml의 theme가 landscape인데 icarus로 수정 hexo-admin에 패스워드 설정 Settings \u0026gt; Setup authentification에서 YAML을 생성 _config.yml의 admin: 밑에 붙여넣는다 hexo-admin에서 deploy 설정 https://github.com/jaredly/hexo-admin/issues/70 sh파일을 만들고 yml 파일을 수정한다 1 2 3 4 5 6 7 8 9 10 11 12 npm install --save hexo-deployer-git # git 배포용 플러그인 설치 touch hexo-deploy.sh; chmod a+x hexo-deploy.sh #!/usr/bin/env sh hexo clean hexo deploy # _config.yml을 수정 deploy: type: git repo: https://계정:패스워드@github.com/저장소.git admin: deployCommand: \u0026#39;./hexo-deploy.sh\u0026#39; 유용한 플러그인 hexo-deployer-git git으로 배포하기 위한 플러그인 1 2 # 설치 npm install hexo-deployer-git --save hexo-generator-feed atom(url/atom.xml ) 혹은 rss2.0(url/rss2.xml)으로 피드 생성해 줌 1 2 3 4 5 6 7 8 9 # 설치 npm install hexo-generator-feed --save # _config.yml 파일 끝에 다음 행 추가 feed: enable: true type: rss2 path: rss2.xml limit: 20 hexo-generator-sitemap sitemap.xml 파일을 자동생성 1 2 3 4 5 6 # 설치 npm install hexo-generator-sitemap --save # _config.yml 파일 맨 끝에 다음 행 추가 sitemap: path: sitemap.xml hexo-math KaTeX and MathJax를 활성화 시켜주는 플러그인 플러그인 설치 1 2 # 설치 npm install hexo-math --save 사용예 1 2 3 {% mathjax %} \\frac{1}{x^2-1} {% endmathjax %} ","date":"2020-10-09T19:24:00+09:00","permalink":"https://cliearl.github.io/posts/linux/docker-hexo-blog/","title":"도커로 Hexo 블로그 만들고 github.io 주소로 접속하기"},{"content":"문제 해설 http://tech.kakao.com/2018/09/21/kakao-blind-recruitment-for2019-round-1/\n오픈채팅방 https://www.welcomekakao.com/learn/courses/30/lessons/42888\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import Foundation func solution(_ record:[String]) -\u0026gt; [String] { var answer = [String]() var userList = [String : String]() var chatLog = [[String]]() let enterMsg = \u0026#34;님이 들어왔습니다.\u0026#34; let leaveMsg = \u0026#34;님이 나갔습니다.\u0026#34; // chatLog 작성 for info in record { let splitInfo = info.components(separatedBy: \u0026#34; \u0026#34;) if splitInfo[0] == \u0026#34;Enter\u0026#34; { userList[splitInfo[1]] = splitInfo[2] chatLog.append([splitInfo[1], enterMsg]) } else if splitInfo[0] == \u0026#34;Leave\u0026#34; { chatLog.append([splitInfo[1], leaveMsg]) } else if splitInfo[0] == \u0026#34;Change\u0026#34; { userList[splitInfo[1]] = splitInfo[2] } } // 최종 answer 작성 for log in chatLog { answer.append(\u0026#34;\\(userList[log[0]]!)\\(log[1])\u0026#34;) } return answer } 실패율 https://www.welcomekakao.com/learn/courses/30/lessons/42889\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import Foundation func solution(_ N:Int, _ stages:[Int]) -\u0026gt; [Int] { // 실패수가 0인 셋은 계산하지 않기 위해 스테이지에 머물러있는 사람의 수를 계수 var table = [Int : Int]() for stage in stages { if let counter = table[stage] { // 값이 있으면 기존 항목의 value를 1 증가시킴 table[stage] = counter + 1 } else { // 값이 없으면 새 항목을 생성 table[stage] = 1 } } var failureRate = [Int : Double]() // 1 스테이지는 모든 사람이 참가하므로 초기값은 stages.count var reached = stages.count for i in 1...N { if let notClear = table[i] { let rate = Double(notClear) / Double(reached) failureRate[i] = rate // 통과하지 못한 사람만큼 다음스테이지의 총인원수에서 빠져나감 reached -= notClear } else { // 게임중인 플레이어가 없는 스테이지는 0으로 고정 failureRate[i] = 0.0 } } // 키값으로 정렬한 뒤에 밸류값으로 정렬 let sortedErr = failureRate.sorted(by: \u0026lt;).sorted(by: { $0.value \u0026gt; $1.value }) return sortedErr.map { $0.key } } 후보키 https://www.welcomekakao.com/learn/courses/30/lessons/42890\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import Foundation func solution(_ relation:[[String]]) -\u0026gt; Int { var candidateKey = [Int]() let row = relation.count let col = relation[0].count // 2^col 갯수만큼 키 조합을 만들 수 있음 for i in 1 ..\u0026lt; Int(pow(2.0, Double(col))) { // 중복을 없애주는 tempSet으로 조합가능한 키 묶음을 생성 var tempSet = Set\u0026lt;String\u0026gt;() for j in 0..\u0026lt;row { var tmp = \u0026#34;\u0026#34; for k in 0..\u0026lt;col { if (i \u0026amp; (1 \u0026lt;\u0026lt; k)) != 0 { tmp += relation[j][k] } } tempSet.insert(tmp) } // 중복이 없는 키 묶음에 대해서만 연산하여 유일성 획득 if tempSet.count == row { var contains = true // 후보키의 최소성 판정 for num in candidateKey { if (num \u0026amp; i) == num { contains = false break } } // 후보키가 없으면 추가 if contains { candidateKey.append(i) } } } return candidateKey.count } 무지의 먹방 라이브 https://www.welcomekakao.com/learn/courses/30/lessons/42891\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import Foundation func solution(_ food_times:[Int], _ K:Int64) -\u0026gt; Int { // 모든 음식을 방송이 중단되기 전에 다 먹을 수 있는 경우 guard food_times.reduce(0, +) \u0026gt; K else { return -1 } // 64비트 머신에서 Int와 Int64는 동일한 값이다 var k: Int = Int(K) // 시간과 인덱스를 저장한 배열을 작성 var food_info: [(time: Int, idx: Int)] = food_times.enumerated().map { ($1,$0) } .sorted(by: \u0026lt;) var i = 0, j = 0, cycle = 0 // 일괄적으로 먹어치울 수 있는 부분을 처리 while i \u0026lt; food_info.count { j = i // 먹는 시간이 같은 음식의 총 갯수를 j로 확인 while j \u0026lt; food_info.count \u0026amp;\u0026amp; food_info[i].time == food_info[j].time { j += 1 } let eats = food_info[i].time - cycle let dec = (food_info.count - i) * eats // 다음 음식을 먹는데 필요한 총 시간보다 남은 시간이 짧으면 루프 탈출 if dec \u0026gt; k { break } // 먹는데 소요된 시간을 k에서 빼 준다 k -= dec cycle += eats // 다음 탐색할 인덱스를 다 먹은 음식 다음걸로 옮김 i = j } // 루프를 돌리고도 못 먹은 음식들의 인덱스를 오름차순 정렬 food_info = food_info[i...].sorted { $0.idx \u0026lt; $1.idx } // 남은 시간을 루프로 돌릴 수 있을 만큼 전부 소모하고 난 후의 값이 음식 인덱스 k = k % food_info.count // 배열 인덱스에 +1 한 값이 방송 재개후 먹을 음식이 됨 return food_info[k].idx + 1 } 길 찾기 게임 https://www.welcomekakao.com/learn/courses/30/lessons/42892\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 import Foundation class Node { var key: Int = 0 // x좌표 var value: Int = 0 // 값 var l_child: Node? var r_child: Node? init(key: Int, value: Int) { self.key = key self.value = value } } class Tree { var root: Node? func put(node: Node) { if self.root == nil { // 루트가 널이면 값을 바로 저장 self.root = node } else { var c_node = self.root var is_put = false while !is_put { if node.key \u0026lt; c_node!.key { if c_node!.l_child == nil { c_node!.l_child = node is_put = true } else { c_node = c_node!.l_child } } else { if c_node!.r_child == nil { c_node!.r_child = node is_put = true } else { c_node = c_node!.r_child } } } } } // 전위 순회 func preorder() -\u0026gt; [Int] { var stack = [self.root] var visit = [Int]() while !stack.isEmpty { // 맨 뒤의 노드값을 반환 후 삭제 let node = stack.popLast()! visit.append(node!.value) // 왼쪽 노드가 맨 뒤로 오도록 한다 if node?.r_child != nil { stack.append(node?.r_child) } if node?.l_child != nil { stack.append(node?.l_child) } } return visit } // 후위 순회 func postorder() -\u0026gt; [Int] { var stack = [self.root] var visit = [Int]() while !stack.isEmpty { let node = stack.popLast()! visit.append(node!.value) // 오른쪽 노드가 맨 뒤로 오도록 한다 if node?.l_child != nil { stack.append(node?.l_child) } if node?.r_child != nil { stack.append(node?.r_child) } } return visit.reversed() } } func solution(_ nodeinfo:[[Int]]) -\u0026gt; [[Int]] { var answer = [[Int]]() // [높이 : [(값, [X좌표, Y좌표])]] var depth_dic = [Int : [(Int, [Int])]]() for (i, node) in nodeinfo.enumerated() { if depth_dic[node[1]] != nil { // 같은 높이를 가진 다른 값이 이미 등록되어 있을 경우 추가 depth_dic[node[1]]?.append((i + 1, node)) } else { // 값이 없을경우 딕셔너리 쌍을 새로 작성 depth_dic[node[1]] = [(i + 1, node)] } } let tree = Tree() // 높이가 높은 순서부터 트리에 집어넣는다 let sorted_keys = depth_dic.keys.sorted(by: \u0026gt;) for level in sorted_keys { if let x = depth_dic[level] { // 왼쪽부터 순서대로 트리에 넣기 위해 x좌표값이 작은 순서부터 정렬 let sibling = x.sorted(by: { $0.1[0] \u0026lt; $1.1[0] }) // 바이너리 트리 작성 for node in sibling { tree.put(node: Node(key: node.1[0], value: node.0)) } } } answer.append(tree.preorder()) answer.append(tree.postorder()) return answer } 매칭 점수 https://www.welcomekakao.com/learn/courses/30/lessons/42893\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 import Foundation extension String{ func getAllMatchAfterRegex(_ pattern: String, _ option: NSRegularExpression.Options) -\u0026gt; [String] { // 옵셔널을 벗기기 위해 do-catch를 사용 do { let regex = try NSRegularExpression(pattern: pattern, options: option) let range = NSRange(self.startIndex..., in: self) let matches = regex.matches(in: self, range: range) return matches.map { String(self[Range($0.range, in: self)!]) } } catch let error { print(\u0026#34;invalid regex: \\(error.localizedDescription)\u0026#34;) return [] } } } class Page { var url = \u0026#34;\u0026#34; // url var normal = 0 // 기본 점수 var external_links = [String]() // 외부링크 list var matching = 0.0 // 매칭 점수 init(_ url: String, _ normal: Int, _ external_links: [String]) { self.url = url self.normal = normal self.external_links = external_links self.matching = Double(normal) } } func parse_html(word: String, html: String) -\u0026gt; (String, Int, [String]) { // target과 일치하는 단어를 리스트에서 계수 func count(target: String, word_list: [String]) -\u0026gt; Int { var result = 0 for word in word_list { if word.lowercased() == target.lowercased() { result += 1 } } return result } // head -\u0026gt; meta 태그안의 url을 추출 let head = html.getAllMatchAfterRegex(\u0026#34;\u0026lt;head\u0026gt;(.+)\u0026lt;/head\u0026gt;\u0026#34;, .dotMatchesLineSeparators) let url = head[0].getAllMatchAfterRegex(\u0026#34;(?\u0026lt;=meta property=\\\u0026#34;og:url\\\u0026#34; content=\\\u0026#34;https://)([^\\\u0026#34;]+)\u0026#34;, .dotMatchesLineSeparators) // 기본점수 계산 let word_list = html.getAllMatchAfterRegex(\u0026#34;[a-zA-Z]+\u0026#34;, []) let normal = count(target: word, word_list: word_list) // 후방탐색으로 외부링크 추출 let ext_links = html.getAllMatchAfterRegex(\u0026#34;(?\u0026lt;=\u0026lt;a href=\\\u0026#34;https://)([^\\\u0026#34;]+)\u0026#34;, .dotMatchesLineSeparators) let external_links = Array(Set(ext_links)) // 중복 삭제 return (url[0], normal, external_links) } func solution(_ word:String, _ pages:[String]) -\u0026gt; Int { var dic = [String : (Int, Page)]() // key: url, value: (idx, Page) // pages를 순회하면서 Page 객체를 생성 for (idx, html) in pages.enumerated() { let (url, normal, external_links) = parse_html(word: word, html: html) let page = Page(url, normal, external_links) dic[url] = (idx, page) } // 모든 Page 객체에 대해 매칭점수를 계산 for url in dic { let page = url.value.1 let external_links = page.external_links if external_links.count != 0 { let power = Double(page.normal) / Double(external_links.count) for link in external_links { if dic[link] != nil { dic[link]!.1.matching += power } } } } // 정렬을 위해 dic을 list로 변환 var answer = [(Int, Page)]() for url in dic { answer.append(url.value) } // idx에 대해 오름차순으로 정렬 후 rank에 대해 내림차순으로 정렬 answer = answer.sorted(by: { $0.0 \u0026lt; $1.0 }).sorted(by: { $0.1.matching \u0026gt; $1.1.matching}) // arr 내용확인 // for tup in answer { // print((tup.0, tup.1.url, tup.1.normal, tup.1.external_links, tup.1.matching)) // } return answer[0].0 } 블록 게임 https://www.welcomekakao.com/learn/courses/30/lessons/42894\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 import Foundation var n = 0 // 2x3 블록을 확인하기 위한 x, y 인덱스 모음 let block2x3 = [[0, 0, 0, 1, 1, 1], [0, 0, 1, 1, 2, 2]] // 3x2 블록을 확인하기 위한 x, y 인덱스 모음 let block3x2 = [[0, 1, 2, 0, 1, 2], [0, 1, 0, 1, 0, 1]] // x, y값이 인덱스에서 벗어나는지를 판정 func isXYsafe(_ x: Int, _ y: Int, _ n: Int) -\u0026gt; Bool { return min(x, y) \u0026gt;= 0 \u0026amp;\u0026amp; max(x, y) \u0026lt; n } func possible(_ x: Int, _ y: Int, _ k: Int, _ count: [[Int]], _ matrix: [[Int]], _ check: [[Int]], _ n: Int) -\u0026gt; ([[Int]], [[Int]], [[Int]], Bool) { var col = -1 var cur = 0 var check = check for i in 0 ..\u0026lt; 6 { let nx = x + block2x3[k][i] let ny = y + block3x2[k][i] // 같은 숫자가 4개 있고 0이 두개인 6개짜리 블록을 찾는다 if isXYsafe(nx, ny, n) { if matrix[nx][ny] != 0 { if col == -1 { col = matrix[nx][ny] } else { if col != matrix[nx][ny] { return (count, matrix, check, false) } } } else { cur += 1 // 보드에서 0인 곳이 count에서 0이 아니라면 블록 아래쪽이라는 말이므로 연산 종료 if count[nx][ny] != 0 { return (count, matrix, check, false) } } } else { return (count, matrix, check, false) } } if cur != 2 { return (count, matrix, check, false) } // 블록을 지울 수 있었던 경우 for i in 0 ..\u0026lt; 6 { let nx = x + block2x3[k][i] let ny = y + block3x2[k][i] check[nx][ny] = 1 // true 대신 1로 함 } // while 연산을 한번 더 하도록 함 return (count, matrix, check, true) } func solution(_ board:[[Int]]) -\u0026gt; Int { n = board.count var answer = 0 var possi = Bool() // 입력받는 행렬, 블록 체크 후 지워지는것도 반영 var board = board // 검은 블록을 내릴 수 있는지 판정하는 보드 var count = Array(repeating: Array(repeating: 0, count: n), count: n) // 지워야 할 블록을 알려주는 행렬 var check = Array(repeating: Array(repeating: 0, count: n), count: n) while true { // count, check보드 초기확 for i in 0 ..\u0026lt; n { for j in 0 ..\u0026lt; n { count[i][j] = 0 check[i][j] = 0 } } var flag = false // board 정보로부터 count 보드를 작성. 블록이 있는지만 우선 판정 for i in 0 ..\u0026lt; n { for j in 0 ..\u0026lt; n { if board[i][j] \u0026gt; 0 { count[i][j] = 1 } else { count[i][j] = 0 } } } // 블록 값을 밑으로 내리면서 계속 더한다. 그럼 검은 블록은 블록 밑에 올 수 없음 for i in 1 ..\u0026lt; n { for j in 0 ..\u0026lt; n { count[i][j] += count[i-1][j] } } for i in 0 ..\u0026lt; n { for j in 0 ..\u0026lt; n { for k in 0 ..\u0026lt; 2 { (count, board, check, possi) = possible(i, j, k, count, board, check, n) if possi { // 연산이 끝나지 않았으므로 루프를 다시 실행시킴 flag = true answer += 1 } } } } // 지워질 수 있는 행렬을 check보드로 판정 후 board에서 삭제 for i in 0 ..\u0026lt; n { for j in 0 ..\u0026lt; n { if check[i][j] == 1 { board[i][j] = 0 } } } if !flag { break } } return answer } ","date":"2019-09-19T22:31:28+09:00","permalink":"https://cliearl.github.io/posts/coding-test/2019-kakao-1st-swift/","title":"2019 카카오 신입 공채 1차 코딩 테스트 Swift 풀이"},{"content":"문제 해설 https://tech.kakao.com/2017/11/14/kakao-blind-recruitment-round-3/\nN진수 게임 https://www.welcomekakao.com/learn/courses/30/lessons/17687\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import Foundation // 진법변환 func convertBase(n: Int, base: Int) -\u0026gt; String { if n == 0 { return \u0026#34;0\u0026#34; } let list = [\u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;6\u0026#34;, \u0026#34;7\u0026#34;, \u0026#34;8\u0026#34;, \u0026#34;9\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;E\u0026#34;, \u0026#34;F\u0026#34;] var answer = [String]() var quotient = n // 몫 var remainder = 0 // 나머지 // 몫이 0이 될 때까지 n을 base로 계속 나누고 튀어나오는 나머지값을 역순으로 배치 while (quotient \u0026gt; 0) { remainder = quotient % base quotient = quotient / base answer.append(list[remainder]) } answer = answer.reversed() return answer.joined() } func solution(_ n:Int, _ t:Int, _ m:Int, _ p:Int) -\u0026gt; String { // 진법 n, 미리 구할 숫자의 갯수 t, 게임에 참가하는 인원 m, 튜브의 순서 p // 총 문자열 구하기 var totalStr = \u0026#34;\u0026#34; for i in 0 ..\u0026lt; (t * m) { totalStr += convertBase(n: i, base: n) } var answer = \u0026#34;\u0026#34; for i in 0 ..\u0026lt; t { let str = String(totalStr[totalStr.index(totalStr.startIndex, offsetBy: p + (i * m) - 1)]) answer += str } return answer } 압축 https://www.welcomekakao.com/learn/courses/30/lessons/17684\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import Foundation func solution(_ msg:String) -\u0026gt; [Int] { // 알파벳 리스트를 딕셔너리로 준비 let alphabetList: [String] = (0..\u0026lt;26).map({String(UnicodeScalar(\u0026#34;A\u0026#34;.unicodeScalars.first!.value + $0)!)}) var dict = [String : Int]() for (i, char) in alphabetList.enumerated() { dict[char] = i + 1 } var answer = [Int]() var searchWord = \u0026#34;\u0026#34; for i in msg { searchWord += String(i) // 찾는 단어가 없으면 if dict[searchWord] == nil { // 사전에 추가 dict[searchWord] = dict.count + 1 // 찾는 단어의 길이보다 한글자 작은 값의 인덱스를 반환값에 추가 answer.append(dict[String(searchWord.dropLast())]!) // 다음 찾을 단어를 searchWord에서 찾지 못했던 맨 마지막 문자로 설정 searchWord = String(searchWord.popLast()!) } else { continue } } // 맨 마지막에 남은 글자의 인덱스를 추가해줌 if !searchWord.isEmpty { answer.append(dict[searchWord]!) } return answer } 파일명 정렬 https://www.welcomekakao.com/learn/courses/30/lessons/17686\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import Foundation func solution(_ files:[String]) -\u0026gt; [String] { var answer = [String]() // HEAD, NUMBER, FILENAME으로 구성된 사전 준비 var dict = [(String, String, String)]() // dict 작성 for file in files { // 처음으로 나오는 숫자를 찾음 let range = NSRange(file.startIndex..., in: file) let numberRegex = try! NSRegularExpression(pattern: \u0026#34;[0-9]+\u0026#34;, options: []) let numberMatch = numberRegex.firstMatch(in: file, options: [], range: range) let number = numberMatch.map { String(file[Range($0.range, in: file)!]) }! // head 작성 let wordArr = file.map { String($0) } let head = wordArr[0...numberMatch!.range.lowerBound - 1].joined() dict.append((head, number, file)) } // dict를 정렬 for _ in dict { for i in 0 ..\u0026lt; dict.count - 1 { // head가 같으면 if dict[i].0.lowercased() == dict[i+1].0.lowercased() { // number를 비교 if (Int(dict[i].1)! \u0026gt; Int(dict[i+1].1)!) { // i가 i+1보다 크면 스왑 // (dict[i], dict[i+1]) = (dict[i+1], dict[i]) dict.swapAt(i, i + 1) } } else { // head를 비교 if dict[i].0.lowercased() \u0026gt; dict[i+1].0.lowercased() { // i가 i+1보다 크면 스왑 // (dict[i], dict[i+1]) = (dict[i+1], dict[i]) dict.swapAt(i, i + 1) } } } } // 정렬한 순서대로 파일명을 꺼내 옴 for value in dict { answer.append(value.2) } return answer } 방금 그 곡 https://www.welcomekakao.com/learn/courses/30/lessons/17683\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 import Foundation func solution(_ m:String, _ musicinfos:[String]) -\u0026gt; String { // 입력의 샵문자를 일반 캐릭터로 변환 var convertm = m convertm = convertm.replacingOccurrences(of: \u0026#34;A#\u0026#34;, with: \u0026#34;H\u0026#34;) .replacingOccurrences(of: \u0026#34;C#\u0026#34;, with: \u0026#34;I\u0026#34;) .replacingOccurrences(of: \u0026#34;D#\u0026#34;, with: \u0026#34;J\u0026#34;) .replacingOccurrences(of: \u0026#34;F#\u0026#34;, with: \u0026#34;K\u0026#34;) .replacingOccurrences(of: \u0026#34;G#\u0026#34;, with: \u0026#34;L\u0026#34;) var matchSong = \u0026#34;\u0026#34; // 실제 플레이 된 사운드와 타이틀을 매치시킨 사전 준비 var dict = [String : String]() // dict 작성 for info in musicinfos { let str = info.components(separatedBy: \u0026#34;,\u0026#34;) var (start, end, title, sound) = (str[0], str[1], str[2], str[3]) // 시간 변환 let (starthh, startmm) = (start.components(separatedBy: \u0026#34;:\u0026#34;)[0], start.components(separatedBy: \u0026#34;:\u0026#34;)[1]) let (endhh, endmm) = (end.components(separatedBy: \u0026#34;:\u0026#34;)[0], end.components(separatedBy: \u0026#34;:\u0026#34;)[1]) let time = (Int(endhh)! - Int(starthh)!) * 60 + (Int(endmm)! - Int(startmm)!) // 재생한 사운드 작성 sound = sound.replacingOccurrences(of: \u0026#34;A#\u0026#34;, with: \u0026#34;H\u0026#34;) .replacingOccurrences(of: \u0026#34;C#\u0026#34;, with: \u0026#34;I\u0026#34;) .replacingOccurrences(of: \u0026#34;D#\u0026#34;, with: \u0026#34;J\u0026#34;) .replacingOccurrences(of: \u0026#34;F#\u0026#34;, with: \u0026#34;K\u0026#34;) .replacingOccurrences(of: \u0026#34;G#\u0026#34;, with: \u0026#34;L\u0026#34;) // 처음부터 끝까지 반복 + 남은거 붙이기 let playedSound = String(repeating: sound, count: time / sound.count) + sound[sound.startIndex..\u0026lt;sound.index(sound.startIndex, offsetBy: time%sound.count)] // dict 작성 dict[playedSound] = title } for song in dict.keys { // 비교하고 싶은 음이 사전에 있으면 if song.contains(convertm) { // 재생된 시간이 같을 경우 먼저 입력된 음악 제목을 반환 if matchSong == \u0026#34;\u0026#34; { matchSong = song } else { // 조건이 일치하는 음악이 여러 개일 때에는 라디오에서 재생된 시간이 제일 긴 음악 제목을 반환 if matchSong.count \u0026lt; song.count { matchSong = song } } } } if matchSong == \u0026#34;\u0026#34; { return \u0026#34;(None)\u0026#34; } return dict[matchSong]! } 자동완성 https://www.welcomekakao.com/learn/courses/30/lessons/17685\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import Foundation // 두 문자를 비교한 횟수를 반환 func compare2(object: [String], target: [String]) -\u0026gt; Int { for i in 1...object.count { // 일치하지 않은 부분이 나타난 인덱스를 반환 // 타겟길이가 오브젝트길이보다 짧으면 비교할 인덱스를 최대값으로 고정 if object[0..\u0026lt;i].joined() != target[0..\u0026lt;min(i, target.count)].joined() { return i } } // 겹치는 부분이 없었으면 (=for문을 중간에 빠져나오지 못했으면) 길이를 그대로 반환 return object.count } // 세 문자를 비교 func compare3(object: [String], targetL: [String], targetR: [String]) -\u0026gt; Int { for i in 1...object.count { if (object[0..\u0026lt;i].joined() != targetL[0..\u0026lt;min(i, targetL.count)].joined()) \u0026amp;\u0026amp; (object[0..\u0026lt;i].joined() != targetR[0..\u0026lt;min(i, targetR.count)].joined()) { return i } } return object.count } func solution(_ words:[String]) -\u0026gt; Int { // 고속탐색을 위해 입력받은 문자열을 정렬한 뒤 배열화 var wordsArr = [[String]]() for word in words.sorted() { let splitWord = word.map { String($0) } wordsArr.append(splitWord) } var answer = 0 for idx in 0..\u0026lt;wordsArr.count { if idx == 0 { // 첫번째 단어는 오른쪽 단어와 비교 answer += compare2(object: wordsArr[idx], target: wordsArr[idx+1]) } else if idx == wordsArr.count - 1 { // 마지막 단어는 왼쪽 단어와 비교 answer += compare2(object: wordsArr[idx], target: wordsArr[idx-1]) } else { // 나머지 단어는 좌우 단어들과 비교 answer += compare3(object: wordsArr[idx], targetL: wordsArr[idx-1], targetR: wordsArr[idx+1]) } } return answer } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 import Foundation // 데이터 저장 및 커서관리용 노드 class Node { var key: Character? var data: String? // 노드간 연결용 이름표 컨테이너 var children = [Character : Node]() // 노드 순서를 표시하는 컨테이너 var order: Int = 0 init (_ key: Character?, data: String? = nil) { self.key = key self.data = data } } // 트라이 자료구조 클래스 // 캐릭터를 트리를 이용하여 포도송이처럼 연결시킨 구조 class Trie { var head: Node init() { self.head = Node(nil) } // 삽입용 함수 func insert(_ str: String) { var curr_node = self.head // 입력받은 단어의 트리작성 for char in str { // 요소가 없으면 char를 가지는 새 노드를 연결 if curr_node.children[char] == nil { curr_node.children[char] = Node(char) } // 다음 노드로 이동 curr_node.order += 1 curr_node = curr_node.children[char]! } // 맨 마지막 노드의 data는 str이다 curr_node.data = str } // 입력 문자열에 대한 값 반환 func countInputWord(_ str: String) -\u0026gt; Int { var curr_node = self.head var count = 0 // 전 노드 검색 for char in str { curr_node = curr_node.children[char]! count += 1 // 일치하는 단어가 있거나 첫번째 노드에 데이터가 없으면 중지 if curr_node.data == str || (curr_node.order == 1 \u0026amp;\u0026amp; curr_node.data == nil) { return count } } return count } } func solution(_ words:[String]) -\u0026gt; Int { // 입력으로부터 트라이 구조 작성 let trie = Trie() for word in words { trie.insert(word) } // 입력값 계산 var answer = 0 for word in words { answer += trie.countInputWord(word) } return answer } 필기 시험 http://tech.kakao.com/files/kakao-blind-recruitment.pdf (새 창으로 열기)\n","date":"2019-09-03T14:43:01+09:00","permalink":"https://cliearl.github.io/posts/coding-test/2018-kakao-3rd-swift/","title":"2018 카카오 신입 공채 3차 코딩 테스트 Swift 풀이"},{"content":"문제해설 http://tech.kakao.com/2017/09/27/kakao-blind-recruitment-round-1/\n비밀지도 (비트연산) https://www.welcomekakao.com/learn/courses/30/lessons/17681\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func solution(_ n:Int, _ arr1:[Int], _ arr2:[Int]) -\u0026gt; [String] { var answer = [String](repeating: \u0026#34;\u0026#34;, count: n) var bitAdded = Array\u0026lt;Int\u0026gt;() for i in 0..\u0026lt;n { bitAdded.append(arr1[i] | arr2[i]) } for i in 0..\u0026lt;n { for _ in 0..\u0026lt;n { // 2진수로 변환한 값의 맨 뒷자리가 튀어나온다 // 그걸 반환배열의 맨 앞으로 넣어준다 answer[i].insert(bitAdded[i] % 2 == 1 ? \u0026#34;#\u0026#34; : \u0026#34; \u0026#34;, at: answer[i].startIndex) // 비트를 오른쪽으로 하나 옮김 bitAdded[i] \u0026gt;\u0026gt;= 1 } } return answer } 다트 게임 (정규표현식) https://www.welcomekakao.com/learn/courses/30/lessons/17682\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 import Foundation // 정규표현식을 쓸수있도록 스트링 타입을 확장 extension String{ func getAllMatchAfterRegex(_ pattern: String) -\u0026gt; [String] { // 옵셔널을 벗기기 위해 do-catch를 사용 do { let regex = try NSRegularExpression(pattern: pattern, options: []) let range = NSRange(self.startIndex..., in: self) let matches = regex.matches(in: self, range: range) return matches.map { String(self[Range($0.range, in: self)!]) } } catch let error { print(\u0026#34;invalid regex: \\(error.localizedDescription)\u0026#34;) return [] } } } func solution(_ dartResult: String) -\u0026gt; Int { // 입력을 정규표현식으로 자르기 let pointArr = dartResult.getAllMatchAfterRegex(\u0026#34;[0-9]+\u0026#34;) // 두자리수까지 탐색 let bonusArr = dartResult.getAllMatchAfterRegex(\u0026#34;[(S|D|T)]\u0026#34;) // 고정인 알파벳만 탐색 let optionArr = dartResult.getAllMatchAfterRegex(\u0026#34;(?\u0026lt;=S|D|T)[(*|#)]?\u0026#34;) // 후방탐색 var result = [Int]() for i in 0..\u0026lt;3 { let newArray = [pointArr[i], bonusArr[i], optionArr[i]] // 점수 결정 let point = Double(newArray[0])! // 보너스값 결정 var bonus: Double = 1 if newArray[1] == \u0026#34;D\u0026#34; { bonus = 2 } else if newArray[1] == \u0026#34;T\u0026#34; { bonus = 3 } // 옵션 결정 후 값 반영 if newArray[2] == \u0026#34;*\u0026#34; { if i == 0 { result.append(Int(pow(point, bonus) * 2)) } else { // 바로 앞의 결과값에 2를 곱해줌 result[result.index(before: result.endIndex)] *= 2 result.append(Int(pow(point, bonus) * 2)) } } else if newArray[2] == \u0026#34;#\u0026#34; { result.append(Int(pow(point, bonus) * -1)) } else { result.append(Int(pow(point, bonus))) } } return result.reduce(0) { $0 + $1 } } 캐시 https://www.welcomekakao.com/learn/courses/30/lessons/17680\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import Foundation func solution(_ cacheSize:Int, _ cities:[String]) -\u0026gt; Int { let CACHE_HIT = 1 let CACHE_MISS = 5 var answer = 0 var cache = [String : Int]() var time = 0 if cacheSize == 0 { answer += cities.count * CACHE_MISS return answer } for city in cities { time += 1 // 대소문자 구분 없앰 let city = city.lowercased() if cache[city] != nil { // 캐시가 히트하면 인덱스의 타임을 최신값으로 갱신 cache[city] = time answer += CACHE_HIT } else { // 캐시미스일때 현재 캐시크기가 캐시사이즈보다 작으면 그냥 추가 if cache.count \u0026lt; cacheSize { cache[city] = time answer += CACHE_MISS } else { // 그렇지 않으면 가장 오래된 캐시를 삭제하고 값을 추가 let oldest = cache.min { a, b in a.value \u0026lt; b.value }! cache.remove(at: cache.index(forKey: oldest.key)!) cache[city] = time answer += CACHE_MISS } } } return answer } 셔틀버스 (문자열 시간변환, 딕셔너리) https://www.welcomekakao.com/learn/courses/30/lessons/17678\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 import Foundation func solution(_ n:Int, _ t:Int, _ m:Int, _ timetable:[String]) -\u0026gt; String { // 문자열 타임테이블을 가공하기 용이하게 숫자로 변환 var cvtTimetable = [Int]() // 시간을 네자리 정수로 변환 for time in timetable { let convert = time[time.startIndex].wholeNumberValue! * 1000 + time[time.index(time.startIndex, offsetBy: 1)].wholeNumberValue! * 100 + time[time.index(time.startIndex, offsetBy: 3)].wholeNumberValue! * 10 + time[time.index(time.startIndex, offsetBy: 4)].wholeNumberValue! cvtTimetable.append(convert) } // 오름차순으로 소트 cvtTimetable = cvtTimetable.sorted(by: \u0026lt;) // 버스 출발타임을 0900으로 설정 var busStartTime: Int = 0900 var answer: Int = 0 var crewIdx: Int = 0 // 각 버스에 대한 체크 시작 for _ in 0..\u0026lt;n { var crewMember: Int = 0 var arriveTime: Int = 0 // 크루도착시간과 도착순서 관계 컨테이너 초기화 var watingCue = [Int : Int]() // 버스 출발시간보다 빨리 온 크루의 도착시간 딕셔너리를 작성 while (crewMember \u0026lt; m \u0026amp;\u0026amp; crewIdx \u0026lt; timetable.count) { // 크루가 버스보다 늦게 왔으면 추가하지 않고 지나감 if (cvtTimetable[crewIdx] \u0026gt; busStartTime) { break } // 버스 출발시간보다 빨리 온 크루를 딕셔너리에 순서대로 등록 watingCue[cvtTimetable[crewIdx]] = crewIdx + 1 crewIdx += 1 crewMember += 1 } // 타려고 대기한 크루의 배열을 소팅함 let sortedCue = watingCue.sorted(by: \u0026lt;) // 타려고 대기한 총 인원이 버스의 승차가능인보다 적으면 버스출발시간에 오면 됨 if (crewMember \u0026lt; m) { answer = max(answer, busStartTime) } else { // 대기멤버가 승차가능인보다 많으면 연산시작 var check = 0 for cue in sortedCue { // 탑승가능한 맨 마지막 크루에 대해 체크 if (check + cue.value \u0026gt;= m) { // 그 크루보다 1분 빠르게 도착하도록 함 arriveTime = cue.key - 1 // 08:99를 08:59로 바꿔줌 if (arriveTime % 100 \u0026gt; 59) { arriveTime -= 40 } // 00:00 에서 -1 하면 24:00이 되도록 보정 if arriveTime \u0026lt; 0 { arriveTime += 2400 } } check += cue.value } answer = max(answer, arriveTime) } // 시작시간을 버스 다음 도착시간으로 변경 busStartTime += t // minute가 59보다 커질 경우 1 hour 추가하고 min에서 60을 빼줌 if (busStartTime % 100 \u0026gt; 59) { busStartTime += 100 busStartTime -= 60 } } // 답 작성 var hh = String(answer / 100) if (hh.count \u0026lt; 2) { hh = \u0026#34;0\u0026#34; + hh } var mm = String(answer % 100) if (mm.count \u0026lt; 2) { mm = \u0026#34;0\u0026#34; + mm } return hh + \u0026#34;:\u0026#34; + mm } 뉴스 클러스터링 (집합, 딕셔너리) https://www.welcomekakao.com/learn/courses/30/lessons/17677\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 import Foundation func solution(_ str1:String, _ str2:String) -\u0026gt; Int { // 분리한 입력문자를 저장할 컨테이너 var splitstr1 = [String]() var splitstr2 = [String]() // 각 요소의 개수가 몇 개씩 있는지 기록할 딕셔너리 준비 var set1 = [String : Int]() var set2 = [String : Int]() var intersectSet: Int = 0 // 교집합 개수 var unionSet: Int = 0 // 합집합 개수 // 입력문자를 두개씩 분리 for i in 0..\u0026lt;str1.count - 1 { // 대문자로 변환한 스트링을 앞에서부터 두 문자씩 빼옴 let first = String(str1[str1.index(str1.startIndex, offsetBy: i)]).uppercased() let second = String(str1[str1.index(str1.startIndex, offsetBy: i + 1)]).uppercased() // 문자가 알파벳일때만 배열에 추가 if \u0026#34;A\u0026#34; \u0026lt;= first \u0026amp;\u0026amp; first \u0026lt;= \u0026#34;Z\u0026#34; \u0026amp;\u0026amp; \u0026#34;A\u0026#34; \u0026lt;= second \u0026amp;\u0026amp; second \u0026lt;= \u0026#34;Z\u0026#34; { splitstr1.append(first + second) } } // set1 작성 for elem in splitstr1 { // 각 요소 개수세기 let count = splitstr1.filter { $0 == elem }.count // 딕셔너리 형태로 저장 set1[elem] = count } // 입력문자를 두개씩 분리 for i in 0..\u0026lt;str2.count - 1 { // 대문자로 변환한 스트링을 앞에서부터 두 문자씩 빼옴 let first = String(str2[str2.index(str2.startIndex, offsetBy: i)]).uppercased() let second = String(str2[str2.index(str2.startIndex, offsetBy: i + 1)]).uppercased() // 문자가 알파벳이면 추가 if \u0026#34;A\u0026#34; \u0026lt;= first \u0026amp;\u0026amp; first \u0026lt;= \u0026#34;Z\u0026#34; \u0026amp;\u0026amp; \u0026#34;A\u0026#34; \u0026lt;= second \u0026amp;\u0026amp; second \u0026lt;= \u0026#34;Z\u0026#34; { splitstr2.append(first + second) } } // set2 작성 for elem in splitstr2 { // 각 요소 개수세기 let count = splitstr2.filter { $0 == elem }.count // 딕셔너리 형태로 저장 set2[elem] = count } // set1에 대해 set2를 비교 for it in set1 { // set1의 키값이 set2에도 있으면 if (set2[it.key] != nil) { // 작은값을 교집합에 추가 intersectSet += min(it.value, set2[it.key]!) // 큰 값을 합집합에 추가 unionSet += max(it.value, set2[it.key]!) } else { // 키값이 없으면 합집합에 set1 요소만 추가 unionSet += it.value } } // set2에 대해 set1을 비교 for it in set2 { // set1에 대응되는 값이 없으면 if (set1[it.key] == nil) { // 합집합에 set2 요소만 추가 unionSet += it.value } } // 예외처리 if unionSet == 0 { return 65536 } // 답안 작성 intersectSet *= 65536 return intersectSet / unionSet } 프렌즈 4블록 (2차원배열, 스왑) https://www.welcomekakao.com/learn/courses/30/lessons/17679\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 import Foundation func solution(_ m:Int, _ n:Int, _ board:[String]) -\u0026gt; Int { var isFinished = false var answer = 0 // 입력받은 문자열배열을 2차원 캐릭터배열로 분리변환 var newBoard = [[String]]() for elem in board { var arr = [String]() for e in elem { arr.append(String(e)) } newBoard.append(arr) } while true { isFinished = true var judgeBoard = [[Bool]](repeating: Array(repeating: false, count: n), count: m) for row in 1 ..\u0026lt; m { for col in 1 ..\u0026lt; n { // 배열을 순회하면서 인접한 사각 요소를 가져옴 let a = newBoard[row - 1][col - 1] let b = newBoard[row - 1][col] let c = newBoard[row][col - 1] let d = newBoard[row][col] // 사각 요소가 모두 일치하는지 확인 if (a == b \u0026amp;\u0026amp; b == c \u0026amp;\u0026amp; c == d) { if a == \u0026#34;-\u0026#34; { continue } // 일치하면 다음 요소를 검색 isFinished = false // 판정 보드에 트루라고 기록 judgeBoard[row - 1][col - 1] = true judgeBoard[row - 1][col] = true judgeBoard[row][col - 1] = true judgeBoard[row][col] = true } } } // 배열을 순회하면서 true이면 newBoard값을 -로 변경 for row in 0 ..\u0026lt; m { for col in 0 ..\u0026lt; n { if judgeBoard[row][col] { newBoard[row][col] = \u0026#34;-\u0026#34; } } } // 삭제하고 나서 떠있는 블럭을 밑으로 떨어뜨림 for row in 0 ..\u0026lt; n { for j in (0 ... m - 1).reversed() { // for j in stride(from: m - 1, through: 0, by: -1) { var col = j // 한 칸씩 내려보내다가 빈공간(-)이 없어지면 중단한다 while (col + 1 \u0026lt; m \u0026amp;\u0026amp; newBoard[col + 1][row] == \u0026#34;-\u0026#34;) { // 아래 위 보드 내용을 스왑 let temp = newBoard[col][row] newBoard[col][row] = newBoard[col + 1][row] newBoard[col + 1][row] = temp col += 1 } } } // 처리가 끝났으면 종료한다 if (isFinished) { break } } // -의 갯수를 계수한다 for row in 0 ..\u0026lt; m { for col in 0 ..\u0026lt; n { if (newBoard[row][col] == \u0026#34;-\u0026#34;) { answer += 1 } } } return answer } 추석 트래픽 (문자열 시간변환) https://www.welcomekakao.com/learn/courses/30/lessons/17676\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 import Foundation func convertTime(_ input: [String]) -\u0026gt; [[Double]] { var startList = [Double]() var endList = [Double]() for i in input { let (timeStr, durationStr) = (i.split(separator: \u0026#34; \u0026#34;)[1], i.split(separator: \u0026#34; \u0026#34;)[2]) // 시간 문자열을 sec 스케일의 숫자로 변환 let timeSplit = timeStr.split(separator: \u0026#34;:\u0026#34;) let hour = Double(String(timeSplit[0]))! * 3600 let min = Double(String(timeSplit[1]))! * 60 let sec = Double(String(timeSplit[2][timeSplit[2].startIndex...timeSplit[2].index(after: timeSplit[2].startIndex)]))! let subsec = Double(\u0026#34;0.\u0026#34; + String(timeSplit[2][timeSplit[2].index(timeSplit[2].startIndex, offsetBy: 3)..\u0026lt;timeSplit[2].endIndex]))! // 간격 가져오기 let duration = Double(String(durationStr[durationStr.startIndex..\u0026lt;durationStr.index(before: durationStr.endIndex)]))! // 시작과 종료시간을 각각 배열화 let endTime: Double = hour + min + sec + subsec let startTime: Double = endTime - duration + 0.001 startList.append(startTime) endList.append(endTime) } return [startList, endList] } func solution(_ lines:[String]) -\u0026gt; Int { let converttime = convertTime(lines) let (startList, endList) = (converttime[0], converttime[1]) var request = [Int]() // 각 시작시간과 종료시간의 직전, 직후 윈도우 요청수만을 확인 for k in (startList + endList) { var count = 0 for (i, j) in zip(startList, endList) { if i \u0026lt; k + 1 \u0026amp;\u0026amp; j \u0026gt;= k { count += 1 } else { count += 0 } } request.append(count) } return request.max()! } ","date":"2019-08-30T14:06:53+09:00","permalink":"https://cliearl.github.io/posts/coding-test/2018-kakao-1st-swift/","title":"2018 카카오 신입 공채 1차 코딩 테스트 Swift 답안"},{"content":" Consumer Electronics Show (CES)\n1/7 ~ 1/10 http://www.ces.tech/ Las Vegas Convention Center, Nevada Youtube Free and Open source Software Developers\u0026rsquo; European Meeting (FOSDEM)\n2/2 ~ 2/3 http://fosdem.org/2019/ ULB Solbosch Campus, Brussels Youtube DeveloperWeek\n2/19 ~ 2/24 http://www.developerweek.com/ Oakland Convention Center, California Youtube Game Developers Conference (GDC)\n3/18 ~ 3/22 http://gdconf.com/ Moscone Center, California Youtube iOSCon\n3/21 ~ 3/22 http://skillsmatter.com/conferences/10823-ioscon-2019-the-conference-for-ios-and-swift-developers CodeNode, London try! Swift Tokyo\n3/21 ~ 3/22 http://www.tryswift.co/events/2019/tokyo/en/ 住友不動産 渋谷ファーストタワー, 東京 Youtube GPU Technology Conference (GTC)\n3/23 ~ 3/26 http://www.nvidia.com/en-us/gtc/ San Jose McEnery Convention Center, California Youtube Unreal Fest Europe\n4/10 ~ 4/12 http://unrealfesteurope.com/ Hilton, Prague Youtube AWS Summit Seoul\n4/17 ~ 4/18 http://aws.amazon.com/ko/events/summits/seoul/ 코엑스 컨벤션 센터, 서울 Youtube UNREAL FEST WEST\n4/20 http://unrealengine.jp/unrealfest/ 京都コンピュータ学院 京都駅前校 Youtube Nexon Developers Conference (NDC)\n4/24 ~ 4/26 http://ndc.nexon.com/main GB1 타워, 경기도 Youtube World IT Show\n4/24 ~ 4/27 http://www.worlditshow.co.kr/kor/ 코엑스, 서울 Pycon US\n5/1 ~ 5/9 http://us.pycon.org/2019/ Huntington Convention Center of Cleveland, Ohio Youtube Microsoft Build\n5/6 ~ 5/8 http://www.microsoft.com/en-us/build Washington State Convention Center, Seattle Youtube Google I/O\n5/7 ~ 5/9 http://developers.google.com/ Shoreline Amphitheatre, California Youtube O\u0026rsquo;Reilly Open Source Convention (OSCON)\n5/8 ~ 5/9 http://conferences.oreilly.com/oscon/oscon-tx Austin Convention Center, Texas Youtube Unreal Summit\n5/14 ~ 5/15 http://www.unrealsummit.co.kr/ 그랜드 인터컨티넨탈 서울 파르나스, 서울 Youtube Unite Seoul\n5/21 ~ 5/22 http://uniteseoul.com/2019/ 코엑스 그랜드볼룸, 서울 Youtube COMPUTEX\n5/28 ~ 6/1 http://www.computextaipei.com.tw/ Taipei Nangang Exhibition Center, Taipei Youtube The Apple Worldwide Developers Conference (WWDC)\n6/3 ~ 6/7 http://developer.apple.com/wwdc19/ San Jose McEnery Convention Center, California Youtube try! Swift San Jose\n6/7 http://www.tryswift.co/events/2019/sanjose/ Hilton San Jose, California Youtube O\u0026rsquo;Reilly Fluent\n6/11 ~ 6/12 http://conferences.oreilly.com/fluent/fl-ca San Jose McEnery Convention Center, California Youtube Electronic Entertainment Expo (E3)\n6/12 ~ 6/13 http://www.e3expo.com/ Los Angeles Convention Center, California Youtube QCon New York\n6/24 ~ 6/28 http://qconnewyork.com/ Marriott Marquis, New York Youtube DevOps Enterprise Summit (DOES)\n6/25 ~ 6/27 http://events.itrevolution.com/eur/ InterContinental London - The O2, England Youtube Google Play Indie Games Festival\n6/29 http://indiegamesshowcase.withgoogle.com/korea/ 예스24 라이브홀, 서울 Youtube Euro Python\n7/8 ~ 7/14 http://ep2019.europython.eu/ Congress Center Basel, Swiss Youtube Develop:Brignton\n7/9 ~ 7/11 http://www.developconference.com/ Hilton Brighton Metropole, England Youtube Pycon KR\n8/15 ~ 8/18 http://www.pycon.kr/ 코엑스 그랜드볼룸, 서울 Youtube droidcon New York\n8/26 ~ 8/27 http://www.nyc.droidcon.com/ Brooklyn Expo Center, Brooklyn Youtube Open Source Summit\n8/29 ~ 8/31 http://events.linuxfoundation.org/events/open-source-summit-north-america-2018/ Vancouver Convention Centre, Canada Youtube iOSDC Japan\n9/5 ~ 9/7 http://iosdc.jp/2019/ 早稲田大学 西早稲田キャンパス, 東京 Youtube Computer Entertainment Developers Conference (CEDEC)\n9/4 ~ 9/6 http://2019.cedec.cesa.or.jp/ パシフィコ横浜 会議センター, 神奈川 try! Swift New York\n9/9 ~ 9/10 http://www.tryswift.co/events/2019/nyc/ New World Stages, New York Youtube Pycon JP\n9/16 ~ 9/17 http://www.pycon.jp/ 大田区産業プラザ, 東京 Youtube CppCon\n9/14 ~ 9/22 http://cppcon.org/regopen2019/ Gaylord Rockies Resort \u0026amp; Convention Center, Colorado Youtube 한국전자전 (KES)\n10/8 ~ 10/11 http://www.kes.org/kor/ 코엑스, 서울 Youtube CEATEC JAPAN\n10/15 ~ 10/18 http://www.ceatec.com/ 幕張メッセ, 千葉 Youtube INVEN Game Conference (IGC)\nhttp://igc.inven.co.kr/ Android Dev Summit\n10/23 ~ 10/24 http://developer.android.com/dev-summit/ Google Event Center (MP7), Sunnyvale Youtube) DevOps Enterprise Summit (DOES)\n10/28 ~ 10/30 http://events.itrevolution.com/us/ The Cosmopolitan of Las Vegas, Nevada Youtube QCon San Francisco\n11/16 ~ 11/20 http://qconsf.com/ Hyatt Regency San Francisco, California Youtube Kotlin Fest\nhttps://twitter.com/kotlin_fest KotlinFest2019 #kotlinfest Rakuten Technology Conference\nhttps://tech.rakuten.co.jp/ Rakuten Technology Conference 2019 - Main Stage Cookpad TechConf\nhttps://techconf.cookpad.com/2019/ Cookpad TechConf 2019 Yahoo! JAPAN Tech Conference\nhttps://techconference.yahoo.co.jp/2019/ Yahoo! JAPAN Tech Conference 基調講演 Oracle Code One\nhttps://www.oracle.com/code-one/ Oracle Code One 2019 KotlinConf\nhttps://kotlinconf.com/2019/ KotlinConf 2019 FEConf\nhttps://2019.feconf.kr/ FEConf 2019 Korea ","date":"2019-05-27T22:40:32+09:00","permalink":"https://cliearl.github.io/posts/conferences/2019/","title":"2019년 개발관련 컨퍼런스 리스트"},{"content":"Swift 코딩규약 Swift 코드를 작성할 때는 코딩규약에 따라 작성하는게 추천되는데, 여러 조직에서 이 규약을 제공하고 있다.\n스위프트 공식 홈페이지의 API Design Guidelines\nraywenderlich.com 의 The Official raywenderlich.com Swift Style Guide\nThe Official raywenderlich.com Swift Style Guide는 한국어로도 번역되어 있다.\nGoogle Swift Style Guide\n일본의 IT 교육회사에서 사용하는 규약 Swiftコーディング規約@Life is Tech !\nGithub에서도 Github guide to Swift style and conventions를 제공하고 있었으나 2017년 11월 시점으로 업뎃을 중단했다.\nLint 사용 규약을 항상 외우고 있을수는 없기 때문에 Lint 플러그인을 사용하여 자동으로 문법오류를 잡도록 하는것이 편리하다. SwiftLint라는 도구가 그 역할을 할 수 있다.\nSwiftLint의 사용법에 대해서는 SwiftLint로 보다 명확하고 깔끔한 코드를 만들어 보세요!를 참고하도록 하자.\nSwiftLint의 실제 사용법은 갓제드님의 iOS ) 내 프로젝트에 SwiftLint를 적용해보자를 참고하도록 하자.\nJazzy로 코드 문서화하기 코드를 깔끔하게 작성했다면 코드를 자동으로 문서화 하는 툴인 Jazzy를 사용할 수 있다.\nrealm.io에서 개발한 jazzy를 사용하면 Xcode에서 Markdown 스타일로 작성한 코드를 문서화해준다. 포맷에 대해서는 Documenting Your Swift Code in Xcode Using Markdown 이나, Swift Documentation을 참고하자.\n한글로 된 Jazzy의 사용법에 대해서는 Xcode에서 Jazzy를 이용해서 애플 래퍼런스 문서 스타일의 API문서 만들기를 참고하자. 가장 최신의 Jazzy 사용법은 Generate \u0026amp; Host your iOS Documentation, Swift用ドキュメント生成ツール「Jazzy」のセットアップ\u0026amp;操作方法에서 확인할 수 있다.\njazzy 사용 gem update --system으로 gem 최신화 gem install jazzy 로 설치 인스톨중 (Errno::EPERM) Operation not permitted 에러가 발생할 수 있는데, rootless라는 OSX의 시스템요소때문에 발생한다고 하니 stackoverflow를 참고하여 해결하자. sudo gem install -n /usr/local/bin jazzy 빌드가 가능한 xcode 디렉토리에서 jazzy --clean --min-acl private를 실행하면 문서가 생성된다. ","date":"2019-05-09T20:06:14+09:00","permalink":"https://cliearl.github.io/posts/ios/documentation-using-jazzy/","title":"Jazzy를 이용한 코드 문서화"},{"content":"들어가기 애플의 약관에 따라 앱스토어에서 발생한 매출액이 50달러를 넘으면 총 매출의 30%를 제한 금액(카드사 16%, 애플 13%, 운영설비 1%)을 그 다음달에 개발자에게 지급한다. 이때 각 나라의 정책에 따라 수익금에 대해 소득세가 과세되는데, 적절한 서류를 제출함으로써 이 금액을 면제받을 수 있다. 미국 미국에서 판매한 금액에 대해서는 70% 수익에 대해 미국 국세청(IRS)에 의해 30%의 원천징수를 당하게 되므로 결과적으로 수익은 49%가 된다\n미국과 한국 사이에는 이중과세방지협약이 체결되어 있어, 미국에서의 원천징수액을 완전히 면제받을 수 있다.\n미국 원천세 감면신청을 위한 서류는 W8-BEN인데 이 서류를 작성하기 위해서는 EIN(Employer Identification Number)이 필요하다.\nEIN 발급을 위해서는 SS-4 서류를 제출해야 한다.\n해외에서의 EIN 발급은 IRS에 팩스를 보내거나 전화하면 된다.\n개인개발자의 SS-4 Form 기재사항은 다음과 같다.\n1 2 3 4 5 6 7 1. 자신의 이름. 4a. 자신의 주소지 (상세) 4b. 자신의 주소지 , 도시 , 구 우편번호 8a. 법인이 아닌 개인개발자라면 소속회사는 없는것으로 간주한다. No에 체크 9a. sole proprier 를 체크 10. Compliance with IRS withholding rate 를 체크 18. 이전에 EIN 받은적이 있느냐는 항목: 자신에 맞게 체크 맨밑에 친필서명, 날짜, 전화번호및 팩스번호 기입후 IRS 사무소인 미국 (304)-707-9471로 전송한다.\n전화에 의한 신청 팩스는 왔다갔다 하는 시간이 많이 걸려서 싫다는 사람은 전화로 신청한다. 001-1-267-941-1099에 전화해서 1번(영어)-\u0026gt;1번(외국에서 신청)을 눌러 상담원과 연결한다. 위에서 설명한 SS-4 Form 기재사항을 영어로 대답해주고 그 외 필요한 사항을 정확히 전달해주면 그자리에서 바로 EIN을 발급해준다. EIN이 발급되면 확인증을 팩스로 보내주고 우편으로도 발송해준다. 혹시 스펠링을 틀릴까 걱정되면 Phonetic 차트를 이용하자.\nEIN을 받았으면 Appstore Connect의 계약, 세금 및 금융거래 -\u0026gt; 유료 앱 메뉴에서 W8-BEN 서류를 온라인으로 제출한다.\n일본 동일한 프로세스가 일본시장에 대해서도 이루어진다. 일본에서 앱 판매시 원천징수율은 20%인데 일본도 역시 우리나라와 이중과세방지협약을 맺고 있으므로 소득세 경감신청을 할 수 있다.\n이를 위해서는 租税条約に関する届出（使用料に対する所得税及び復興特別所得税の軽減・免除）［様式3］을 작성해야 한다.\n이 서류는 수작업으로 작성하는게 아니라 Appstore Connect의 계약, 세금 및 금융거래 -\u0026gt; 유료 앱 메뉴에서 필요사항을 기입하면 자동으로 작성된 PDF 서류가 다운로드 된다.\n자동기입된 서류를 프린트후 서명하여 다음 주소로 보내면 완료이다. 처리는 약 90일 정도까지 걸릴 수 있다고 한다.\n1 Apple Inc. MS 198-2RA, 12545 Riata Vista Circle, Austin, TX 78727, USA ","date":"2019-05-01T16:16:09+09:00","permalink":"https://cliearl.github.io/posts/ios/apple-appstore-tax-related/","title":"Apple Appstore 개인개발자 소득세 면제 받기"},{"content":"Xcode 프로젝트 설정 프로젝트 생성시 Product Name은 스페이스 없는 연속된 글자로 설정한다. Camelcase를 쓰면 알아보기 좋다. Version은 기본값인 1.0 보다는 1.0.0 으로 쓴다. Apple Developer 설정 developer.apple.com -\u0026gt; Certificates, Identifiers \u0026amp; Profiles -\u0026gt; Identifiers -\u0026gt; App IDs 에서 와일드카드가 아닌 프로젝트의 고유한 App ID를 작성해야 한다. 이때 입력하는 번들ID는 프로젝트의 번들ID와 일치해야 한다.\nApp ID 는 Xcode -\u0026gt; Capabilities 에서 메뉴 중 아무거나 하나를 ON으로 해 주면 자동으로 등록되므로 문제없이 하고 싶다면 이 방법을 추천한다.\niOS Distribution용 Certificate가 없다면 생성해 주어야 한다. 이 때 CSR 파일이 요구된다\nCSR(Certificate Signing Request)파일은 실제 개발에 사용하는 맥북의 고유한 키 파일이다.\n런처패드 -\u0026gt; 기타 -\u0026gt; 키체인 접근 -\u0026gt; 인증서 지원 -\u0026gt; 인증 기관에서 인증서 요청 -\u0026gt; 디스크에 저장됨 으로 CSR파일을 생성 및 저장한다. 도큐먼트 폴더에 일괄적으로 모아두면 파악하기 좋다.\ndeveloper.apple.com의 Provisioning Profiles -\u0026gt; Distribution -\u0026gt; +버튼으로 추가 -\u0026gt; App store 선택 -\u0026gt; App ID 선택 -\u0026gt; Download 후 실행하면 키체인에 등록된다.\n맥북에 있는 Provisioning Profile이 충돌할 경우 파일을 다 지우고 다시 설치하면 된다.\nProvisioning Profile 파일은 Finder -\u0026gt; 이동 메뉴에서 Option키 클릭 -\u0026gt; 라이브러리 -\u0026gt; MobileDevice에 자동으로 저장된다.\nApp Store Connect 설정 1 appstoreconnect.apple.com에서 My Apps (나의 앱) -\u0026gt; New iOS App 을 선택했을때 번들ID가 뜨면 Apple Developer에서 생성한 App ID가 iTunes Connect에 연동된 것이다. SKU는 아무렇게나 넣어도 되는데 번들ID를 그대로 넣어주는게 편하다. Xcode에서 Appstore에 업로드 Xcode에서 실행을 시뮬레이터가 아닌 디바이스를 선택 메뉴의 Product -\u0026gt; Archive -\u0026gt; Validate 로 앱스토어에 업로드 할 패키지를 생성 Submit 과정에서 Validate가 이루어지기 때문에 Validate는 미리 안해도 되지만 만일을 위해서 수행한다 패키지가 생성되면 Archive -\u0026gt; Submit 으로 업로드. 업로드시 동일한 빌드넘버를 가진 빌드를 중복해서 올릴 수 없으므로 작업시 빌드넘버는 자동으로 증가하도록 설정하면 편리하다. App Store Connect 설정 2 appstoreconnect.apple.com에서 My Apps(나의 앱) -\u0026gt; Activity(활동 내역) 에서 업로드한 ipa 빌드를 확인할 수 있다. Processing 중이라면 끝나기를 기다려야 하는데 길어도 수십분 정도면 종료된다. 5.5인치 화면(iPhone 8+)와, 12.9인치 화면(iPad 프로)에 대한 스크린샷을 업로드해야 하므로 시뮬레이터로 준비한다. Appstore용 아이콘은 1024x1024, Copyright는 회사이름 게임센터가 필요하면 나의 앱 -\u0026gt; 앱 내 추가 기능 -\u0026gt; Game Center 에서 순위표와 목표달성 테이블을 작성하고 App store 메뉴에서 Game Center를 활성화한다. Build 에서 Xcode로 제출한 Archive를 선택 Pricing 에서 가격설정후 Submit for Review ","date":"2019-05-01T15:46:54+09:00","permalink":"https://cliearl.github.io/posts/ios/register-app-to-appstore/","title":"Apple Appstore에 앱 등록하기"},{"content":"깃 저장소 관리 서비스 Git repositories 를 관리하는 서비스는 여러가지가 있는데 Github는 프라이빗 저장소에 제한이 있다. Gitlab은 시놀로지에 설치는 되는데 Docker를 지원하는 고가의 기종에서만 가능하다. 도커를 지원하는 시놀로지 모델은 다음과 같다.\n19 시리즈 : RS1619xs+, RS1219+, DS1819+ 18 시리즈 : FS1018, RS3618xs, RS2818RP+, RS2418RP+, RS2418+, RS818RP+, RS818+, DS3018xs, DS1618+, DS918+, DS718+, DS218+ 17 시리즈 : FS3017, FS2017, RS18017xs+, RS4017xs+, RS3617xs+, RS3617RPxs, RS3617xs, DS3617xs, DS1817+, DS1517+ 16 시리즈 : RS18016xs+, RS2416RP+, RS2416+, DS916+, DS716+, DS716+II, DS216+, DS216+II 15 시리즈 : RS815RP+, RS815+, RC18015xs+, DS3615xs, DS2415+, DS1815+, DS1515+, DS415+ 14 시리즈 : RS3614xs+, RS3614RPxs, RS3614xs, RS2414RP+, RS2414+, RS814RP+, RS814+ 13 시리즈 : RS10613xs+, RS3413xs+, DS2413+, DS1813+, DS1513+, DS713+ 12 시리즈 : RS3412RPxs, RS3412xs, RS2212RP+, RS2212+, RS812RP+, RS812+, DS3612xs, DS1812+, DS1512+, DS712+, DS412+ 11 시리즈 : RS3411RPxs, RS3411xs, RS2211RP+, RS2211+, DS3611xs, DS2411+, DS1511+, DS411+, DS411+II 10 시리즈 : RS810RP+, RS810+, DS1010+, DS710+ Gogs 선정 어쨌든 프라이빗 소스를 서비스회사에 맡기고 싶진 않아 개인서버에 git을 설치하고 웹에서 매니징을 할수 있게 해 주는 서비스를 찾아보니 Gogs와 Gogs에서 파생되어 나온 Gitea가 있다. 두 서비스의 차이점은 Slant에서 비교했는데 Gogs는 시놀로지 서버에 설치되므로 Gogs를 사용하기로 했다.\nBenchmark of GitBucket / Gogs / Gitea / GitLab on Raspberry Pi 3 를 보면 속도도 다른 서비스들에 비해 충분히 빠른 것 같다.\nGogs 설치 git server 설치 시놀로지에서 git을 사용하기 위해 git server를 설치한다. 유저는 생성하지 않아도 된다.\ngogs 설치하기 https://kimcblog.com/2018/08/28/%EC%8B%9C%EB%86%80%EB%A1%9C%EC%A7%80synology-nas%EC%97%90-github%EC%B2%98%EB%9F%BC-%EC%9A%B4%EC%9A%A9%ED%95%98%EA%B8%B0-feat-gogs-1-2/\nhttps://kimcblog.com/2018/08/28/%ec%8b%9c%eb%86%80%eb%a1%9c%ec%a7%80synology-nas%ec%97%90-github%ec%b2%98%eb%9f%bc-%ec%9a%b4%ec%9a%a9%ed%95%98%ea%b8%b0-feat-gogs-2-2/\n패키지 다운로드 Gogs 홈페이지에서 바이너리를 다운받아 설치한다.\ngogs_0.11.86_linux_armv5를 풀어서 1_create_package 안에다 넣는다.\n인증서에 git.주소 추가후, 역방향프록시를 설정한다.\n시놀로지에서 데몬 사용자 계정은 무조건 root 이다.\n파일업로드 제한 풀기 파일업로드 크기에 제한이 걸려있으니 다음 포스팅을 참고해 풀어준다. 참고로 시놀로지에서 app.ini 파일의 경로는 /volumeX/@appstore/Gogs/gogs/custom/conf/app.ini 이다.\nWindows에서의 git 테스트를 위한 bash 설치 프로그램 및 기능 -\u0026gt; windows 기능 켜기/끄기 -\u0026gt; Linux용 Windows 하위 시스템 설치 -\u0026gt; window store에서 win10용 ubuntu 설치.\n각 폴더에서 바로 실행하기 위해 wsltty 를 설치.\n설치후 알게된 문제 Gogs는 시놀로지에서 root 계정으로밖에 설치할수 없다\n시놀로지는 DSM 6.0이후로 root의 ssh접속을 금한다\nGogs의 ssh 주소는 루트를 기준으로 만들어지는데 시놀로지에서 유저계정을 만들어서 ssh에 접속해도 결국 루트에 액세스할수 없어 ssh를 사용할 수가 없다. 할수없이 https 주소를 써야한다.\nGogs의 remote주소를 https://도메인:포트/git주소 로 설정한뒤 로그인하는 방식으로는 인증에 실패한다. https://계정:패스워드@도메인:포트/git주소 로 설정하면 인증을 통과할 수 있다. 이때 계정은 @마크를 쓰는 이메일이 아닌 평문으로 해야 한다.\n","date":"2019-02-08T00:54:25+09:00","permalink":"https://cliearl.github.io/posts/linux/install-gogs-on-synology/","title":"Synology에 Gogs 설치하기"}]