<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='이번 포스팅에서는 안드로이드의 HTTP 통신에 대해 알아보도록 하겠습니다.
안드로이드에서의 통신 앱에서 가장 많이 수행하는 처리중 하나는 서버에 데이터를 요청하고 받아온 데이터를 단말-다시말해 클라이언트의 화면에 표시하는 것입니다. 이 때 클라이언트와 서버가 통신하는 방식은 크게 소켓연결과 HTTP연결 두 가지로 나눌 수 있습니다.
소켓 연결 소켓은 네트워크 상의 두 프로그램 사이에서 일어나는 양방향 통신중 한 쪽의 엔드 포인트를 의미합니다. 여기서 엔드포인트란 IP와 포트의 조합을 뜻합니다.
소켓 연결방식에서는 클라이언트와 서버가 특정 포트를 통해 연결을 계속 유지하고 있기 때문에 실시간으로 양방향 통신을 할 수 있는데요, 주로 동영상 스트리밍이나, 온라인 게임등에서 사용되는 연결방식입니다.'><title>안드로이드의 HTTP 통신 라이브러리 고찰</title>

<link rel='canonical' href='https://cliearl.github.io/posts/android/android-http-library-review/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='안드로이드의 HTTP 통신 라이브러리 고찰'>
<meta property='og:description' content='이번 포스팅에서는 안드로이드의 HTTP 통신에 대해 알아보도록 하겠습니다.
안드로이드에서의 통신 앱에서 가장 많이 수행하는 처리중 하나는 서버에 데이터를 요청하고 받아온 데이터를 단말-다시말해 클라이언트의 화면에 표시하는 것입니다. 이 때 클라이언트와 서버가 통신하는 방식은 크게 소켓연결과 HTTP연결 두 가지로 나눌 수 있습니다.
소켓 연결 소켓은 네트워크 상의 두 프로그램 사이에서 일어나는 양방향 통신중 한 쪽의 엔드 포인트를 의미합니다. 여기서 엔드포인트란 IP와 포트의 조합을 뜻합니다.
소켓 연결방식에서는 클라이언트와 서버가 특정 포트를 통해 연결을 계속 유지하고 있기 때문에 실시간으로 양방향 통신을 할 수 있는데요, 주로 동영상 스트리밍이나, 온라인 게임등에서 사용되는 연결방식입니다.'>
<meta property='og:url' content='https://cliearl.github.io/posts/android/android-http-library-review/'>
<meta property='og:site_name' content='냉동코더의 기술블로그'>
<meta property='og:type' content='article'><meta property='article:section' content='Posts' /><meta property='article:tag' content='http' /><meta property='article:tag' content='Library' /><meta property='article:published_time' content='2021-10-23T10:58:16&#43;09:00'/><meta property='article:modified_time' content='2021-10-23T10:58:16&#43;09:00'/>
<meta name="twitter:title" content="안드로이드의 HTTP 통신 라이브러리 고찰">
<meta name="twitter:description" content="이번 포스팅에서는 안드로이드의 HTTP 통신에 대해 알아보도록 하겠습니다.
안드로이드에서의 통신 앱에서 가장 많이 수행하는 처리중 하나는 서버에 데이터를 요청하고 받아온 데이터를 단말-다시말해 클라이언트의 화면에 표시하는 것입니다. 이 때 클라이언트와 서버가 통신하는 방식은 크게 소켓연결과 HTTP연결 두 가지로 나눌 수 있습니다.
소켓 연결 소켓은 네트워크 상의 두 프로그램 사이에서 일어나는 양방향 통신중 한 쪽의 엔드 포인트를 의미합니다. 여기서 엔드포인트란 IP와 포트의 조합을 뜻합니다.
소켓 연결방식에서는 클라이언트와 서버가 특정 포트를 통해 연결을 계속 유지하고 있기 때문에 실시간으로 양방향 통신을 할 수 있는데요, 주로 동영상 스트리밍이나, 온라인 게임등에서 사용되는 연결방식입니다.">
    <link rel="shortcut icon" href="favicon/favicon.ico" />

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-769063-3', 'auto');
	
	ga('send', 'pageview');
}
</script>
    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "dark");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>Back</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/android/" >
                android
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/posts/android/android-http-library-review/">안드로이드의 HTTP 통신 라이브러리 고찰</a>
    </h2>

    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Oct 23, 2021</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    6 minute read
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <p>이번 포스팅에서는 안드로이드의 HTTP 통신에 대해 알아보도록 하겠습니다.</p>
<h2 id="안드로이드에서의-통신">안드로이드에서의 통신</h2>
<p>앱에서 가장 많이 수행하는 처리중 하나는 서버에 데이터를 요청하고 받아온 데이터를 단말-다시말해 클라이언트의 화면에 표시하는 것입니다. 이 때 클라이언트와 서버가 통신하는 방식은 크게 소켓연결과 HTTP연결 두 가지로 나눌 수 있습니다.</p>
<h3 id="소켓-연결">소켓 연결</h3>
<p><a class="link" href="https://docs.oracle.com/javase/tutorial/networking/sockets/definition.html"  target="_blank" rel="noopener"
    >소켓</a>은 네트워크 상의 두 프로그램 사이에서 일어나는 양방향 통신중 한 쪽의 엔드 포인트를 의미합니다. 여기서 엔드포인트란 IP와 포트의 조합을 뜻합니다.</p>
<p>소켓 연결방식에서는 클라이언트와 서버가 특정 포트를 통해 연결을 계속 유지하고 있기 때문에 실시간으로 양방향 통신을 할 수 있는데요, 주로 동영상 스트리밍이나, 온라인 게임등에서 사용되는 연결방식입니다.</p>
<p><a class="link" href="https://socket.io/blog/native-socket-io-and-android/"  target="_blank" rel="noopener"
    >Native Socket.IO and Android</a> 에 소켓통신을 사용해서 채팅앱을 만드는 법을 설명하고 있으니 궁금하신분은 참고하시면 좋을 것 같습니다.</p>
<h3 id="http-연결">HTTP 연결</h3>
<p>HTTP는 <a class="link" href="https://ko.wikipedia.org/wiki/HTTP"  target="_blank" rel="noopener"
    >HyperText Transfer Protocol</a>의 약자로, 80번 포트를 사용하여 웹 상에서 정보를 주고받을 수 있는 프로토콜을 말합니다. HTTP 통신에서는 클라이언트가 서버에 헤더(header)와 바디(body)로 이루어진 <a class="link" href="https://developer.mozilla.org/ko/docs/Web/HTTP/Messages"  target="_blank" rel="noopener"
    >메시지</a>를 요청(request)합니다. 그러면 서버는 이 요청을 처리하고 <a class="link" href="https://ko.wikipedia.org/wiki/HTTP_%EC%83%81%ED%83%9C_%EC%BD%94%EB%93%9C"  target="_blank" rel="noopener"
    >응답코드</a>와 함께 응답(response)을 반환하게 됩니다.</p>
<ul>
<li>
<p>Connectionless : HTTP 연결은 소켓을 사용해서 접속을 만들지만, 용건이 있을때만 연결했다가 용건이 끝나면 연결을 끊게 되어 있습니다. 이걸 <code>Connectionless</code>하다고 표현하는데, 이렇게 하면 서버에 여유가 생겨 더 많은 접속요구에 대응할 수 있게 됩니다.</p>
</li>
<li>
<p>Stateless : 통신이 일어날때마다 새로운 접속을 생성하고 삭제하는 <code>Connectionless</code> 특징때문에 HTTP 통신에서는 기본적으로 서버가 클라이언트를 식별할 수가 없는데 이것을 <code>Stateless</code>하다고 합니다. 그래서 서버가 클라이언트를 기억해야 할 경우 쿠키나 세션, 혹은 토큰이라는 기술을 사용하게 됩니다.</p>
</li>
</ul>
<h3 id="http-method">HTTP Method</h3>
<p><a class="link" href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html"  target="_blank" rel="noopener"
    >HTTP Method</a>란 클라이언트가 서버에 메시지를 보낼 때 어떠한 목적을 가졌는지 밝히는 것으로, 다음과 같은 것들이 있습니다. 일반적으로 많이 사용되는 GET, POST, PUT, DELETE 이외에도 여러가지 명령어들이 있습니다.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>서버에 리소스를 요청합니다. 서버를 수정하지 않기 때문에 safe method로 분류.</td>
</tr>
<tr>
<td>HEAD</td>
<td>GET과 같지만 서버가 본문(body)을 포함하지 않음.</td>
</tr>
<tr>
<td>POST</td>
<td>클라이언트에서 요청한 URL에 본문의 내용으로 새로운 리소스를 생성.</td>
</tr>
<tr>
<td>PUT</td>
<td>클라이언트가 요청한 내용으로 서버의 리소스를 수정.</td>
</tr>
<tr>
<td>DELETE</td>
<td>서버의 리소스를 삭제.</td>
</tr>
<tr>
<td>CONNECT</td>
<td>요청 리소스에 대해 양방향 연결을 수립, 예로 프록시를 통한 SSL 연결수립에  사용될 수 있음.</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>서버가 어떤 HTTP 메소드를 지원하는지 물어봄.</td>
</tr>
<tr>
<td>TRACE</td>
<td>메시지의 변조여부 확인을 위해, 서버가 수신한 클라이언트의 메시지를 반환하도록 함.</td>
</tr>
<tr>
<td>PATCH</td>
<td>PUT은 리소스 전체를 수정하나, PATCH는 해당 리소스의 일부만을 수정.</td>
</tr>
</tbody>
</table>
<h3 id="restful-api">RESTful API</h3>
<p><a class="link" href="https://cloud.google.com/apis/docs/overview"  target="_blank" rel="noopener"
    >구글</a>, <a class="link" href="https://developers.facebook.com/docs/graph-api"  target="_blank" rel="noopener"
    >페이스북</a>, <a class="link" href="https://developer.twitter.com/en/docs/api-reference-index"  target="_blank" rel="noopener"
    >트위터</a>, <a class="link" href="https://developers.naver.com/docs/common/openapiguide/"  target="_blank" rel="noopener"
    >네이버</a>, <a class="link" href="https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api"  target="_blank" rel="noopener"
    >카카오</a> 등 많은 IT회사는 자기 회사의 서비스를 이용할 수 있도록 REST API를 제공합니다. REST API라는게 뭘까요?</p>
<p>REST(Representational State Transfer)는 HTTP 기반으로 필요한 자원에 접근하는 방식을 정해놓은 네트워크 아키텍처입니다. 일반적으로 다음과 같은 <a class="link" href="https://www.redhat.com/ko/topics/api/what-is-a-rest-api"  target="_blank" rel="noopener"
    >기준</a>을 만족하면 RESTful 하다고하며 RESTful하게 작동하도록 만든 API를 RESTful API라고 합니다.</p>
<ul>
<li>클라이언트와 서버의 분리</li>
<li>무상태(Stateless)</li>
<li>캐시 처리가 가능해야 함</li>
<li>시스템이 계층화(Layered) 되어있어야 함</li>
<li>일관성 있는 인터페이스</li>
</ul>
<p>Http Method와 RESTful API의 대응은 다음 <a class="link" href="https://www.restapitutorial.com/lessons/httpmethods.html"  target="_blank" rel="noopener"
    >표</a>와 같이 정리할 수 있습니다.</p>
<table>
<thead>
<tr>
<th>HTTP Method</th>
<th>CRUD</th>
<th>Entire Collection (e.g. /customers)</th>
<th>Specific Item (e.g. /customers/{id})</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>Create</td>
<td>201 (Created), &lsquo;Location&rsquo; header with link to /customers/{id} containing new ID.</td>
<td>404 (Not Found), 409 (Conflict) if resource already exists..</td>
</tr>
<tr>
<td>GET</td>
<td>Read</td>
<td>200 (OK), list of customers. Use pagination, sorting and filtering to navigate big lists.</td>
<td>200 (OK), single customer. 404 (Not Found), if ID not found or invalid.</td>
</tr>
<tr>
<td>PUT</td>
<td>Update/Replace</td>
<td>405 (Method Not Allowed), unless you want to update/replace every resource in the entire collection.</td>
<td>200 (OK) or 204 (No Content). 404 (Not Found), if ID not found or invalid.</td>
</tr>
<tr>
<td>PATCH</td>
<td>Update/Modify</td>
<td>405 (Method Not Allowed), unless you want to modify the collection itself.</td>
<td>200 (OK) or 204 (No Content). 404 (Not Found), if ID not found or invalid.</td>
</tr>
<tr>
<td>DELETE</td>
<td>Delete</td>
<td>405 (Method Not Allowed), unless you want to delete the whole collection—not often desirable.</td>
<td>200 (OK). 404 (Not Found), if ID not found or invalid.</td>
</tr>
</tbody>
</table>
<h2 id="android-http-통신-라이브러리">Android HTTP 통신 라이브러리</h2>
<p>안드로이드에는 HTTP 통신을 구현하는 여러가지 라이브러리가 있는데요, 여기서는 주요하게 사용된 몇 가지 라이브러리를 시간순으로 다루어보도록 하겠습니다.</p>
<h3 id="httpclient">HttpClient</h3>
<p>Http 통신을 용이하게 수행하기 위해 Apache에서 <a class="link" href="https://hc.apache.org/httpcomponents-client-4.5.x/current/httpclient/apidocs/org/apache/http/client/HttpClient.html"  target="_blank" rel="noopener"
    >제작</a>한 라이브러리입니다. 안드로이드 초기에 주로 사용되었으며 실제로는 HttpClient를 래핑한 <a class="link" href="https://hc.apache.org/httpcomponents-client-4.5.x/current/httpclient/apidocs/org/apache/http/impl/client/DefaultHttpClient.html"  target="_blank" rel="noopener"
    >DefaultHttpClient</a>나, 안드로이드에 맞게 개수한 <a class="link" href="https://docs.microsoft.com/en-us/dotnet/api/android.net.http.androidhttpclient?view=xamarin-android-sdk-9"  target="_blank" rel="noopener"
    >AndroidHttpClient</a>가 사용되었습니다.</p>
<p>HttpClient는 안드로이드와 독립적으로 개발되는 라이브러리인지라 변경점을 안드로이드 SDK에 일괄적으로 즉시 반영할 수 없었습니다. 결국 버전이 뒤쳐지면서 버그가 계속 발생하게 되었고, HttpClient는 Android 5.1에서 Deprecated 되며 6.0에서는 아예 <a class="link" href="https://developer.android.com/about/versions/pie/android-9.0-changes-28?hl=zh-tw#apache-p"  target="_blank" rel="noopener"
    >삭제</a>되었습니다. 이 시기 클라이언트의 버그는 네이버 D2 블로그의 <a class="link" href="https://d2.naver.com/helloworld/377316"  target="_blank" rel="noopener"
    >Android의 HTTP 클라이언트 라이브러리</a>에 잘 정리되어 있으니 참고하시기 바랍니다.</p>
<h3 id="httpurlconnection">HttpUrlConnection</h3>
<p>HttpClient를 삭제하면서 구글에서 제시한 대안이 <a class="link" href="https://developer.android.com/reference/java/net/HttpURLConnection"  target="_blank" rel="noopener"
    >HttpUrlConnection</a>인데요, 기존의 <a class="link" href="https://developer.android.com/reference/java/net/URLConnection"  target="_blank" rel="noopener"
    >URLConnection</a>에 HTTP를 다루는데 필요한 메서드를 추가한 클래스입니다.</p>
<p><code>URL.openConnection()</code>으로 얻어진 URLConnection 객체를 HttpURLConnection으로 캐스팅하여 데이터 송수신을 행하고 disconnect로 접속을 종료하는 방식으로 사용합니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java">   <span class="n">URL</span> <span class="n">url</span> <span class="o">=</span> <span class="k">new</span> <span class="n">URL</span><span class="o">(</span><span class="s">&#34;http://www.android.com/&#34;</span><span class="o">);</span>
   <span class="n">HttpURLConnection</span> <span class="n">urlConnection</span> <span class="o">=</span> <span class="o">(</span><span class="n">HttpURLConnection</span><span class="o">)</span> <span class="n">url</span><span class="o">.</span><span class="na">openConnection</span><span class="o">();</span>
   <span class="k">try</span> <span class="o">{</span>
     <span class="n">InputStream</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedInputStream</span><span class="o">(</span><span class="n">urlConnection</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">());</span>
     <span class="n">readStream</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
   <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
     <span class="n">urlConnection</span><span class="o">.</span><span class="na">disconnect</span><span class="o">();</span>
   <span class="o">}</span>
</code></pre></div><h3 id="volley">Volley</h3>
<p>HttpUrlConnection을 사용할 때는 Application Not Responding(ANR)을 피하기 위해 백그라운드 스레드도 만들어야하고, 버퍼를 통한 입출력도 준비해야 하고, 캐시나 예외처리도 한땀한땀 다 처리해 주어야 하는 불편함이 있었습니다.</p>
<p>그래서 구글에서는 HTTP 연결을 만들때마다 이런 귀찮은 일을 안해도 되는 라이브러리인 <a class="link" href="https://developer.android.com/training/volley"  target="_blank" rel="noopener"
    >Volley</a>를 2013년 Google I/O에서 <a class="link" href="https://www.youtube.com/watch?v=yhv8l9F44qo"  target="_blank" rel="noopener"
    >발표</a>했습니다. Volley는 다음과 같은 특징이 있다고 하네요.</p>
<ul>
<li>Automatic scheduling of network requests.</li>
<li>Multiple concurrent network connections.</li>
<li>Transparent disk and memory response caching with standard HTTP cache coherence.</li>
<li>Support for request prioritization.</li>
<li>Cancellation request API. You can cancel a single request, or you can set blocks or scopes of requests to cancel.</li>
<li>Ease of customization, for example, for retry and backoff.</li>
<li>Strong ordering that makes it easy to correctly populate your UI with data fetched asynchronously from the network.</li>
<li>Debugging and tracing tools.</li>
</ul>
<p>사용법은 다음과 같습니다. HTTP 메소드와 url 정보를 가진 <a class="link" href="https://javadoc.io/static/com.android.volley/volley/1.1.1/com/android/volley/Request.html"  target="_blank" rel="noopener"
    >Request</a>를 만들어서 <a class="link" href="https://developer.android.com/training/volley/requestqueue"  target="_blank" rel="noopener"
    >RequestQueue</a>에 넣어줍니다. 그러면 Volley가 알아서 스레드를 만들고 HttpUrlConnection으로 통신을 수행한 뒤 response를 반환해줍니다. 코드를 보시면 HttpUrlConnection을 직접 사용할 때보다 코드가 더 읽기 쉬워진 것을 알 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="k">val</span> <span class="py">textView</span> <span class="p">=</span> <span class="n">findViewById</span><span class="p">&lt;</span><span class="n">TextView</span><span class="p">&gt;(</span><span class="n">R</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">text</span><span class="p">)</span>

<span class="k">val</span> <span class="py">queue</span> <span class="p">=</span> <span class="n">Volley</span><span class="p">.</span><span class="n">newRequestQueue</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
<span class="k">val</span> <span class="py">url</span> <span class="p">=</span> <span class="s2">&#34;https://www.google.com&#34;</span>

<span class="k">val</span> <span class="py">stringRequest</span> <span class="p">=</span> <span class="n">StringRequest</span><span class="p">(</span><span class="n">Request</span><span class="p">.</span><span class="n">Method</span><span class="p">.</span><span class="n">GET</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span>
        <span class="n">Response</span><span class="p">.</span><span class="n">Listener</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="p">{</span> <span class="n">response</span> <span class="o">-&gt;</span>
            <span class="c1">// Display the first 500 characters of the response string.
</span><span class="c1"></span>            <span class="n">textView</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="s2">&#34;Response is: </span><span class="si">${response.substring(0, 500)}</span><span class="s2">&#34;</span>
        <span class="p">},</span>
        <span class="n">Response</span><span class="p">.</span><span class="n">ErrorListener</span> <span class="p">{</span> <span class="n">textView</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="s2">&#34;That didn&#39;t work!&#34;</span> <span class="p">})</span>

<span class="n">queue</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">stringRequest</span><span class="p">)</span>
</code></pre></div><h3 id="okhttp">OkHttp</h3>
<p>그런 와중에 <a class="link" href="https://github.com/square/okhttp/blob/master/docs/changelog_1x.md#version-100"  target="_blank" rel="noopener"
    >2013년 5월 6일</a>엔 Square에서 <a class="link" href="https://square.github.io/okhttp/"  target="_blank" rel="noopener"
    >OkHttp</a>라는 HTTP 클라이언트 라이브러리를 발표합니다. 이 라이브러리는 <a class="link" href="https://github.com/square/okio"  target="_blank" rel="noopener"
    >Okio</a>와 코틀린을 활용해 쓰여졌고 다음과 같은 특징이 있습니다. Connection pooling과 Redirection을 도입해 접속을 더 안정적이게 하면서도, 속도를 개선시킬 수 있는 여러가지 기술이 적용된 것으로 보입니다.</p>
<ul>
<li>HTTP/2 support allows all requests to the same host to share a socket.</li>
<li>Connection pooling reduces request latency (if HTTP/2 isn’t available).</li>
<li>Transparent GZIP shrinks download sizes.</li>
<li>Response caching avoids the network completely for repeat requests.</li>
</ul>
<p>사용법은 다음과 같습니다. 클라이언트 인스턴스를 생성하고 리퀘스트 객체를 만들어 클라이언트에 전해주면 response가 반환되는 구조를 가지고 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">OkHttpClient</span> <span class="n">client</span> <span class="o">=</span> <span class="k">new</span> <span class="n">OkHttpClient</span><span class="o">();</span>

<span class="n">String</span> <span class="nf">run</span><span class="o">(</span><span class="n">String</span> <span class="n">url</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
  <span class="n">Request</span> <span class="n">request</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Request</span><span class="o">.</span><span class="na">Builder</span><span class="o">()</span>
      <span class="o">.</span><span class="na">url</span><span class="o">(</span><span class="n">url</span><span class="o">)</span>
      <span class="o">.</span><span class="na">build</span><span class="o">();</span>

  <span class="k">try</span> <span class="o">(</span><span class="n">Response</span> <span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">newCall</span><span class="o">(</span><span class="n">request</span><span class="o">).</span><span class="na">execute</span><span class="o">())</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">response</span><span class="o">.</span><span class="na">body</span><span class="o">().</span><span class="na">string</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="retrofit">Retrofit</h3>
<p><a class="link" href="https://square.github.io/retrofit/"  target="_blank" rel="noopener"
    >Retrofit</a>은 OkHttp를 개발한 Square에서 <a class="link" href="https://github.com/square/retrofit/blob/master/CHANGELOG.md"  target="_blank" rel="noopener"
    >2013/05/14</a> 에 발표한 라이브러리입니다. HttpURLConnection을 사용하기 편하도록 랩핑한게 Volley라면 Retrofit은 OkHttp를 랩핑한 것입니다.</p>
<p>사용법은 다음과 같습니다. 우선 REST API 콜을 인터페이스 형식으로 준비합니다. 그리고 Retrofit 객체를 만들어서 인터페이스의 인스턴스를 생성합니다. 마지막으로 인터페이스를 동기 혹은 비동기적으로 구동시켜 response를 반환받게 되어 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">GitHubService</span> <span class="o">{</span>
  <span class="nd">@GET</span><span class="o">(</span><span class="s">&#34;users/{user}/repos&#34;</span><span class="o">)</span>
  <span class="n">Call</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Repo</span><span class="o">&gt;&gt;</span> <span class="nf">listRepos</span><span class="o">(</span><span class="nd">@Path</span><span class="o">(</span><span class="s">&#34;user&#34;</span><span class="o">)</span> <span class="n">String</span> <span class="n">user</span><span class="o">);</span>
<span class="o">}</span>

<span class="n">Retrofit</span> <span class="n">retrofit</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Retrofit</span><span class="o">.</span><span class="na">Builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">baseUrl</span><span class="o">(</span><span class="s">&#34;https://api.github.com/&#34;</span><span class="o">)</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
<span class="n">GitHubService</span> <span class="n">service</span> <span class="o">=</span> <span class="n">retrofit</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">GitHubService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="n">Call</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Repo</span><span class="o">&gt;&gt;</span> <span class="n">repos</span> <span class="o">=</span> <span class="n">service</span><span class="o">.</span><span class="na">listRepos</span><span class="o">(</span><span class="s">&#34;octocat&#34;</span><span class="o">);</span>
</code></pre></div><h3 id="ktor">Ktor</h3>
<p>Jetbrains에서 개발한 <a class="link" href="https://ktor.io/"  target="_blank" rel="noopener"
    >Ktor</a>는 코틀린을 이용해 비동기 서버와 클라이언트를 구축할수 있게 해주는 라이브러리입니다. <a class="link" href="https://github.com/ktorio/ktor"  target="_blank" rel="noopener"
    >1.6.3</a> 버전까지 발표되어 있으며 현재도 활발한 업데이트가 이루어지고 있습니다</p>
<p>안드로이드에서의 사용법은 다음과 같습니다. 코루틴 스코프 안에서 <a class="link" href="https://api.ktor.io/ktor-client/ktor-client-core/ktor-client-core/io.ktor.client.engine/-http-client-engine-config/index.html"  target="_blank" rel="noopener"
    >Http 클라이언트</a>를 만들어서 request를 보내고 response를 확인한  뒤, 클라이언트의 리소스를 close로 반환하면 됩니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="n">CoroutineScope</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">IO</span><span class="p">).</span><span class="n">launch</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">client</span> <span class="p">=</span> <span class="n">HttpClient</span><span class="p">()</span>
  <span class="k">val</span> <span class="py">response</span><span class="p">:</span> <span class="n">HttpResponse</span> <span class="p">=</span> <span class="n">client</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="s2">&#34;https://ktor.io/&#34;</span><span class="p">)</span>
  <span class="k">val</span> <span class="py">stringBody</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="n">response</span><span class="p">.</span><span class="n">receive</span><span class="p">()</span>
  <span class="n">client</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><h2 id="volley-or-retrofit">Volley or Retrofit?</h2>
<p>안드로이드의 통신 라이브러리로는 주로 Volley 나 Retrofit을 이용하실 겁니다. 그렇다면 둘 중 어느것을 사용해야 할까요?</p>
<p><a class="link" href="https://github.com/google/volley"  target="_blank" rel="noopener"
    >Volley</a>와 <a class="link" href="https://github.com/square/retrofit"  target="_blank" rel="noopener"
    >Retrofit</a>은 지금도 꾸준히 갱신되고 있는 라이브러리인데요, 두 라이브러리의 기능차이는 다음과 같이 정리할 수 있을 것 같습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">Function</th>
<th style="text-align:center">Volley</th>
<th style="text-align:center">Retrofit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Automatic Parsing</td>
<td style="text-align:center">No</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td style="text-align:center">Caching</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">No</td>
</tr>
<tr>
<td style="text-align:center">Retrying</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">No</td>
</tr>
<tr>
<td style="text-align:center">Post Requests &amp; Multipart uploads</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Partly</td>
</tr>
<tr>
<td style="text-align:center">Image Loading</td>
<td style="text-align:center">Built-in</td>
<td style="text-align:center">No</td>
</tr>
</tbody>
</table>
<p>속도에 있어서는 Volley가 빠르다는 사람도 있고 Retrofit이 빠르다는 사람도 있습니다만 결국 밀리세컨드 스케일의 차이라 속도만으로 어느 한쪽을 선택하는건 어려울 것 같네요. 코드 가독성은 대부분 Retrofit이 더 좋다는 평가인 것 같습니다. 사용법을 보시고 더 편한 쪽을 선택하시면 될 것 같습니다.</p>
<p>개인적으로는 API 콜을 인터페이스로 정의해서 사용하는 Retrofit이 전체 구조를 파악하기 더 좋은것 같아 이쪽을 선호합니다. 한가지 재밌는 것은 구글의 <a class="link" href="https://developer.android.com/jetpack/guide#recommended-app-arch"  target="_blank" rel="noopener"
    >권장 앱 아키텍처</a>에서는 HTTP 통신에 Volley가 아닌 Retrofit을 추천하고 있다는 점입니다.</p>
<p><figure 
	>
	<a href="/images/posts/final-architecture.png" >
		<img src="/images/posts/final-architecture.png"
			
			
			
			loading="lazy"
			alt="출처 : https://developer.android.com/jetpack/guide#recommended-app-arch">
	</a>
	
	<figcaption>출처 : <a href="https://developer.android.com/jetpack/guide#recommended-app-arch">https://developer.android.com/jetpack/guide#recommended-app-arch</a></figcaption>
	
</figure></p>
<p>이렇게 해서 HTTP 통신과 안드로이드의 통신 라이브러리에 대해 알아보았습니다.</p>
<div class="video-wrapper">
    <iframe loading="lazy" 
            src="https://www.youtube.com/embed/z69FsR_-e_s" 
            allowfullscreen 
            title="YouTube Video"
    >
    </iframe>
</div>


</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/http/">http</a>
        
            <a href="/tags/library/">Library</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY 4.0</span>
    </section>
    </footer>


    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">Related contents</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/posts/android/android-studio-plugins/">
        
        

        <div class="article-details">
            <h2 class="article-title">내가 Android Studio에서 사용하는 Plugins</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/posts/android/implement-crud-with-sqliteopenhelper/">
        
        

        <div class="article-details">
            <h2 class="article-title">SQLite 이해하고 SQLiteOpenHelper로 CRUD 구현하기</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/posts/android/understanding-singleton-pattern/">
        
        

        <div class="article-details">
            <h2 class="article-title">알기쉬운 Singleton Pattern</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/posts/android/android-gradle-java-11/">
        
        

        <div class="article-details">
            <h2 class="article-title">Android Studio Arctic Fox와 JDK 11의 도입</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/posts/android/jsoup-lotto-checker/">
        
        

        <div class="article-details">
            <h2 class="article-title">jsoup으로 로또 홈페이지의 당첨번호 파싱하기</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    
        
    <script src="https://utteranc.es/client.js" 
        repo="cliearl/cliearl.github.io"
        issue-term="cliearl"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;
        setUtterancesTheme(document.documentElement.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        setUtterancesTheme(e.detail)
    })
</script>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2019 - 
        
        2021 냉동코더의 기술블로그
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.5.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">Table of contents</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#안드로이드에서의-통신">안드로이드에서의 통신</a>
      <ol>
        <li><a href="#소켓-연결">소켓 연결</a></li>
        <li><a href="#http-연결">HTTP 연결</a></li>
        <li><a href="#http-method">HTTP Method</a></li>
        <li><a href="#restful-api">RESTful API</a></li>
      </ol>
    </li>
    <li><a href="#android-http-통신-라이브러리">Android HTTP 통신 라이브러리</a>
      <ol>
        <li><a href="#httpclient">HttpClient</a></li>
        <li><a href="#httpurlconnection">HttpUrlConnection</a></li>
        <li><a href="#volley">Volley</a></li>
        <li><a href="#okhttp">OkHttp</a></li>
        <li><a href="#retrofit">Retrofit</a></li>
        <li><a href="#ktor">Ktor</a></li>
      </ol>
    </li>
    <li><a href="#volley-or-retrofit">Volley or Retrofit?</a></li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
