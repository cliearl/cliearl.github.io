<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='이번 포스팅에서는 코틀린의 코루틴(Coroutine)에 대해 알아보도록 하겠습니다.
'><title>알기쉬운 코루틴 이론</title>

<link rel='canonical' href='https://cliearl.github.io/posts/android/coroutine-principle/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='알기쉬운 코루틴 이론'>
<meta property='og:description' content='이번 포스팅에서는 코틀린의 코루틴(Coroutine)에 대해 알아보도록 하겠습니다.
'>
<meta property='og:url' content='https://cliearl.github.io/posts/android/coroutine-principle/'>
<meta property='og:site_name' content='냉동코더의 기술블로그'>
<meta property='og:type' content='article'><meta property='article:section' content='Posts' /><meta property='article:tag' content='kotlin' /><meta property='article:tag' content='coroutine' /><meta property='article:published_time' content='2021-06-28T22:01:50&#43;09:00'/><meta property='article:modified_time' content='2021-06-28T22:01:50&#43;09:00'/>
<meta name="twitter:title" content="알기쉬운 코루틴 이론">
<meta name="twitter:description" content="이번 포스팅에서는 코틀린의 코루틴(Coroutine)에 대해 알아보도록 하겠습니다.
">
    <link rel="shortcut icon" href="favicon/favicon.ico" />

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-769063-3', 'auto');
	
	ga('send', 'pageview');
}
</script>
    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "dark");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>Back</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/android/" >
                android
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/posts/android/coroutine-principle/">알기쉬운 코루틴 이론</a>
    </h2>

    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Jun 28, 2021</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    6 minute read
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <p>이번 포스팅에서는 코틀린의 코루틴(Coroutine)에 대해 알아보도록 하겠습니다.</p>
<h2 id="코루틴의-개념">코루틴의 개념</h2>
<p>안드로이드에서는 <a class="link" href="https://developer.android.com/reference/android/os/AsyncTask"  target="_blank" rel="noopener"
    >AsyncTask</a>를 이용해서 손쉽게 비동기 프로그래밍을 구현했었지만 <a class="link" href="https://android-review.googlesource.com/c/platform/frameworks/base/&#43;/1156409/6/core/java/android/os/AsyncTask.java#40"  target="_blank" rel="noopener"
    >구글</a>이 다음과 같이 밝힌 것처럼 메모리 누수등 여러가지 문제가 있었습니다. 그래서 API 30부터는 AsyncTask를 deprecate 시키고 <a class="link" href="https://developer.android.com/kotlin/coroutines"  target="_blank" rel="noopener"
    >코루틴</a>을 사용하도록 권장하고 있습니다.</p>
<blockquote>
<p>AsyncTask was intended to enable proper and easy use of the UI thread. However, the most common use case was for integrating into UI, and that would cause Context leaks, missed callbacks, or crashes on configuration changes. It also has inconsistent behavior on different versions of the platform, swallows exceptions from {@code doInBackground}, and does not provide much utility over using {@link Executor}s directly.</p>
</blockquote>
<p>코루틴은 1958년 멜빈 콘웨이가 처음 제창했다고 하는 개념으로 현재 <a class="link" href="https://en.wikipedia.org/wiki/Coroutine#Programming_languages_with_native_support"  target="_blank" rel="noopener"
    >여러 프로그래밍 언어</a>에 구현되어 있으며 코틀린만의 고유한 개념은 아닙니다.</p>
<p>프로그래밍에서 루틴이란 프로그램의 흐름을 추상적으로 일컫는 말입니다. 루틴은 크게 메인루틴과 서브루틴으로 나눌 수 있는데요. 예를들어 main 함수에 의해 수행되는 프로그램의 흐름을 메인루틴이라고 한다면, main 함수 안에서 실행되는 개별 함수들에 의해 수행되는 흐름을 서브루틴이라 비유할 수 있겠습니다.</p>
<p>루틴의 한 종류인 함수는 호출을 함으로써 그 내부에 진입하여 내부에서 처리를 수행하고, 처리가 끝나면 함수도 종료되는 구조를 가지고 있기 때문에 보통은 루틴이 일직선적인 흐름을 가지고 있다고 할 수 있습니다.</p>
<p>그런데 코루틴의 특징은 이 일직선적인 흐름을 중간에 지연시켰다가(suspend) 다시 재시작하는(resume) 것이 가능합니다. 따라서 코루틴을 사용하면 루틴이 실행 되었더라도 더 바쁜 다른 루틴이 실행되는동안 잠시 멈췄다가, 바쁜게 끝나면 재시작하여 나머지 작업을 끝내는 형태의 비동기 프로그래밍이 가능하게 됩니다.</p>
<p>또 코루틴은 자기 스스로가 메인루틴이 되면서도 서브루틴이 될 수 있다는 특징도 있습니다.</p>
<h2 id="코루틴과-스레드">코루틴과 스레드</h2>
<p>구글에서는 AsyncTask를 코루틴으로 대체하여 쓰라고 하고 있기 때문에 얼핏 생각하면 코루틴은 AsyncTask의 약점인 메모리누수가 없는 스레드라고 생각하기 쉽습니다. 그러나 <a class="link" href="https://aaronryu.github.io/2019/05/27/coroutine-and-thread/"  target="_blank" rel="noopener"
    >코루틴은 스레드가 아닙니다</a>.</p>
<h3 id="메모리-구조의-차이">메모리 구조의 차이</h3>
<p><a class="link" href="https://cliearl.github.io/posts/android/progressdialog-thread/"  target="_blank" rel="noopener"
    >ProgressDialog로 Thread와 Handler 이해하기</a> 강의에서 다루었던 것처럼 프로세스속에서 실행되는 독립된 여러 흐름중의 하나를 스레드라고 합니다. 프로세스는 자기가 사용할 메모리영역(Heap)을 할당받는데, 이때 스레드는 Heap 안에서 다시 자신만이 사용할 수 있는 고유의 메모리영역(Stack)을 할당받게 됩니다.</p>
<p>그런데 앞에서 설명했듯이 코루틴은 스택을 할당받지 않고 프로세스의 Heap 메모리를 공유하여 사용하기 때문에 비동기 작업을 구현한다는 점에서는 스레드와 동일한 일을 하고 있지만, 스레드보다는 함수에 가까운 구조를 가지고 있습니다.</p>
<h3 id="수행방식의-차이">수행방식의 차이</h3>
<p>코루틴은 비선점형 멀티태스킹(Non-preemptive Multitasking)이고 스레드는 선점형 멀티태스킹(Preemptive Multitasking)입니다. 스레드는 실제로 멀티코어를 사용함으로써 동시에 복수의 스레드를 처리할 수 있는데요 이것을 <code>병행성</code>이 있다고 합니다. 그런데 코루틴은 CPU를 시간분할하여 사용하기 때문에 실제로는 복수의 작업을 동시에 처리할 수 없어 병행성은 없습니다. 하지만 코루틴은 한번에 한개밖에 실행되지 않음에도 불구하고 전환속도가 빠르기 때문에 외부에서 볼 때는 마치 동시에 처리되는 것처럼 인식되므로 <code>동시성</code>이 있다고 합니다.</p>
<h3 id="코루틴의-장점">코루틴의 장점</h3>
<p>예를들어 세개의 스레드를 사용해야 하는 작업을 코루틴 세개로 만들어 사용할 경우 스택을 따로 할당할 필요가 없으니 사용되는 메모리가 줄어들게 됩니다. 그리고 스레드끼리 처리순서를 조정할 때 메모리를 공유하지 않기 때문에 수행해야 했던 context switching을 하지 않게 되므로 작업전환시의 오버헤드도 줄어들게 됩니다. 한 개의 스레드 안에서 여러개의 코루틴이 돌아가도록 할 수 있으니 스레드를 불필요하게 많이 만들어야 할 필요도 없어지게 됩니다.</p>
<h3 id="코틀린에서의-사용">코틀린에서의 사용</h3>
<p>코틀린의 코루틴 안에서 실행되는 함수에는 <code>suspend</code> 키워드를 붙여서 실행을 보류하거나 재개할수 있다는 표시를 하게 됩니다.</p>
<p><a class="link" href="https://myungpyo.medium.com/%EC%BD%94%EB%A3%A8%ED%8B%B4-%EA%B3%B5%EC%8B%9D-%EA%B0%80%EC%9D%B4%EB%93%9C-%EC%9E%90%EC%84%B8%ED%9E%88-%EC%9D%BD%EA%B8%B0-part-1-dive-3-b174c735d4fa"  target="_blank" rel="noopener"
    >공식 가이드</a>에 따르면 suspend 키워드로 마킹된 함수는 <a class="link" href="https://en.wikipedia.org/wiki/Continuation-passing_style"  target="_blank" rel="noopener"
    >Continuation Passing Style</a>로 변환되고, Coroutine Builder를 통해 적절한 스레드 상에서 시나리오에 따라 동작하도록 구성되게 됩니다.</p>
<h2 id="코루틴-구조">코루틴 구조</h2>
<p>코틀린의 코루틴은 크게 Coroutine Scope, Coroutine Context, Coroutine Builder의 세 부분으로 나눌 수 있습니다.</p>
<h3 id="coroutine-scope">Coroutine Scope</h3>
<p>코루틴의 동작하는 범위를 규정합니다. 스코프 내에서 실행되는 코루틴의 실행을 감시하거나 취소할 수 있습니다.</p>
<h4 id="coroutinescope">CoroutineScope</h4>
<p>다음과 같은 인터페이스로 정의되며 특정한 dispatcher를 지정하여 동작이 실행될 스코프를 제한할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="k">public</span> <span class="k">interface</span> <span class="nc">CoroutineScope</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">val</span> <span class="py">coroutineContext</span><span class="p">:</span> <span class="n">CoroutineContext</span>
<span class="p">}</span>
</code></pre></div><h4 id="globalscope">GlobalScope</h4>
<p>GlobalScope는 CoroutineScope의 한 종류입니다. 안드로이드에서 어플리케이션 라이프사이클을 따르며, 싱글톤으로 최상위 레벨에서 코루틴을 시작하기 때문에 필요할때 만들어 쓰고 버린다는 사용법이 불가능합니다. 일반적으로는 <a class="link" href="https://medium.com/harrythegreat/%EB%B2%88%EC%97%AD-%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%BD%94%EB%A3%A8%ED%8B%B4%EC%9D%98-%ED%8C%A8%ED%84%B4%EA%B3%BC-%EC%95%88%ED%8B%B0%ED%8C%A8%ED%84%B4-6e97f852ea2d"  target="_blank" rel="noopener"
    >사용 자체를 추천하지 않습니다</a>.</p>
<h3 id="coroutine-context">Coroutine Context</h3>
<p>코루틴은 항상 <a class="link" href="https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html"  target="_blank" rel="noopener"
    >Coroutine Context</a>로 구성된 콘텍스트 안에서 실행되는데, 이 콘텍스트는 Dispatchers와 Job으로 구성됩니다.</p>
<h4 id="dispatchers">Dispatchers</h4>
<p><a class="link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html"  target="_blank" rel="noopener"
    >Dispatchers</a>는 코루틴이 실행될 스레드를 지정하는 역할을 합니다. 네가지 타입이 있는데 특징을 간단하게 정리해보면 .Default는 주로 CPU에서 많은 연산이 필요한 처리, .IO는 파일IO나 네트워크 콜을 수행해야 할 때, 그리고 코루틴에서 처리된 값을 UI에 반영할 때는 .Main을 사용한다고 생각하면 될 것 같습니다. Unconfined는 일반적인 용도에서는 사용하지 않기 때문에 무시하셔도 됩니다.</p>
<ul>
<li>
<p>Dispatchers.Default</p>
<ul>
<li>CPU자원을 많이 필요로하는 작업에 사용.</li>
<li>공유 백그라운드 스레드의 common pool에서 동작.</li>
<li>동시작업 가능한 최대 개수는 CPU코어수와 같으며 최소 2개임.</li>
</ul>
</li>
<li>
<p>Dispatchers.IO</p>
<ul>
<li>파일 혹은 소켓IO등의 가볍고 빈번한 IO작업에 사용.</li>
<li>Blocking IO용 공유 스레드풀에서 동작.</li>
<li>필요에 따라 스레드를 추가 생성하거나 없앨 수 있는데 64 or 코어 수 중 큰 수만큼 생성가능함.</li>
<li>Dispatchers.Default와 스레드를 공유하므로 withContext에서 Dispatcher변경시 context switching하지 않고 동일한 스레드에서 실행됨.</li>
</ul>
</li>
<li>
<p>Dispatchers.Main</p>
<ul>
<li>MainCoroutineDispatcher 클래스의 인스턴스이다</li>
<li>안드로이드에서는 UI 오브젝트를 다루는 메인스레드에서 동작</li>
<li>일반적으로 싱글스레드가 된다</li>
</ul>
</li>
<li>
<p>Dispatchers.Unconfined</p>
<ul>
<li>첫번째 지연점까지만 실행된다.</li>
<li>메인스레드에서 동작한다.</li>
<li>일반적인 용도로는 사용하지 않는다.</li>
</ul>
</li>
</ul>
<h4 id="job--deferred">Job &amp; Deferred</h4>
<p>코틀린에서는 코루틴 작업을 <a class="link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/"  target="_blank" rel="noopener"
    >Job</a> 혹은 <a class="link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/"  target="_blank" rel="noopener"
    >Deferred</a>라는 오브젝트로 만들어 다룹니다. Deferred는 결과값을 가지는 Job이므로 둘 다 Job이 되겠습니다.</p>
<p>코루틴이라는 것은 프로그램의 흐름이라고 하는 추상적인 개념인데요, 코루틴 한 덩어리를 한 개의 Job이라는 오브젝트로 만들게 되면 그 오브젝트에 대해 취소나 예외처리를 함으로써 용이하게 코루틴의 흐름제어를 할 수 있게 됩니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="k">val</span> <span class="py">job</span> <span class="p">=</span> <span class="n">scope</span><span class="p">.</span><span class="n">launch</span> <span class="p">{</span>
    <span class="c1">// New coroutine
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>코루틴은 일시정지될수 있는 작업의 흐름이기 때문에 Job은 코루틴의 여러가지 상태를 반영할 수 있도록 다음과 같이 설계되었습니다.</p>
<table>
<thead>
<tr>
<th>State</th>
<th>isActive</th>
<th>isCompleted</th>
<th>isCancelled</th>
</tr>
</thead>
<tbody>
<tr>
<td>New (optional initial state)</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>Active (default initial state)</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>Completing (transient state)</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>Cancelling (transient state)</td>
<td>false</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>Cancelled (final state)</td>
<td>false</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>Completed (final state)</td>
<td>false</td>
<td>true</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>그리고 각 상태는 다음과 같이 전환되죠.</p>
<pre tabindex="0"><code>Job states cycle
                                          wait children
    +-----+ start  +--------+ complete   +-------------+  finish  +-----------+
    | New | -----&gt; | Active | ---------&gt; | Completing  | -------&gt; | Completed |
    +-----+        +--------+            +-------------+          +-----------+
                     |  cancel / fail       |
                     |     +----------------+
                     |     |
                     V     V
                 +------------+                           finish  +-----------+
                 | Cancelling | --------------------------------&gt; | Cancelled |
                 +------------+                                   +-----------+
</code></pre><p>Job 객체에 대해서는 .cancel(), .join(), .start() 등의 메소드가 정의되어 있습니다. .cancel()과 .start()는 위의 다이어그램에서 표시되는 cancel과 start 동작을 구현하는 메소드입니다. join은 코루틴을 병렬처리하지 않고 현재 job에 정의된 작업을 수행하는동안 기다리도록 하는 메소드입니다.</p>
<h3 id="coroutine-builder">Coroutine Builder</h3>
<p>코루틴을 시작하는 방법에는 4가지가 있습니다.</p>
<ul>
<li>launch : 메인 스레드를 블록하지 않는 코루틴 작업을 실행합니다. 결과를 반환할 필요가 없는 작업에 사용하며 Job 객체를 반환합니다.</li>
<li>async : 메인 스레드를 블록하지 않는 코루틴 작업을 실행합니다. 결과를 반환할 필요가 있는 작업에 사용하며 Deferred 객체를 반환합니다.</li>
<li>runBlocking : 메인 스레드를 블록하고 작업을 실행합니다. runBlocking은 테스트 용도등에나 사용하지, 코루틴을 위해서는 <a class="link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html"  target="_blank" rel="noopener"
    >사용하지 말라</a>고 권장하고 있습니다.</li>
<li>withContext : 예를들어 Dispatchers.Main으로 지정된 스코프 안에서 Dispatchers.IO가 필요한 처리를 해야할 일이 있을 수 있습니다. 이 때 Dispatchers 안에 다시 Dispatchers를 정의할 수도 있지만 <a class="link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html"  target="_blank" rel="noopener"
    >withContext</a>를 사용하면 Dispatchers를 간편하게 스위치할 수 있습니다. <a class="link" href="https://developer.android.com/kotlin/coroutines/coroutines-adv#main-safety"  target="_blank" rel="noopener"
    >withContext를 이용한 스코프 전환은 OS에서 관리되므로 오버헤드가 적다</a>고 알려져 있습니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">fetchDocs</span><span class="p">()</span> <span class="p">{</span>                      <span class="c1">// Dispatchers.Main
</span><span class="c1"></span>    <span class="k">val</span> <span class="py">result</span> <span class="p">=</span> <span class="k">get</span><span class="p">(</span><span class="s2">&#34;developer.android.com&#34;</span><span class="p">)</span>  <span class="c1">// Dispatchers.Main
</span><span class="c1"></span>    <span class="n">show</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>                               <span class="c1">// Dispatchers.Main
</span><span class="c1"></span><span class="p">}</span>

<span class="k">suspend</span> <span class="k">fun</span> <span class="nf">get</span><span class="p">(</span><span class="n">url</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">=</span>                 <span class="c1">// Dispatchers.Main
</span><span class="c1"></span>    <span class="n">withContext</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">IO</span><span class="p">)</span> <span class="p">{</span>              <span class="c1">// Dispatchers.IO (main-safety block)
</span><span class="c1"></span>        <span class="cm">/* perform network IO here */</span>          <span class="c1">// Dispatchers.IO (main-safety block)
</span><span class="c1"></span>    <span class="p">}</span>                                          <span class="c1">// Dispatchers.Main
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h2 id="코루틴-지연">코루틴 지연</h2>
<ul>
<li>delay : milisecond단위로 루틴을 잠시 대기시킵니다. Thread.sleep은 스레드 자체를 정지시키는데 반해, delay는 코루틴이 멈추지 않고 대기상태에 들어간다는 점이 다릅니다.</li>
<li>join : Job의 실행이 끝날때까지 대기시킵니다.</li>
<li>await : Deferred의 실행이 끝날때까지 대기시키고 결과값을 반환합니다.</li>
</ul>
<h2 id="코루틴-취소">코루틴 취소</h2>
<p>코루틴 실행을 취소하는데에는 몇가지 방법이 있습니다.</p>
<ul>
<li><a class="link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/cancel.html"  target="_blank" rel="noopener"
    >cancel</a> : 위에서 설명한대로 job을 Cancelling (transient state)로 변화시킵니다.</li>
<li><a class="link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/cancel-and-join.html"  target="_blank" rel="noopener"
    >cancelAndJoin</a> : job을 캔슬하고 Cancelled (final state)가 될 때까지 기다립니다.</li>
<li><a class="link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html"  target="_blank" rel="noopener"
    >withTimeout</a> : 제한시간을 설정하고 그때까지 처리가 끝나지 않았을 경우 블럭을 취소하고 TimeoutCancellationException을 throw합니다.</li>
<li><a class="link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout-or-null.html"  target="_blank" rel="noopener"
    >withTimeoutOrNull</a> : withTimeout을 처리중 제한시간이 경과되었을 경우 예외 대신 null을 반환합니다.</li>
</ul>
<h2 id="예외-처리">예외 처리</h2>
<p>코루틴의 예외는 다음과 같이 <a class="link" href="https://tourspace.tistory.com/154?category=797357"  target="_blank" rel="noopener"
    >정리</a>할 수 있습니다.</p>
<ul>
<li>CoroutineExceptionHandler를 이용하여 코루틴 내부의 기본 catch block으로 사용할 수 있다.</li>
<li>launch, actor : exception발생 시 바로 예외가 발생.</li>
<li>async, produce : 중간에 exception이 발생해도 await를 만나야 비로소 exception이 발생.</li>
<li>Job.cancel()을 제외한 다른 exception이 발생하면 부모의 코루틴까지 모두 취소시킨다. 이는 structured concurrency를 유지하기 위함으로 CoroutineExceptionHandler를 설정해도 막을 수 없다.</li>
<li>자식 코루틴에서 exception이 발생하면 다른 자식 코루틴 및 부모코루틴이 다 취소되버리기 때문에, 문제가 생긴 코루틴만 exception 처리할 수 있도록 하기 위해 CoroutineExceptionHandler를 설정한다. 단, CancellationException는 handler에서 무시된다.</li>
<li>여러개의 exception이 발생하면 가장 먼저 발생한 exception이 handler로 전달되며 나머지는 무시된다.</li>
</ul>
<h2 id="코루틴-사용">코루틴 사용</h2>
<p>심플하게 정리하면 스코프는 CoroutineScope를 사용합니다. CPU 작업이냐 IO 작업이냐를 판단하여 Dispatchers를 정의하고 마지막으로 코루틴 처리후 값이 나와야 되는가 아닌가에 따라 launch, async를 사용하면 되겠습니다.</p>
<p>이렇게 해서 코틀린의 코루틴에 대해 알아보았습니다.</p>
<div class="video-wrapper">
    <iframe loading="lazy" 
            src="https://www.youtube.com/embed/xSgZS9e3qCU" 
            allowfullscreen 
            title="YouTube Video"
    >
    </iframe>
</div>
</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/kotlin/">Kotlin</a>
        
            <a href="/tags/coroutine/">coroutine</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY 4.0</span>
    </section>
    </footer>


    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">Related contents</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/posts/android/lotto-checker/">
        
        

        <div class="article-details">
            <h2 class="article-title">코루틴으로 로또번호 당첨 확인하기</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/posts/android/use-ktlint/">
        
        

        <div class="article-details">
            <h2 class="article-title">ktlint로 코틀린 코딩 컨벤션 검토하기</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/posts/android/download-json-data-using-retrofit/">
        
        

        <div class="article-details">
            <h2 class="article-title">Retrofit으로 다운받은 Json 데이터를 RecyclerView에 표시하기</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/posts/android/android-http-library-review/">
        
        

        <div class="article-details">
            <h2 class="article-title">안드로이드의 HTTP 통신 라이브러리 고찰</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/posts/android/android-studio-plugins/">
        
        

        <div class="article-details">
            <h2 class="article-title">내가 Android Studio에서 사용하는 Plugins</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    
        
    <script src="https://utteranc.es/client.js" 
        repo="cliearl/cliearl.github.io"
        issue-term="cliearl"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;
        setUtterancesTheme(document.documentElement.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        setUtterancesTheme(e.detail)
    })
</script>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2019 - 
        
        2021 냉동코더의 기술블로그
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.5.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">Table of contents</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#코루틴의-개념">코루틴의 개념</a></li>
    <li><a href="#코루틴과-스레드">코루틴과 스레드</a>
      <ol>
        <li><a href="#메모리-구조의-차이">메모리 구조의 차이</a></li>
        <li><a href="#수행방식의-차이">수행방식의 차이</a></li>
        <li><a href="#코루틴의-장점">코루틴의 장점</a></li>
        <li><a href="#코틀린에서의-사용">코틀린에서의 사용</a></li>
      </ol>
    </li>
    <li><a href="#코루틴-구조">코루틴 구조</a>
      <ol>
        <li><a href="#coroutine-scope">Coroutine Scope</a>
          <ol>
            <li><a href="#coroutinescope">CoroutineScope</a></li>
            <li><a href="#globalscope">GlobalScope</a></li>
          </ol>
        </li>
        <li><a href="#coroutine-context">Coroutine Context</a>
          <ol>
            <li><a href="#dispatchers">Dispatchers</a></li>
            <li><a href="#job--deferred">Job &amp; Deferred</a></li>
          </ol>
        </li>
        <li><a href="#coroutine-builder">Coroutine Builder</a></li>
      </ol>
    </li>
    <li><a href="#코루틴-지연">코루틴 지연</a></li>
    <li><a href="#코루틴-취소">코루틴 취소</a></li>
    <li><a href="#예외-처리">예외 처리</a></li>
    <li><a href="#코루틴-사용">코루틴 사용</a></li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
