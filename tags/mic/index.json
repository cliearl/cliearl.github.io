[{"content":"이번 포스팅에서는 안드로이드 스튜디오에서 앱의 빌드속도를 빠르게 할 수 있는 여러가지 설정들에 대해 알아보도록 하겠습니다.\n구글에서는 빌드속도를 최적화하는 여러가지 방법들에 대해 정리하여 소개했고 유튜브에서도 공개하고 있습니다. 오늘은 이 내용을 정리해 보겠습니다.\n최신버전의 Gradle 사용 우선은 최신버전의 Gradle을 사용하는게 중요합니다.\n모듈에 대한 build.gradle 파일에서 사용하는 코틀린의 버전이나, 그래들 플러그인의 버전을 정할 수 있게 되어 있습니다.\n버전내역을 보시면 플러그인이 업데이트 될 수록 빌드를 빠르게 하는 기술이 적용되기 때문에, 버전을 항상 최신버전으로 유지하는게 중요합니다.\nGradle 버전은 안드로이드 스튜디오에서 앱을 생성할 때 최신버전으로 생성이 되기 때문에 새로 생성하는 프로젝트에 대해서는 신경 쓸 필요가 없지만, 과거에 작성한 프로젝트의 경우에는 이 빌드플러그인을 가능한 최신 버전으로 업데이트해서 사용하시는걸 추천합니다.\n개발시 서로 다른 빌드세팅 사용 다음은 개발할 때 서로 다른 빌드세팅을 사용하는 겁니다.\n빌드 그래들 파일에 보시면 buildTypes{} 블럭이 있는데, 디버그를 위한 debug{} 블럭과 릴리즈를 위한 release{} 블럭을 나누어서 사용할 수 있습니다.\n릴리즈 블럭 안에는 실제 릴리즈를 할 때 수행할 내용이 들어가게 됩니다. 여기에 디버그 블럭을 추가합니다.\n예를들어 릴리즈시에는 코드의 암호화를 설정해야 하는데 디버그에서는 적용할 필요가 없으므로 설정을 구분해서 빌드를 할 수 있습니다.\nmultidex 사용하지 않음 자바 코드는 실행환경에 의존하지 않는 바이트코드로 컴파일 되어 자바 가상머신(JVM)이 실행되는 환경이라면 어디서나 동일하게 실행할 수 있습니다.\n구글에서는 라이센스 문제를 피하기 위해 JVM 대신 Dalvik VM을 만들었고 이 DVM에서 돌리기 위해 자바 바이트코드를 DEX(Dalvik Executable)로 변환하여 사용하도록 했습니다.\n그런데 DVM을 사용하다보니 여러가지 문제가 있어서 새로 개발한 것이 ART VM입니다. 차이점을 간단하게 정리해 보면 다음과 같습니다.\nDalvik VM  32비트만 지원. JIT(Just In Time) 컴파일러 사용. 실행할 때 마다 필요한 컴파일을 수행하므로 설치파일이 작고 CPU, 메모리 사용이 높아 배터리 소모량이 큼.  Android RunTime(ART) VM  32, 64 비트 지원. AOT(Ahead On Time) 컴파일러 사용. 설치시 모든 컴파일 작업을 수행해 놓으므로 설치파일이 크고 설치가 느리지만 실행중 자원소모량은 JIT보다 적어 배터리 효율이 높다. GC 효율이 향상됨. 킷캣 KitKat 버전부터 지원이 시작되었으며 롤리팝 Lolipop 버전 이후는 AOT 컴파일러가 기본으로 적용됨 누가 Nougat 버전 부터 JIT와 AOT를 모두 탑재하여 최초 설치시에는 JIT으로 컴파일 해 설치시간과 용량을 줄이고, 차후 기기를 사용하지 않을 때나 충전 중일 경우 컴파일을 조금씩 하여, 자주 사용되는 앱을 AOT 방식으로 전환하는 방식으로 바뀜.  단일 DEX(Dalvik Executable) 에서 사용가능한 함수의 최대개수는 65536개입니다. 이 개수를 넘으면 처리를 위해 multidex를 도입해야 하는데 API Level 21 롤리팝 미만에서는 멀티덱스 처리가 느린 Dalvik 런타임이 사용됩니다. 그러나 API 21 이상에서는 ART 런타임을 사용하기 때문에 빌드속도가 빨라집니다. 그것을 위해서는 minSDKVersion을 21로 설정하면 됩니다.\nAPI level 21이면 안드 OS로 따지면 5.0인데 보통은 4.4 킷캣까지 대응하시는 경우도 있지만 저 개인적으로는 큰 문제가 없다면 5.0 대응을 추천드립니다.\n복수의 APK 생성기능 비활성화 안드로이드 앱은 화면 해상도에 따라 서로 다른 앱이 각각 만들어지게 됩니다. 그래서 APK 파일이 크다면 abi/화면 해상도별로 APK 파일을 나누어 앱 용량을 줄일수가 있습니다.\n어차피 테스트를 하는 과정에서는 기능을 확인하는게 중요하기 때문에 다른 해상도에 대해 빌드를 생략해서 속도를 빠르게 할 수 있습니다. gradle에서 다음과 같이 코드를 쓰면 됩니다.\n1 2  splits.abi.enable = false splits.density.enable = false   패키징 리소스 최소화 앞에서는 특정 해상도에 대해서만 빌드하도록 설정을 했는데, 앱에 보시면 언어별로도 각각 앱이 만들어지게 되어 있습니다. 그래서 테스트 해야하는 언어 이외에는 빌드를 안하도록 설정을 할 수 있는데요, 예를들어 영어, 일본어, 독일어, 한국어에 대응하도록 만들었다면 기능확인을 위해 한국어 앱만 빌드를 하게 할 수 있습니다.\n1 2 3 4 5 6 7 8  defaultConfig{ applicationVariants.all { variant -\u0026gt; if (variant.buildType.name == \u0026#34;debug\u0026#34;) { variant.mergedFlavor.resourceConfiguration.clear() variant.mergedFlavor.resourceConfiguration.add(\u0026#34;ko\u0026#34;) } } }   빌드가 디버그면 설정을 다 없애버리고 한국어만 추가한다는 내용인데요, 참고로 현재 빌드가 디버그인지 릴리즈인지는 화면 왼쪽에 Build Variants 탭을 열어서 확인할 수 있습니다.\n패키징 리소스는 resConfig라는 기능을 이용해 간단하게 구현할 수도 있는데\n그럴려면 productFlavor{} 블럭을 추가로 만들어서 다음과 같이 사용하면 됩니다. resConfig는 buildTypes{} 안에서는 사용할 수 없기 때문입니다. productFlavor의 구체적인 사용방법에 대해서는 구글 페이지를 참고하세요.\n1 2 3 4 5  productFlavors{ dev { resConfigs \u0026#34;ko\u0026#34;, \u0026#34;xxxhdpi\u0026#34; } }   PNG 크런칭 비활성화 안드로이드에서 PNG 파일이 포함되면 PNG 파일을 압축하는 기능이 실행되는데요, 이 기능은 debug 빌드에서는 기본적으로 사용이 중지되기 때문에 신경 쓸 필요가 없습니다. 다만 release 빌드에서도 기능사용을 중지시키고 싶다면 코드를 다음과 같이 쓰면 됩니다.\n1 2 3 4 5  buildTypes{ release { crunchPngs false } }   필요없는 변경하지 않기 앱이 처음 실행되는 시작점의 역할을 하는 manifest 파일이 있습니다. 그런데 마니페스트 파일을 변경하면 빌드가 처음부터 다시 이루어지게 됩니다.\n그런데 버전넘버와 버전코드를 변경하면 마니페스트 파일도 변경되어 앱이 처음부터 다시 빌드가 되기 때문에 테스트 시에는 이 값을 숫자로 고정하여 사용하는 것도 빌드를 빠르게 할 수 있는 방법이 될 수 있습니다.\n오류리포팅 기능 사용안함 안드로이드 앱에서는 Crashlytics 보고서를 자동으로 작성하도록 되어있습니다. 이 기능을 다음과 같이 비활성화 시켜 줍니다.\n1 2 3  debug{ ext.enableCrashlytics false }   라이브러리 버전 라이브러리를 사용할 때 버전을 x.x+ 형식으로 지정할 경우 x.x대의 최신버전을 사용하라는 뜻입니다. 그런데 이 경우 24시간마다 최신버전을 웹에서 확인하게 되기 때문에 빌드시간이 증가하게 됩니다. 따라서 라이브러리의 버전을 정확히 정해주면 빌드시간을 줄일 수 있습니다.\n1 2 3 4  dependencies { -compile \u0026#39;com.android.support:appcompat-v7:26.+\u0026#39; +compile \u0026#39;com.android.support:appcompat-v7:26.0.0-alpha1\u0026#39; }   이렇게 해서 안드로이드 스튜디오에서 빌드속도를 빠르게하는 여러가지 방법에 대해 알아보았습니다.\n ","description":"","id":0,"section":"posts","tags":["build","gradle"],"title":"앱 빌드속도 빠르게 하기","uri":"https://cliearl.github.io/posts/and-quickbuild/"},{"content":"이번 포스팅에서는 앱에서 움직이는 GIF를 표시하는 법에 대해 알아보도록 하겠습니다.\n안드로이드에서 이미지를 보여줄때는 화면을 구성하는 xml파일에 ImageView를 올리고 그 이미지뷰에 그림파일을 삽입해주면 됩니다. 이 때 그림파일은 drawable 폴더에 넣어주며 파일이름은 영문소문자 + 언더바로만 구성합니다.\nImageView로 이미지 표시 이미지를 표시하기 위해서는 다음과 같이 imageView의 setImageResource 메소드를 사용합니다.\n그런데 이 때 크기가 너무 큰 그림파일은 넣을 수 없고, 움직이는 GIF는 첫번째 프레임만 표시된다는 문제가 있습니다.\n1  imageView.setImageResource(R.drawable.sample00)   Glide 사용 하지만 Glide라는 외부 라이브러리를 사용하면 이런 문제를 해결할 수 있습니다.\n이렇게 이미지를 표시하는 라이브러리로는 square의 Picasso나 facebook에서 만든 Fresco도 있습니다.\n특징을 간단하게 설명하자면 picasso는 가벼운 대신 비교적 느리고, glide는 빠르고 사용하기 편하며 fresco는 빠르지만 사용법이 좀 복잡하다는 특징이 있습니다.\n아무튼 사용법은 다음과 같이 간단합니다. load 안에는 로컬 파일뿐만 아니라 웹 이미지도 넣을 수 있습니다.\n1 2 3 4  implementation \u0026#39;com.github.bumptech.glide:glide:4.11.0\u0026#39; // 메인액티비티 Glide.with(this).load(R.raw.sample01).into(imageView)   이렇게 해서 Glide를 사용하는 법에 대해 알아보았습니다.\n ","description":"","id":1,"section":"posts","tags":["ImageView","Glide","Picasso","Fresco"],"title":"Glide로 앱에서 움직이는 GIF 표시하기","uri":"https://cliearl.github.io/posts/and-glide/"},{"content":"이번 포스팅에서는 날짜와 시간을 다루는 법에 대해 알아보도록 하겠습니다.\n안드로이드의 날짜 라이브러리 날짜를 다루기 위해서는 일반적으로 날짜객체를 만들고 그 날짜객체를 자기가 필요로 하는 양식에 맞춰서 표현하도록 하면 되는데요, 이때 사용할 수 있는 날짜 패턴은 다음과 같이 여러가지가 있습니다.\n   Date and Time Pattern Result     \u0026ldquo;yyyy.MM.dd G \u0026lsquo;at\u0026rsquo; HH:mm:ss z\u0026rdquo; 2001.07.04 AD at 12:08:56 PDT   \u0026ldquo;EEE, MMM d, \u0026lsquo;\u0026lsquo;yy\u0026rdquo; Wed, Jul 4, \u0026lsquo;01   \u0026ldquo;h:mm a\u0026rdquo; 12:08 PM   \u0026ldquo;hh \u0026lsquo;o'\u0026lsquo;clock\u0026rsquo; a, zzzz\u0026rdquo; 12 o\u0026rsquo;clock PM, Pacific Daylight Time   \u0026ldquo;K:mm a, z\u0026rdquo; 0:08 PM, PDT   \u0026ldquo;yyyyy.MMMM.dd GGG hh:mm aaa\u0026rdquo; 02001.July.04 AD 12:08 PM   \u0026ldquo;EEE, d MMM yyyy HH:mm:ss Z\u0026rdquo; Wed, 4 Jul 2001 12:08:56 -0700   \u0026ldquo;yyMMddHHmmssZ\u0026rdquo; 010704120856-0700   \u0026ldquo;yyyy-MM-dd\u0026rsquo;T\u0026rsquo;HH:mm:ss.SSSZ\u0026rdquo; 2001-07-04T12:08:56.235-0700   \u0026ldquo;yyyy-MM-dd\u0026rsquo;T\u0026rsquo;HH:mm:ss.SSSXXX\u0026rdquo; 2001-07-04T12:08:56.235-07:00   \u0026ldquo;YYYY-\u0026lsquo;W\u0026rsquo;ww-u\u0026rdquo; 2001-W27-3    출처 : https://developer.android.com/reference/java/text/SimpleDateFormat#examples\n코드 작성 java.util.Date 그럼 우선은 java.util.Date 라이브러리를 이용해서 날짜객체를 만들어 보겠습니다.\n1 2 3 4 5  val utilDate = Date() println(utilDate.toString()) // 출력 Wed Apr 07 06:48:15 UTC 2021   다음은 이 객체의 표현패턴을 바꿔보겠습니다.\n1 2 3 4 5 6  val utilDate = Date() val formatType = SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;) println(formatType.format(utilDate)) // 출력 2021-04-07 06:49:17   java.time 그런데 이 java.util.Date라는 라이브러리는 API level 1 부터 추가된 오래된 라이브러리라 여러 문제도 많고 해서 시간관련 문제를 많이 개선한 java.time 라이브러리를 사용하는 것을 권해드립니다.\n날짜객체를 만든 뒤 포매터로 표시형식을 조정하는 것은 동일합니다.\n1 2 3 4 5 6 7  val date = LocalDateTime.now() val dtf = DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;) val nowString = date.format(dtf) println(nowString) // 출력 2021-04-07 06:57:21   Joda-Time 그런데 문제는 java.time이 API level 26에서 새로 추가된 라이브러리이기 때문에 오레오 미만의 기기에서는 시간을 대응하는 코드를 추가로 준비해야 한다는 점입니다.\n이런 경우에 사용할 수 있는 Joda-Time이라는 라이브러리가 있습니다. Joda-Time은 현재 active하게 개발되진 않지만 API level 26 미만에서 정확한 시간을 사용하기에 적절한 라이브러리입니다.\njava.time과 공유하여 사용하기 위해서는 다음과 같이 안드로이드 버전을 확인하고 버전에 맞는 라이브러리로 timeDate 객체를 만들어주면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // gradle에 추가 implementation \u0026#39;joda-time:joda-time:2.10.10\u0026#39; val timeDate: String if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.O) { val date = LocalDateTime.now() val dtf = DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;) val nowString = date.format(dtf) timeDate = nowString } else { val date = org.joda.time.LocalDateTime.now() val dtf = DateTimeFormat.forPattern(\u0026#34;yyyy-MM-dd\u0026#39;T\u0026#39;HH:mm:ss\u0026#34;) val jodatime = dtf.parseDateTime(date.toString()) val nowString = dtf.print(jodatime) timeDate = nowString }   두 날짜 사이의 차이 계산하기 그러면 다음은 2000년 1월 1일부터 오늘까지 경과한 날수를 계산해보겠습니다.\n1 2 3 4 5 6 7 8 9 10 11 12  val period: Int if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.O) { val startDate = LocalDate.of(2000, 1, 1) val todayDate = LocalDate.now() val differenceDate = startDate.until(todayDate, ChronoUnit.DAYS) + 1 period = differenceDate.toInt() } else { val startDate = org.joda.time.LocalDate(2000, 1, 1) val todayDate = org.joda.time.LocalDate.now() val differenceDate = Days.daysBetween(startDate, todayDate).days + 1 period = differenceDate }   이렇게 해서 날짜와 시간을 다루는 법에 대해 알아보았습니다.\n ","description":"","id":2,"section":"posts","tags":["date","time"],"title":"Date and Time 다루기","uri":"https://cliearl.github.io/posts/and-dateandtime/"},{"content":"이번 포스팅에서는 Data class를 사용하는 법에 대해 알아보도록 하겠습니다.\nData class의 특징 toString() 코틀린에서 클래스를 만들 때는 자바의 클래스 스펙에 따라서 toString(), equals(), hashCode()라는 메소드를 구현해주어야 합니다.\n우선 Person이라는 클래스를 만들고 그 인스턴스를 출력 해 보겠습니다. 그러면 Person@랜덤 이라는 값이 출력이 되게 됩니다.\n1 2 3 4 5 6 7  class Person(var name: String, var age: Int, var sex: String) val person1 = Person(\u0026#34;Alice\u0026#34;, 20, \u0026#34;Female\u0026#34;) println(person1) // 출력값 org.jetbrains.kotlin.idea.scratch.generated.ScratchFileRunnerGenerated$ScratchFileRunnerGenerated$Person@b6587368   이제 클래스의 toString()을 다음과 같이 오버라이드 해주면 클래스가 가진 프로퍼티값을 보여주게 됩니다.\n1 2 3 4 5 6  override fun toString(): String { return \u0026#34;Person(name=$name, age=$age, sex=$sex)\u0026#34; } // 출력값 Person(name=Alice, age=20, sex=Female)   equals() equals()은 같은 클래스로부터 인스턴스를 만들었을 때, 클래스 내부의 프로퍼티가 일치하면 같은 인스턴스로 취급할지를 판정하는 메소드입니다. 예를 들어 다음과 같은 인스턴스를 만들어 보면, 두 인스턴스가 동일하지 않다는 판정이 나오게 됩니다.\n1 2 3 4 5 6  val person2 = Person(\u0026#34;Bob\u0026#34;, 22, \u0026#34;Male\u0026#34;) val person3 = Person(\u0026#34;Bob\u0026#34;, 22, \u0026#34;Male\u0026#34;) println(person2 == person3) // 출력값 false   이제 equals()를 다음과 같이 오버라이드 해줍니다. 비교대상이 되는 인스턴스를 받아서 그게 null이거나 Person{} 이 아닐 경우는 false를 돌려주지만, 인스턴스의 프로퍼티가 일치하게 되면 동일한 객체라는 판정을 받게 됩니다.\n1 2 3 4 5 6 7 8  override fun equals(other: Any?): Boolean { if (other == null || other !is Person) return false return name == other.name \u0026amp;\u0026amp; age == other.age \u0026amp;\u0026amp; sex == other.sex } // 출력값 true   hashCode() hashCode()는 인스턴스의 해시값을 정의하는 메소드입니다. 이 부분을 정의하지 않으면 equals() 값이 동일하더라도 서로 다른 객체가 되어버립니다.\n1 2 3 4 5  val person4 = hashSetOf(Person(\u0026#34;Alice\u0026#34;, 20, \u0026#34;Female\u0026#34;)) println(person4.contains(Person(\u0026#34;Alice\u0026#34;, 20, \u0026#34;Female\u0026#34;))) // 출력값 false   그래서 hashCode()를 정의하여 동일한 프로퍼티를 가질 경우 동일한 해시값을 갖도록 합니다.\n1 2 3 4 5 6  override fun hashCode(): Int { return name.hashCode() * 1234 + age - sex.hashCode() } // 출력값 true   data class 그런데 그냥 프로퍼티만을 가지는 단순한 클래스의 경우 이런 것들을 다 정의해주는 행위가 번거로운 일이기 때문에, 코틀린에서는 data class라고 하는 클래스 형식을 하나 더 준비했습니다. data class를 사용하면 위에 언급한 메소드를 자동으로 정의하여 주기 때문에 다음과 같이 간단하게 클래스를 만들수 있게 됩니다.\n사용하는 법은 매우 간단한데요 class 앞에 data라는 접두어를 붙여주기만 하면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11  data class Person(var name: String, var age: Int, var sex: String) val person1 = Person(\u0026#34;Alice\u0026#34;, 20, \u0026#34;Female\u0026#34;) println(person1) // Person(name=Alice, age=20, sex=Female)  val person2 = Person(\u0026#34;Bob\u0026#34;, 22, \u0026#34;Male\u0026#34;) val person3 = Person(\u0026#34;Bob\u0026#34;, 22, \u0026#34;Male\u0026#34;) println(person2 == person3) // true  val person4 = hashSetOf(Person(\u0026#34;Alice\u0026#34;, 20, \u0026#34;Female\u0026#34;)) println(person4.contains(Person(\u0026#34;Alice\u0026#34;, 20, \u0026#34;Female\u0026#34;))) // true   RecyclerView의 데이터를 data class로 정의하기 그럼 data class를 RecyclerView에 적용해 보도록 하겠습니다.\n여기서는 몬스터의 이름, 종족, 레벨, 그리고 몬스터의 능력치, 만난적이 있는지에 대한 불린값을 클래스가 가지도록 하고 그것을 리사이클러뷰에서 보여주도록 할 건데요, 기존에 다른 필요로 인해 만들어 두었던 터치가능한 RecyclerView를 재활용하도록 하겠습니다.\n우선은 몬스터 클래스를 하나 만들어 줍니다. 프로퍼티는 가능한 여러가지의 타입을 가지도록 했습니다. 종족은 선택하기 편하도록 enum을 도입했습니다.\n1 2 3 4 5 6 7 8 9 10 11  data class Monster( val name: String, val race: Race, val level: Int, val stats: List\u0026lt;Int\u0026gt;, val encount: Boolean ) enum class Race { Zombie, Human, Goblin, Dragon }   그리고 기존의 list_item.xml에서 두 개였던 텍스트뷰의 개수를 늘려줍니다. 위에서부터 순서대로 몬스터 클래스의 프로퍼티를 보여주도록 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:paddingStart=\u0026#34;20dp\u0026#34; android:paddingEnd=\u0026#34;20dp\u0026#34; android:id=\u0026#34;@+id/vhLayout\u0026#34; android:background=\u0026#34;?attr/selectableItemBackground\u0026#34; android:gravity=\u0026#34;center_vertical\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;9\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_name\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Monster name\u0026#34; android:textSize=\u0026#34;24sp\u0026#34; android:padding=\u0026#34;3dp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_race\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Race\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_level\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Level\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_stats\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Stats\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_encount\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Encount\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;FrameLayout android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;30dp\u0026#34; android:layout_height=\u0026#34;30dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:src=\u0026#34;@drawable/ic_baseline_reorder_24\u0026#34; /\u0026gt; \u0026lt;/FrameLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt;   다음은 RecyclerView　Adapter에서 사용하는 데이터셋의 타입을 바꾸고 다른 메소드들도 변화시킵니다. 기존의 setData()는 필요없어졌기 때문에 삭제하고, 뷰홀더에서 데이터와 텍스트뷰를 바인딩하는 부분도 바뀐 타입에 맞도록 수정해 줍니다. 그리고 데이터를 추가하는 기능을 가진 addData() 메소드를 추가해줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  class RecyclerViewAdapter: RecyclerView.Adapter\u0026lt;RecyclerViewAdapter.ViewHolder\u0026gt;() { private val dataSet: ArrayList\u0026lt;Monster\u0026gt; = arrayListOf() fun removeData(position: Int) { dataSet.removeAt(position) notifyItemRemoved(position) } fun swapData(fromPos: Int, toPos: Int) { Collections.swap(dataSet, fromPos, toPos) notifyItemMoved(fromPos, toPos) } fun addData(name: String, race: Race, level: Int, stats: List\u0026lt;Int\u0026gt;, encount: Boolean) { dataSet.add(Monster(name, race, level, stats, encount)) notifyItemInserted(dataSet.size) } override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder { val binding = ListItemBinding.inflate(LayoutInflater.from(parent.context), parent, false) return ViewHolder(binding) } override fun onBindViewHolder(holder: ViewHolder, position: Int) { holder.bind(dataSet[position]) } override fun getItemCount(): Int { return dataSet.size } inner class ViewHolder(private val binding: ListItemBinding) : RecyclerView.ViewHolder(binding.root) { fun bind(data:Monster) { binding.tvName.text = \u0026#34;Name: ${data.name}\u0026#34; binding.tvRace.text = \u0026#34;Race: ${data.race}\u0026#34; binding.tvLevel.text = \u0026#34;Level: ${data.level}\u0026#34; binding.tvStats.text = \u0026#34;HP: ${data.stats[0]}/ MP: ${data.stats[1]}/ Exp: ${data.stats[2]}\u0026#34; binding.tvEncount.text = \u0026#34;Encounted: ${data.encount}\u0026#34; binding.vhLayout.setOnClickListener { Snackbar.make(it, \u0026#34;Item $layoutPositiontouched!\u0026#34;, Snackbar.LENGTH_SHORT).show() } } } }   마지막으로 addData() 메소드로 메인액티비티에서 데이터값을 만들어주면 됩니다.\n1 2 3 4 5 6 7 8 9  override fun onCreate(savedInstanceState: Bundle?) { ... rvAdapter.addData(\u0026#34;타일런트\u0026#34;, Race.Zombie, 10, listOf(100,10,50), false) rvAdapter.addData(\u0026#34;조커\u0026#34;, Race.Human, 23, listOf(200,20,100), false) rvAdapter.addData(\u0026#34;그렘린\u0026#34;, Race.Goblin, 2, listOf(10,1,5), true) rvAdapter.addData(\u0026#34;리오레우스\u0026#34;, Race.Dragon, 2500, listOf(10000,1000,50000), false) rvAdapter.addData(\u0026#34;사우론\u0026#34;, Race.Human, 100, listOf(1000,200,1000),false) rvAdapter.addData(\u0026#34;리바이어던\u0026#34;, Race.Dragon, 50, listOf(2000,250,10000), true) }   이렇게 해서 data class의 특징을 이해하고, 리사이클러뷰에서 활용하는 법에 대해 알아보았습니다.\n ","description":"","id":3,"section":"posts","tags":[],"title":"Data class 이해하고 RecyclerView에서 사용하기","uri":"https://cliearl.github.io/posts/and-dataclass-recyclerview/"},{"content":"이번 포스팅에서는 프로젝트의 빌드넘버를 자동으로 증가시키는 법에 대해 알아보도록 하겠습니다.\n버전넘버와 빌드넘버 버전넘버 소프트웨어의 기능이 변할때마다 그것을 구분하기 위해서 버전넘버를 사용하는데요, 일반적인 규칙은 1.0.0 과 같이 세자리로 결정을 합니다.\n첫째자리는 뒤로 되돌릴 수 없는 수준의 큰 변경이 있을때, 둘째자리는 여러가지 새로운 기능이 추가되었을 때 증가를 시키고, 셋째자리는 기능이 추가되지는 않지만 버그가 수정되었을 때 증가를 시킵니다.\n그래서 첫째자리는 메이저 버전, 둘째자리는 마이너 버전, 셋째자리는 패치버전이라고 하는 이름이 있습니다.\n다만 이것은 꼭 지켜야 하는 규칙은 아니고, 날짜를 버전넘버로 사용하는 소프트웨어도 있습니다.\n빌드넘버 빌드넘버란 어떤 버전을 출시할 때 여러번 반복해서 빌드를 할 때마다 숫자를 증가시키는 방법으로 사용하는 숫자인데요, 그러니까 버전넘버가 동일하다고 해도 여러가지 서로다른 빌드넘버를 가질 수 있습니다.\n그래서 빌드를 수행할 때마다 어쨌든 변화가 있어야 되는데, 일반적으로는 증가시키는 형식으로 빌드넘버를 사용을 하구요, 보통은 이 빌드넘버를 일반 사용자가 알 필요가 없기 때문에 이걸 보여주지는 않지만, 개중에는 보여주는 소프트웨어도 있습니다. 윈도우같은 경우는 이 빌드넘버를 프로그램 안에서 확인할 수도 있습니다.\n그런데 이 빌드넘버는 빌드를 수행할 때 하나씩 증가를 시켜야 하는데 안드로이드 스튜디오에서는 이걸 자동으로 증가시켜주지 않기 때문에 이 부분을 자동으로 증가시켜주는 기구를 프로젝트에 적용하는 법에 대해 설명하도록 하겠습니다.\n프로그램 작성 app 레벨의 gradle에서 빌드넘버는 versionCode가 됩니다. 그래서 빌드를 한 번 할 때마다 versionCode는 증가가 되야 하구요, versionName은 기능 추가가 있을때마다 그때그때 개발자가 필요에 의해서 증가를 시켜주면 되겠죠.\n1 2 3 4 5 6  android { defaultConfig { versionCode 1 versionName \u0026#34;1.0\u0026#34; } }   이 versionCode와 versionName을 프로그램 안에서 표시를 할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10  class MainActivity : AppCompatActivity() { private val versionNumber = BuildConfig.VERSION_NAME.replace(\u0026#34;\u0026#39;\u0026#34;, \u0026#34;\u0026#34;) private val versionBuild = BuildConfig.VERSION_CODE override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) textView.text = \u0026#34;App Version: $versionNumber($versionBuild)\u0026#34; } }   하지만 verionCode를 빌드할때마다 증가시켜주는건 귀찮기 때문에 이 부분을 자동으로 증가시켜주는 기구를 만들어 볼 겁니다.\n일단은 앱 안에 version.properties라는 파일을 만들고 이 파일 안에서 버전넘버와 빌드넘버를 관리할 겁니다.\n1 2  VERSION_NUMBER=\u0026#39;1.0.0\u0026#39; VERSION_BUILD=1   그다음은 app 레벨의 gradle 파일에서 version.properties에 있는 값을 불러와서 빌드넘버를 1 증가시키고 그걸 저장하는 코드를 작성합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  android { // 저장된 값을 불러오는 부분  def versionPropsFile = file(\u0026#39;version.properties\u0026#39;) def versionBuild def versionNumber if (versionPropsFile.canRead()) { def versionProps = new Properties() versionProps.load(new FileInputStream(versionPropsFile)) versionBuild = versionProps[\u0026#39;VERSION_BUILD\u0026#39;].toInteger() versionNumber = versionProps[\u0026#39;VERSION_NUMBER\u0026#39;].toString() } else { throw new FileNotFoundException(\u0026#34;Could not read version.properties!\u0026#34;) } // 읽어온 빌드넘버를 증가시키는 부분  ext.autoIncrementBuildNumber = { if (versionPropsFile.canRead()) { def versionProps = new Properties() versionProps.load(new FileInputStream(versionPropsFile)) versionBuild = versionProps[\u0026#39;VERSION_BUILD\u0026#39;].toInteger() + 1 versionProps[\u0026#39;VERSION_BUILD\u0026#39;] = versionBuild.toString() versionProps.store(versionPropsFile.newWriter(), null) } else { throw new FileNotFoundException(\u0026#34;Could not read version.properties!\u0026#34;) } } // 함수를 실행시키는 부분  gradle.taskGraph.whenReady { taskGraph -\u0026gt; if (taskGraph.hasTask(assembleDebug)) { autoIncrementBuildNumber() } else if (taskGraph.hasTask(assembleRelease)) { autoIncrementBuildNumber() } } compileSdkVersion 29 // 수정한 내용을 앱에 반영해 줌  defaultConfig { applicationId \u0026#34;com.example.autobuildnum\u0026#34; minSdkVersion 21 targetSdkVersion 29 versionCode versionBuild versionName versionNumber testInstrumentationRunner \u0026#34;androidx.test.runner.AndroidJUnitRunner\u0026#34; } }   이제 빌드를 할때마다 빌드넘버가 자동으로 증가하게 됩니다.\n ","description":"","id":4,"section":"posts","tags":["build number","Kotlin"],"title":"프로젝트의 빌드넘버 자동증가 시키기","uri":"https://cliearl.github.io/posts/and-buildnumber/"},{"content":"이번 포스팅에서는 ProgressDialog와 Thread 사용법에 대해 알아보도록 하겠습니다.\n들어가기 ProgressDialog는 안드로이드가 어떤 작업을 진행할때 그 작업의 진행상황과 부가적인 문장을 팝업창으로 보여주는 모듈입니다. 시간이 걸리는 파일 다운로드나 복사를 수행할 때 이런창을 띄워주면 기다리는데 유저의 거부감을 줄일 수 있습니다.\nProgressDialog는 다이얼로그가 표시되는 동안 유저가 다른 조작을 못하게 된다는 이유로 Android 8.0(API level 26)부터는 deprecated 되고 대신 ProgressBar를 사용하도록 권장하고 있습니다.\n\u0026hellip;만, 쓰레드를 설명하는데 좋은 예제이기 때문에 여기서는 프로그레스 다이알로그를 구현하면서 쓰레드에 대해 이해해 보도록 하겠습니다\n스레드란 컴퓨터 하드에 저장된 프로그램을 실행하면 운영체제는 프로그램을 메모리에 로딩하고 실행시킵니다. 이 때 메모리로 올라가 실행되고 있는 프로그램을 프로세스라고 합니다. 그리고 프로세스 안에서 실행되는 여러가지 작업 흐름을 각각 쓰레드라고 합니다.\n안드로이드로 예를 들면 스마트폰 안에 저장된 유튜브앱은 프로그램이고 앱을 실행시키면 메모리에 유튜브 프로세스가 새로 하나 생성됩니다. 유튜브에는 앱을 보고있는 동안 계속 메뉴화면을 표시하는 스레드가 생기고 동영상을 선택했을 때 유튜브 서버에서 동영상을 다운로드하는 또 하나의 스레드가 생기게 되는 식입니다.\n안드로이드에서 앱을 실행했을 때 처음으로 시작되는 스레드를 메인 스레드라고 합니다. 메인 스레드는 화면을 표시하고 버튼이나 텍스트뷰에 대한 조작이 이루어졌을 때 그 처리를 담당합니다.\n이 때 예를들어 프로그레스 다이얼로그로 1초에 10%씩 증가하는 다운로드 진행상황을 표시한다고 합시다. 0% 를 표시하고 1초 후에 10%, 2초후에 20%.. 를 표시해야 하는거죠.\n그런데 메인 스레드에서 이 처리를 하게되면 진행상황을 표시하지 않는 1초의 인터벌시간동안 메인스레드가 멈춰서 1초동안 기다리고 있어야 합니다. 그 동안 UI　처리는 수행할 수 없게 되죠.\n그래서 프로그레스다이얼로그의 처리는 메인스레드와는 별개로 동작하는 백그라운드 스레드를 추가로 만들어서 구현하게 됩니다.\n프로그램 작성 그럼 버튼을 터치하면 진행율이 0.2초당 10%씩 증가하는 다이얼로그를 만들어 보면서 스레드를 구현해 보겠습니다.\nview binding 처리 1 2 3 4 5  build.gradle android { buildFeatures.viewBinding true }   progressDialog　준비 메인액티비티 안에 프로그래스다이얼로그용 전역변수를 만들어줍니다.\n1  private lateinit var progressDialog: ProgressDialog   버튼을 터치했을때 다이얼로그가 표시되게 할 것이므로\n버튼의 클릭리스너 안에서 프로그레스다이얼로그를 설정합니다.\n1 2 3 4 5 6 7  progressDialog = ProgressDialog(this) progressDialog.max = 100 progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL) progressDialog.setTitle(\u0026#34;Download Task\u0026#34;) progressDialog.setMessage(\u0026#34;Please wait, we are downloading your files...\u0026#34;) progressDialog.setCancelable(false) progressDialog.show()   스레드와 핸들러 출처 : https://academy.realm.io/kr/posts/android-thread-looper-handler/\n한 프로세스 안에서 여러개의 스레드를 사용하게 되면 서로다른 스레드가 버튼이나 텍스트뷰 등의 UI 컴포넌트에 동시에 접근하는 문제가 생길 수 있습니다. 안드로이드에서는 이것을 막기 위해 처리흐름 중간에 Looper와 Handler를 끼워 넣었습니다.\n스레드는 수행해야 할 UI 작업이 발생하면 message 또는 runnable을 만들어내고 이걸 message queue에 담습니다. looper는 무한히 루프를 돌며 message queue속의 객체를 핸들러에 전달합니다. 핸들러는 메시지를 받으면 운영체제가 정해주는 타이밍에 따라 UI조작을 수행하게 되므로 UI요소에 대한 동시접근을 막을 수 있게 됩니다.\n핸들러 구현 스레드에서 사용할 핸들러 객체는 다음과 같이 만들어 줍니다. handleMessage 메소드를 오버라이드하고 그 안에 수행할 UI작업을 작성하면 됩니다.\n1 2 3 4 5 6  val handler: Handler = object : Handler() { override fun handleMessage(msg: Message) { super.handleMessage(msg) progressDialog.incrementProgressBy(10) } }   코틀린에서 스레드 사용 코틀린에서 스레드를 사용하는 방법은 Thread 클래스를 상속받아 스레드를 직접 구현하는 법, 그리고 Runnable 인터페이스로 구현하는 법이 있습니다. 여기서는 스레드 클래스를 변경할 필요가 없으므로 간편하게 구현할 수 있는 runnable 인터페이스를 사용하겠습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13  Thread { try { while (progressDialog.progress \u0026lt;= progressDialog.max) { Thread.sleep(200) handler.sendMessage(handler.obtainMessage()) if (progressDialog.progress == progressDialog.max) { progressDialog.dismiss() } } } catch (e: Exception) { e.printStackTrace() } }.start()   쓰레드에서는 매 루프마다 현재 프로그래스 값을 체크하고 그 값이 최대값보다 작으면 핸들러에 메시지를 보냅니다. 이 때 Thread.sleep을 이용해 0.2초 간격으로 스레드를 정지시킵니다.\n메모리 리크 방어하기 메인 루퍼 이용하기 이렇게 해서 프로그레스다이얼로그를 구현하였습니다. 그런데 핸들러 객체에 하이라이트 된 부분을 보면 This Handler class should be static or leaks might occur라는 경고를 하고 있습니다.\n앞에서 설명했듯이 모든 스레드는 각자의 개별Looper를 가지게 됩니다. 그런데 핸들러가 백그라운드 스레드에 의해 만들어진 루퍼를 사용할 경우 메시지큐에 메시지가 남아있으면 액티비티가 종료되도 죽지않고 살아있게 됩니다. 그래서 메모리누수가 일어날 수 있다는 경고가 발생하는 것입니다.\n그래서 핸들러가 백그라운드 스레드의 Looper가 아닌 메인 스레드의 Looper를 사용하게 하면 핸들러의 수명은 액티비티가 종료될 때 같이 종료되게 되므로 경고메시지가 사라지게 됩니다.\n그렇게 하기 위해서는 핸들러를 만들 때 메인 스레드의 루퍼를 전달해주면 됩니다.\n1 2 3 4 5 6  val handler: Handler = object : Handler(Looper.getMainLooper()) { override fun handleMessage(msg: Message) { super.handleMessage(msg) progressDialog.incrementProgressBy(10) } }   메모리 리크 경고가 사라진 것을 알 수 있습니다.\n약한참조 이용하기 핸들러 클래스를 새로 만들어 주는 방식으로 메모리 리크를 방지할 수도 있습니다.\n자바에서는 객체간의 관계를 Strong reference, Soft reference, Weak reference, Phantom reference 등으로 구분하는데 메모리 확보를 위해 가비지 컬렉터가 작동하면 강한참조는 무시되고 약한참조를 가진 객체만 삭제되게 됩니다.\n현재 구현한 코드대로라면 핸들러가 메인액티비티의 내부 클래스가 되고 강한참조를 가지게 되므로 액티비티가 종료되어도 핸들러 객체에 대해 가비지 컬렉터가 작동하지 않게 되어 메모리 리크가 발생하게 됩니다.\n따라서 메인 액티비티에 대한 참조를 가지지 않는 정적 클래스로 만들면 됩니다.\n핸들러 정적 클래스화 코틀린에서 만들어지는 클래스는 기본적으로 static 이므로 다음과 같이 핸들러 클래스를 만들어 사용하면 됩니다.\n1 2 3 4 5 6 7  val handler = MyHandler() private class MyHandler() : Handler() { override fun handleMessage(msg: Message) { } }   클래스 약한참조화하기 그런데 정적인 핸들러 클래스를 만들었지만 우리가 사용할 핸들러는 액티비티의 progressDialog를 참조하여야 하므로 다시 참조가 생기게 됩니다, 따라서 weakreference를 이용해서 이를 약한참조로 만들어 줍니다.\n1 2 3 4 5 6 7 8 9 10  private class MyHandler(activity: MainActivity?) : Handler() { private val weakReference: WeakReference\u0026lt;MainActivity\u0026gt; = WeakReference(activity) override fun handleMessage(msg: Message) { val activity = weakReference.get() if (activity == null || activity.isFinishing) return activity.progressDialog.incrementProgressBy(10) } }   이렇게 하면 핸들러를 약한 참조로 하면서 액티비티의 요소를 이용할 수 있습니다.\n이렇게 ProgressDialog를 구현해 보면서 Thread에 대해 이해해 보았습니다.\n ","description":"","id":5,"section":"posts","tags":["ProgressDialog","Thread","Handler","Kotlin"],"title":"ProgressDialog로 Thread와 Handler 이해하기","uri":"https://cliearl.github.io/posts/and-progressdialog-thread/"},{"content":"패스워드 매니저는 웹브라우저에서 아이디와 패스워드를 자동으로 넣어주는 프로그램입니다.\n들어가기 저는 패스워드 매니저로 LastPass를 사용하고 있습니다. 과거에 해킹당한 적도 있었지만 그 이후 큰 이슈가 없었고 사용하기 편해서 계속 사용하고 있습니다.\n크롬, 파이어폭스, 사파리, 엣지, 오페라 등의 브라우저에서 작동하며 안드로이드, iOS, 윈도우, 맥을 지원하고 터치ID도 대응하기 때문에 여러 장치사이에서 동기화하며 잘 사용하고 있었습니다\u0026hellip;만 2021년 3월 16일부터 무료이용자에 대한 정책을 변경하였습니다.\n그 내용은 컴퓨터 혹은 모바일 기기 둘 중 하나에서만 자유롭게 사용하게 할 것이고 양쪽 모두에서 사용하고 싶다면 한달에 3달러인 프리미엄 플랜에 가입해야 한다는 것 입니다. 그 덕분에 LastPass 파이어폭스 플러그인은 별점 테러를 먹고 있는 중입니다.\n성능이 나쁘지 않은것도 있었지만 LastPass의 가장 큰 장점 중 하나는 무료로 사용이 가능하다는 점이었기 때문에 갈아탈 때가 된 것 같다는 생각이 들었습니다.\n이것저것 찾아봤는데 복수의 기기에서 무료로 이용할 수 있게 해주는 자비로운 서비스는 존재하지 않았고, 거의 대부분이 서비스를 유로플랜으로 제공하고 있었습니다.\nLastpass 대체서비스    서비스 무료 플랜 파폭 플러그인     Bitwarden 모든 기기, 암호 무제한 있음   Dashlane 기기 한대, 암호 50개 없음   LastPass 기기 한 종류, 암호 무제한 있음   NordPass 모든 기기, 암호 무제한 있음   Roboform 기기 한대, 암호 무제한 있음    이 중 모든기기에서 사용 가능한건 Bitwarden과 NordPass인데 NordPass는 파이어폭스 플러그인의 평이 그리 좋지 않습니다. 거기다 이 서비스도 언제 유료화 할지 모르니 오픈소스로 개발되는 Bitwarden을 사용하기로 결정했습니다. 파이어폭스 플러그인의 평도 좋고 인터넷에서의 평도 나쁘지 않은것 같습니다.\nBitwarden Bitwarden의 경우 세 가지 사용방법이 있습니다\n 공식 홈페이지에서 가입하여 사용 공개된 코드를 개인용 NAS에 Docker 이미지로 설치하여 사용 공식 도커이미지는 서버 요구스펙이 높은데 이 것을 저사양 서버에서도 돌아가도록 개인이 편집한 소스에서 만들어진 도커 이미지로 설치  개인이 쓸 거면 bitwarden_rs 를 사용하는것만으로 아마 충분하겠지만 역시 개인 프로젝트는 언제 어떤식으로 중단될 지 알 수 없고 그 경우 관리상 여러가지 곤란한 점이 생길 수 있습니다.\n현재로서는 소스를 퍼블릭 공개하고 있는 Bitwarden 회사가 나의 패스워드를 함부로 다루지 않을 것이라는 믿음을 가져보기로 했고 그렇다면 보안의 관점에서 볼 때 개인용 NAS에 보관하는 것 보다는 회사 서버에 보관하는 것이 더 낫다고 생각해서 공식 홈페이지에 가입하여 서비스를 사용해 보기로 했습니다.\n또 공식서버에서 운용하다가 뭔가 맘에 안드는 점이 있다면 그때가서 개인 NAS로 옮겨도 될 것 같네요.\n","description":"","id":6,"section":"posts","tags":["lastpass","bitwarden"],"title":"패스워드 매니저 교체기","uri":"https://cliearl.github.io/posts/password-manager/"},{"content":"지금까지 사용하던 녹음환경을 개선하였습니다.\n들어가기 지금까지는 음성녹음을 위해 애플 이어팟을 맥북에 연결하여 마이크로 사용하고 있었습니다.\n핸즈프리인것 치고는 마이크 성능이 나쁘지 않았는데요, 최근 맥북에서 녹음할 때 드라이버 충돌이 있었는지 목욕탕에서 녹음하는것처럼 소리가 울리는 문제가 발생했기에 새로 마이크를 들이기로 했습니다.\n컨셉은 20만원대에서 믹서없이 사용할 수 있는 USB 콘덴서마이크였습니다.\n검토한 마이크들 NT-USB  https://ko.rode.com/microphones/nt-usb 워낙 평도 좋고 가성비도 좋아서 눈여겨보고있던 마이크였는데 최근에 가격이 좀 올랐습니다.  NT-USB Mini  NT-USB에 비하면 해상도가 24비트로 더 높고 연결단자가 USB-C라는 장점이 있으나 팝필터가 내장이라는 점이 별로였네요. 다만 유튜브에서 찾아보니 음질은 나쁘지 않았습니다.  Blue Yeti X  https://www.bluemic.com/ko-kr/products/yeti-x/ 스펙도 훌륭하고 녹음패턴도 4가지나 가지고 있어 게스트를 두고 녹음하는 것도 가능하다. 소리크기에 LED가 반응하는것도 이쁘고 유튜브에서 청음해보니 음질도 좋은 편이다. 마이크 컨트롤용 앱도 잘 만들어놓은것 같았다.  AT-2020USB+  https://www.audio-technica.com/en-us/at2020usb 실 사용기를 보면 폴라패턴이 좀 넓은듯한데 그래도 훌륭한 마이크인것 같다.  그래서 구입한 장비 (뒷광고 아닙니다!) RODE NT-USB  여러가지 비교포인트는 있었는데 마이크별로 극적인 차이는 없었습니다. 결국 바다씨의 speechless를 듣고 NT-USB를 구입해버렸습니다\u0026hellip; 흠\u0026hellip;    아리스노보 UMA-RF03 리플렉션 필터  https://smartstore.naver.com/arsnovo/products/4609145421  환경개선 비교 20만원대 마이크를 2만5천원짜리 핸즈프리와 비교하는것은 이어팟에 너무 가혹한 일이지만 한번 비교를 해보겠습니다.\n  우선은 화이트노이즈가 개선되었습니다. 이어팟은 목소리 자체는 비교적 깨끗하게 잡아주지만, 화이트노이즈가 꽤 큰편인데 로데로 교체하면서 화이트노이즈가 많이 사라졌습니다.\n  이어팟이 옷과 부딪힐때 나는 잡음이 사라졌습니다. 타이핑이나 마우스를 조작하다보면 이어팟의 볼륨조절버튼이 옷에 부딪히면서 바스락거리는 잡음이 수음되곤 했는데 마이크를 암 스탠드에 거치하고 책상과 이격시키면서 옷에서 나는 잡음을 잡았습니다. 또 키보드를 두드릴 때와 마우스를 들었다놨다 할때 책상에 전해지는 소음도 억제할 수 있게 되었습니다.\n  반향음을 억제할 수 있게 되었습니다. 기존에는 무료로 대여할 수 있는 녹음실에서 녹음을 했었는데 이 방은 방음처리가 잘 되어 있어서 외부에서 들어오는 잡음이나 반향음을 신경 쓸 필요가 없었습니다. 그런데 코로나로 녹음실을 사용할 수 없게 되면서 집에서 녹음했더니 반향음이 있었습니다. 하지만 이번에 마이크를 구매하면서 같이 구입한 리플렉션필터 덕분인지 반향음이 잘 잡히게 되었습니다.\n  목소리를 모니터링할수 있게 되었습니다. 이어팟으로 녹음할 때는 어디서 소음이 잡히는지 내 목시리가 어떻게 녹음되고 있는지 알 길이 없었습니다. 하지만 마이크의 모니터링단자에서 목소리를 확인하면서 녹음하니 노이즈가 들어가거나 입이 마이크에서 좀 떨어져있구나 하는 것들을 실시간으로 확인할 수 있어서 작업이 수월해졌습니다.\n  마이크 성능이 좋다보니 ASMR도 됩니다. 마지막으로 서정시 한편을 읽으며 마치겠습니다.\n  어둠에다크에서 죽음의데스를 느끼며\n서쪽에서 불어오는 바람의윈드를 맞았다.\n그것은 운명의데스티니.\n그는 인생의 라이프를 끝내기 위해 디엔드.\n모든것을 옭아매는 폭풍같은 스톰에서 벗어나기 위해\n결국 자신 스스로를 죽음에데스로 몰아갔다.\n후에 전설의 레전드로써 기억에 메모리- 기적에미라클\n길이길이 가슴속의하트에 기억될 리멤버.\n끝에 Fin\n","description":"","id":7,"section":"posts","tags":["mic"],"title":"녹음용 마이크 교체기","uri":"https://cliearl.github.io/posts/changemic/"},{"content":"이번 포스트에서는 작성된 코드의 교열을 보는 방법에 대해 알아보도록 하겠습니다.\n들어가기 우리가 작성하는 코드는 기본적으로는 컴퓨터에게 명령을 내리기 위한 것이고 그 명령은 각 언어의 문법에 따라 작성되어져야 합니다.\n코틀린에서 상수 두 개를 만들고 그 상수를 더하는 명령은 다음과 같이 쓸 수 있습니다.\n1 2 3 4  val a = 3 val b = 4 val c = a + b println(c)   자 그럼 이번엔 코드 안에서 띄어쓰기의 방식을 다르게 해보겠습니다.\n1 2 3 4  val a= 3 val b = 4 val c= a+ b println(c)   각 줄마다 띄어쓰기의 방식이 다르다고 해도 컴퓨터는 코드를 문제없이 컴파일 할 수 있습니다.\n그럼 코드를 이렇게 써도 문제없이 작동하니 괜찮은걸까요?\n내가 작성한 코드를 내 동료가 검토할 수도 있고, 몇 년후 내가 더 이상 코드를 관리하지 않게 되었을 때 내 후임이 코드를 읽어야 할 일이 생길 수 있습니다. 또 다음주쯤에 내 스스로가 내가 작성한 코드를 다시 읽어야 할 일도 생길 수 있죠.\n코드는 나와 컴퓨터의 대화이기도 하지만, 나와 다른 사람과의 대화이기도 합니다. 따라서 컴파일이 되게 문법을 맞추는 것 뿐만 아니라, 사람이 보기 좋도록 코드의 구조도 이쁘게 만드는 것이 좋습니다.\n프로그래머들 사이에서는 코드가 이쁘다고 느끼게 하는 어느정도 일반적으로 받아들여지는 정도의 수준이 있고 이걸 정리한 것을 코드 컨벤션이라고 합니다.\nktlint 코드 컨벤션의 형태는 언어별로 다른데 코틀린의 경우 구글에서는 다음과 같은 규약을 정의하고 있습니다.\n https://developer.android.com/kotlin/style-guide https://kotlinlang.org/docs/coding-conventions.html  이 수많은 규약들을 머리에 넣어두고 잘 지킬 수 있다면 문제가 없겠지만 실제 코딩을 하다보면 이런 것들을 모두 신경쓰면서 코드를 쓸 수가 없습니다. 그래서 각 언어에는 린트 혹은 린터라고 불리는 도구가 있습니다.\n린트는 과거에 C언어의 소스코드를 검사하기 위해 만들어진 유틸리티의 이름인데요. 현재는 동일한 작업을 하는 도구들을 모두 린트라고 부르고 있습니다.\n코틀린의 대표적인 린트 툴로는 ktlint, detekt 등이 있는데요, 이번 영상에서는 복잡한 설정을 하지 않고 편하게 사용할 수 있는 ktlint의 사용법에 대해 설명하도록 하겠습니다.\nktlint는 다음과 같은 컨벤션 오류를 체크하고 자동으로 컨벤션에 맞게 코드를 수정해주는 기능이 있습니다\n https://ktlint.github.io/#rules  실제로는 이것뿐만 아니라 체크되는 더 많은 룰이 있습니다.\n https://github.com/pinterest/ktlint#standard-rules  ktlint 사용법 ktlint는 그 자체를 프로젝트에 삽입해서 사용해도 되지만 래퍼 라이브러리를 사용하면 더 간편하게 사용할 수 있습니다. ktlint의 래퍼는 여러가지가 있는데 저는 커밋이 활발하게 이루어지는 다음 라이브러리를 사용하였습니다.\n https://github.com/jlleitschuh/ktlint-gradle  이 라이브러리를 project 레벨의 gradle에 플러그인으로 추가합니다.\n1 2 3 4 5 6 7 8 9 10 11  buildscript {...} plugins { id \u0026#34;org.jlleitschuh.gradle.ktlint\u0026#34; version \u0026#34;10.0.0\u0026#34; } allProjects {...} subprojects { apply plugin: \u0026#34;org.jlleitschuh.gradle.ktlint\u0026#34; }   이렇게 설정하면 프로젝트의 task에 여러가지 작업이 추가됩니다.\n오른쪽 메뉴의 gradle에서 확인가능하며 모든 task의 리스트는 여기서 확인 가능합니다.\n https://github.com/JLLeitschuh/ktlint-gradle#tasks-added  task가 추가되었으면 터미널에서 실행합니다.\n1 2  ./gradlew ktlintCheck // 로 틀린부분을 체크받고 ./gradlew ktlintFormat // 로 자동수정을 할 수 있습니다.   ktlintcheck를 수동으로 수행하는 것이 귀찮다면 다음 명령으로 커밋할때마다 ktlintcheck가 실행되게 할 수 있습니다.\n1  ./gradlew addKtlintCheckGitPreCommitHook   ktlint를 이용해서 코드 컨벤션에 맞는 코드를 생산하는 법에 대해 알아보았습니다. 중요한 것은 코드 컨벤션을 지키지 않아도 컴파일은 정상적으로 수행되지만, 이 코드를 언젠가 다시 읽게 될 나와 다른 사람을 위해 코드 컨벤션을 지켜야 한다는 점입니다.\n ","description":"","id":8,"section":"posts","tags":["ktlint"],"title":"ktlint로 코틀린 코딩 컨벤션 검토하기","uri":"https://cliearl.github.io/posts/and-ktlint/"},{"content":"기술블로그 엔진을 Hugo에서 Hexo로 바꾸어 보았다.\nHexo에 Icarus 태그를 씌우고 도커에 올려서 잘 쓰고 있었는데 내가 사용한 도커 이미지는 업뎃이 안된다는 문제가 있었다.\nhttps://github.com/spurin/docker-hexo\n그래서 비슷한 엔진인 Hugo를 찾아보았는데 Hugo의 도커 이미지는 관리가 잘 되고 있었다.\nhttps://hub.docker.com/r/klakegg/hugo/\n근데 이상하게도 이 이미지를 비롯한 모든 hugo의 도커 이미지는 내 환경에서 실행이 안됐다. 짜증나기도 하고 이왕 이렇게 된거 로컬에서 실행하기로 했다. 맥북에서 하면 brew를 사용하기 때문에 업뎃도 쉬워서 관리가 편하다. hexo가 brew로 관리가 안된다는 점도 hugo로 온 이유중에 하나. Go를 쓰니까 빠르다는 점은 그렇게까진 다가오지 않았다.\nhugo 초기화 1 2  $ brew install hugo // hugo를 인스톨 $ hugo new site [생성할 폴더 이름]   깃 준비 1 2 3 4 5 6  $ cd cliearl.github.io $ git init $ git remote add origin [https://hugo 원본파일을 보관할 저장소] $ git submodule add [https://hugo가 생성한 사이트를 업로드할 저장소] public $ git submodule add [https://github.com/zzossig/hugo-theme-zzo.git] themes/zzo $ git submodule update --init --recursive // 테마가 업데이트 될 경우 반영   글 작성 후 확인 1 2  $ hugo new posts/test.md // 새로운 글 작성 $ hugo server -D // localhost:1313에서 만들어진 정적사이트를 확인   페이지 작성 후 업로드 1 2 3 4 5  $ hugo -t [테마이름] // 정적사이트 생성 $ cd public $ git add . $ git commit -m \u0026#34;deploy updates\u0026#34; $ git push origin main   커밋 자동화 스크립트 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  #!/bin/bash  echo -e \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\u0026#34; # Build the project. hugo -t zzo # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin main # Come Back up to the Project Root cd .. # blog 저장소 Commit \u0026amp; Push git add . msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; git push origin master   검색엔진에 등록 Google Search Console  Google Search Console에 접속 속성 추가 후 URL 접두어에서 github.io 주소 입력 HTML파일로 확인 선택 -\u0026gt; 파일 다운로드 hugo의 public 폴더에 복사하면 루트에 업로드 됨 소유권 확인됨  config.toml 수정 # 로봇 검색 허용 enableRobotsTXT = true # 사이트맵 작성 [sitemap] changefreq = \u0026quot;daily\u0026quot; filename = \u0026quot;sitemap.xml\u0026quot; 서치콘솔에 등록 Sitemaps 메뉴에서 \u0026hellip;/sitemap.xml을 등록.\n","description":"","id":9,"section":"posts","tags":["hugo","blog"],"title":"Hugo Blog","uri":"https://cliearl.github.io/posts/hugo-blog/"},{"content":"내가 사용하는 파이어폭스 플러그인을 정리해 보았다.\nAuto Tab Discard https://addons.mozilla.org/ko/firefox/addon/auto-tab-discard/\n 안보고 있는 탭을 자동으로 정리해서 메모리 사용량을 줄여줌.  Bitwarden https://addons.mozilla.org/ko/firefox/addon/bitwarden-password-manager/\n 패스워드 매니저.  Clear Cache https://addons.mozilla.org/en-US/firefox/addon/clearcache/\n 캐시삭제 버튼을 만들어 줌.  Dark Reader https://addons.mozilla.org/ko/firefox/addon/darkreader/\n 모든 웹사이트에 다크모드를 적용하여 어둡게 보이도록 함.  Download Filename Encoding https://addons.mozilla.org/ko/firefox/addon/download-filename-encoding/\n 다운로드하는 파일명이 언어 인코딩 때문에 깨지는 것을 방지.  Download Manager (S3) https://addons.mozilla.org/ko/firefox/addon/s3download-statusbar/\n 다운로드 진행상황을 상태표시줄에 표시해줌.  DownThemAll! https://addons.mozilla.org/ko/firefox/addon/downthemall/\n 대량의 파일을 다운로드해주는 관리자.  Enhancer for YouTube https://addons.mozilla.org/ko/firefox/addon/enhancer-for-youtube/\n 유튜브 영상의 반복, 고정등 여러가지 기능을 추가해 줌.  Flagfox https://addons.mozilla.org/ko/firefox/addon/flagfox/\n 현재 접속중인 서버의 위치를 국기로 표시해 줌.  Gesturefy https://addons.mozilla.org/ko/firefox/addon/gesturefy/\n 마우스 제스처로 브라우저를 조작할 수 있게 함.  Google search link fix https://addons.mozilla.org/ko/firefox/addon/google-search-link-fix/\n 구글을 통해 검색한 사이트의 링크를 복사할 때 구글 리퍼러가 붙는것을 막아줌.  Happy Right-Click https://addons.mozilla.org/ko/firefox/addon/%E5%BF%AB%E4%B9%90%E5%8F%B3%E9%94%AE/\n 마우스 오른쪽 버튼이 막혀있는 사이트를 풀어줌.  Imagus https://addons.mozilla.org/ko/firefox/addon/imagus/\n 이미지나 동영상에 커서를 갖다 대었을 때 호버링으로 크게 보여줌.  ImTranslator https://addons.mozilla.org/ko/firefox/addon/imtranslator/\n 팝업 형태로 번역기를 사용할 수 있게 해줌.  Open With https://addons.mozilla.org/ko/firefox/addon/open-with/\n 현재 보고있는 웹페이지를 다른 브라우저로 띄워줌.  Print Edit WE https://addons.mozilla.org/ko/firefox/addon/print-edit-we/\n 웹 페이지에서 자신이 원하는 부분만 잘라내서 프린트하도록 도와줌.  Quick Dial https://addons.mozilla.org/ko/firefox/addon/quick-dial/\n 시작 페이지에 자주가는 웹사이트를 버튼형태로 표시해 줌.  Toolbar Clock https://addons.mozilla.org/ko/firefox/addon/toolbar-clock/\n 상태표시줄에 아날로그 시계를 표시해 줌.  Top and Bottom scroll buttons https://addons.mozilla.org/ko/firefox/addon/top-and-bottom-scroll-buttons/\n 사이트의 맨 위 / 맨 아래로 이동하는 버튼을 표시.  uBlock Origin https://addons.mozilla.org/ko/firefox/addon/ublock-origin/\n 자원을 덜 먹는다고 선전하는 광고차단기.  Undo Close Tab https://addons.mozilla.org/ko/firefox/addon/undoclosetabbutton/\n 최근에 닫은 탭을 다시 여는 버튼을 표시.  View Image https://addons.mozilla.org/ko/firefox/addon/view-image/\n 구글에서 이미지를 검색할 때 이미지 보기 버튼을 추가함.  Wappalyzer https://addons.mozilla.org/ko/firefox/addon/wappalyzer/\n 현재 보는 중인 사이트애 적용된 웹 기술을 보여줌.  weAutoPagerize https://addons.mozilla.org/ko/firefox/addon/weautopagerize/\n 현재 보고있는 페이지의 다음 페이지를 미리 읽어서 현재 페이지에 연결시켜줌.  Zoom Page WE https://addons.mozilla.org/ko/firefox/addon/zoom-page-we/\n 페이지 줌을 편하게 할 수 있는 버튼을 추가함.  Zotero Connector https://www.zotero.org/download/\n 서지정보 관리 프로그램인 Zotero와 브라우저를 연동시켜 줌.   ","description":"","id":10,"section":"posts","tags":["firefox","plugin"],"title":"내가 사용하는 Firefox Plugin","uri":"https://cliearl.github.io/posts/firefox-plugin/"},{"content":"윈도우, Mac, 스마트폰에서 모두 사용할 수 있는 메모 앱을 찾아봤다. 마크다운 포맷을 사용할 수 있으면서 메모를 디렉토리로 관리할 수 있을 것이 조건이었다.\n스탠드얼론 앱 iOS 메모 앱 https://support.apple.com/ko-kr/HT205773\n아이폰을 사용하고 있기에 처음에는 아이폰의 메모 앱을 사용해 봤으나 별 기능도 없고 아이클라우드환경은 윈도우 환경에서 싱크할 수가 없다는 한계가 있었다.\nGoogle Keep https://apps.apple.com/us/app/google-keep-notes-and-lists/id1029207872\n구글 생태계에서 사용할 수 있는 메모 앱. 워드프로세서로 사용하는 느낌이 아닌 포스트잇 같은 느낌으로 사용한다. 개인적 용도와는 맞지않아서 패스함.\nSynology Note Station https://www.synology.com/en-us/dsm/feature/note_station\n시놀로지를 운영할 경우 사용할 수 있는 솔루션. 디렉토리 구성으로 되어있고 필기도 할 수 있는데 초기 로그인 화면이 크게 나타나는게 팬시하지 않고 데이터 싱크가 느리다.\njoplin https://github.com/laurent22/joplin\niOS, 안드로이드, 윈도우, Mac, 리눅스에서 사용할 수 있는 앱을 제공하며 DB는 webdav로 싱크할 수 있다. 메모는 디렉토리로 관리할 수 있다. 오픈소스로 활발하게 업데이트가 이루어진다. 딱 하나 단점은 웹앱이 없어서 브라우저에서 접근이 안된다는 것.\n웹 앱 오픈소스이며 액티브하게 갱신되고 도커이미지가 있는 것을 기준으로 하여 실제로 써본 것들만을 소개한다.\nTrillium Notes https://github.com/zadam/trilium\n자바스크립트로 만들어진 앱. 마크다운 스크립트를 입력하면 실시간으로 화면에 반영되는 위지위그 방식. 메모를 디렉토리 기준으로 관리하며 글만이 아니라 관계도도 그릴 수 있고 암튼 사용할 수 있는 문서형태가 다양하다.\nBookStack https://github.com/BookStackApp/BookStack\nPHP와 라라벨로 만들어진 앱. 메모를 서고와 서가형태로 관리하는데 개인적으로는 이 부분이 직관적으로 느껴지지 않아서 적응하지 못했다.\nWiki.js https://github.com/Requarks/wiki\nNode.js로 만들어진 앱. 메모를 디렉토리 구조로 관리하며 퍼포먼스도 나쁘지 않아 현재 주력으로 사용중.\n","description":"","id":11,"section":"posts","tags":["google keep","synology","note station","note app","joplin","bookstack","wiki.js"],"title":"노트 앱 정착기","uri":"https://cliearl.github.io/posts/finding-note-app/"},{"content":"작업환경에서 사용하는 폰트에 대하여 정리해 보았다.\n텍스트 에디터용 폰트 메모장, 워드, 파워포인트, 한글 등에서 한국어, 영어, 일본어를 모두 표시할 수 있는 폰트가 필요하다.\nGoogle Noto Fonts   어도비와 구글이 합작하여 본고딕이라는 폰트를 출시했다. https://blog.typekit.com/alternate/source-han-sans-kor/\n  이 폰트는 구글에서 Noto Fonts라는 이름으로 풀었다.\n  다운로드 https://www.google.com/get/noto/help/cjk/\n  KoPubWorld  한국출판인회의에서 전자출판에 특화된 서체를 풀었다. 다운로드 http://www.kopus.org/Biz/electronic/Font.aspx  네이버 나눔폰트  네이버에서 나눔시리즈 폰트를 풀었다. 다운로드 https://hangeul.naver.com/2017/nanum  코딩용 폰트 코딩용 폰트에 요구되는 사항들\n 문자열을 스페이스단위로 일치시켜야 하므로 폰트가 고정폭(Monospaced)이어야 한다. 오인식하기 쉬운 알파벳, 특수문자에 대한 대책이 있어야 한다. 특수문자의 가독성을 높여준다고 하는 Ligature는 필수는 아니다. 한글이 깨끗하게 나오면 좋지만 영문체보다 중요하진 않다  개인적으로 괜찮다 생각하는 폰트 (알파벳순)  Consolas 마이크로소프트 개발. D2Coding 네이버 개발. 다닥다닥 붙어있는 느낌. 리가쳐 지원. Fira Code 리가쳐가 이쁘게 나옴. Hack 동글동글한 폰트. IBM Plex Mono IBM 개발. 정렬과 각을 강조. Inconsolata 동글하면서도 살짝 딱딱. Input Mono Inconsolata보다 폭이 약간 넓고 굵음. JetBrains Mono 젯브레인 개발. 아래위로 긴 느낌. 리가쳐 지원. Menlo 애플 개발. Myrica 일본어 코딩용. Source Code Pro 어도비 개발. 글씨폭이 넓고 아래위로 납작한 편. Ubuntu Mono 캐노니컬 개발.  폰트 확인 사이트  Programming Fonts Programming font comparison ","description":"","id":12,"section":"posts","tags":["font","google noto fonts","KoPubWorld","Naver Nanum font"],"title":"작업용 폰트 정보 정리","uri":"https://cliearl.github.io/posts/fonts-for-work/"},{"content":"내가 사용하는 VS Code의 settings.json 내용\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  { \u0026#34;files.autoSave\u0026#34;: \u0026#34;afterDelay\u0026#34;, \u0026#34;editor.fontSize\u0026#34;: 18, \u0026#34;editor.fontFamily\u0026#34;: \u0026#34;\u0026#39;Fira Code\u0026#39;, \u0026#39;Noto Sans CJK KR\u0026#39;\u0026#34;, \u0026#34;editor.fontLigatures\u0026#34;: false, \u0026#34;editor.renderWhitespace\u0026#34;: \u0026#34;boundary\u0026#34;, \u0026#34;editor.wordWrap\u0026#34;: \u0026#34;on\u0026#34;, \u0026#34;editor.wrappingIndent\u0026#34;: \u0026#34;indent\u0026#34;, \u0026#34;editor.rulers\u0026#34;: [ 100, 120 ], \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;git.autofetch\u0026#34;: true, \u0026#34;git.confirmSync\u0026#34;: false, \u0026#34;git.postCommitCommand\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;python.formatting.provider\u0026#34;: \u0026#34;black\u0026#34;, \u0026#34;python.languageServer\u0026#34;: \u0026#34;Microsoft\u0026#34;, \u0026#34;python.linting.pylintEnabled\u0026#34;: false, \u0026#34;python.linting.pylintPath\u0026#34;: \u0026#34;pylint\u0026#34;, \u0026#34;terminal.integrated.shell.windows\u0026#34;: \u0026#34;C:\\\\WINDOWS\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe\u0026#34;, \u0026#34;code-runner.runInTerminal\u0026#34;: true, \u0026#34;code-runner.executorMap\u0026#34;: { \u0026#34;javascript\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;php\u0026#34;: \u0026#34;php\u0026#34;, \u0026#34;python\u0026#34;: \u0026#34;$pythonPath -u $fullFileName\u0026#34;, \u0026#34;perl\u0026#34;: \u0026#34;perl\u0026#34;, \u0026#34;ruby\u0026#34;: \u0026#34;ruby\u0026#34;, \u0026#34;go\u0026#34;: \u0026#34;go run\u0026#34;, \u0026#34;html\u0026#34;: \u0026#34;\\\u0026#34;C:\\\\Program Files (x86)\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe\\\u0026#34;\u0026#34;, \u0026#34;java\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; javac $fileName \u0026amp;\u0026amp; java $fileNameWithoutExt\u0026#34;, \u0026#34;c\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; gcc $fileName -o $fileNameWithoutExt \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026#34;, \u0026#34;cpp\u0026#34;: \u0026#34;cd $dir \u0026amp;\u0026amp; g++ -std=c++14 $fileName -o $fileNameWithoutExt \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026#34; }, \u0026#34;editor.suggestSelection\u0026#34;: \u0026#34;first\u0026#34;, \u0026#34;vsintellicode.modify.editor.suggestSelection\u0026#34;: \u0026#34;automaticallyOverrodeDefaultValue\u0026#34;, }   ","description":"","id":13,"section":"posts","tags":["VS Code","settings.json"],"title":"내가 사용하는 VS Code settings.json","uri":"https://cliearl.github.io/posts/vscode-settings-json/"},{"content":"윈도우 환경에서 VS Code에 파이썬 가상환경 설정하고 사용하는 법에 대해 정리했다.\nvenv 환경 작성  작업폴더를 연 뒤 터미널에서 다음 값 입력  1  $ python3 -m venv .venv     상태표시줄의 파이썬을 눌러 ('.venv')인 python을 선택\n  다음 명령어로 가상환경을 활성화 후 패키지 설치\n  윈도우 macOS  .venv\\\\scripts\\\\activate   source .venv/bin/activate     'use strict'; var containerId = JSON.parse(\"\\\"f3a9b3a304650797\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  code-runner를 실행하기 위한 settings.json 설정 윈도우 macOS  \u0026quot;python.pythonPath\u0026quot;: \u0026quot;blahblah\\\\.venv\\\\Script\\\\python.exe\u0026quot;,   \u0026quot;python.pythonPath\u0026quot;: \u0026quot;.venv/bin/python\u0026quot;,     'use strict'; var containerId = JSON.parse(\"\\\"a08a452ff5480719\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; } ","description":"","id":14,"section":"posts","tags":["python","virtualenv"],"title":"VSCODE에서 Python VirtualEnv 환경설정하기","uri":"https://cliearl.github.io/posts/python-virtualenv-settings/"},{"content":"시놀로지에서 도커 이미지를 업데이트하는 법에 대해 정리하였다.\n  도커패널 \u0026gt; 컨테이너 \u0026gt; 업데이트할 컨테이너 선택후 [작업 -\u0026gt; 중지]\n  도커패널 \u0026gt; 레지스트리 \u0026gt; 업데이트할 이미지 찾아서 [다운로드]\n(이전 다운로드 받은 이미지(image) 삭제 하지 않아도 됨)\n  도커패널 \u0026gt; 업데이트할 컨테이너 선택후 [작업 -\u0026gt; 지우기]\n(이전 설정은 지워지지 않음)\n  도커패널 \u0026gt; 업데이트할 컨테이너 선택후 [작업 -\u0026gt; 시작점]\n ","description":"","id":15,"section":"posts","tags":["synology","docker","update"],"title":"시놀로지 도커 이미지 업데이트하기","uri":"https://cliearl.github.io/posts/synology-docker-update/"},{"content":"내가 사용하는 VS Code의 extension에 대해 정리해보았다.\nActive File In StatusBar  현재 편집하고 있는 파일의 위치를 상태바에 표시.  C/C++  C/C++ 지원  Code Runner  코드 실행을 도와줌. settings.json에 다음 내용을 추가.  \u0026quot;code-runner.executorMap\u0026quot;: { \u0026quot;javascript\u0026quot;: \u0026quot;node\u0026quot;, \u0026quot;php\u0026quot;: \u0026quot;php\u0026quot;, \u0026quot;python\u0026quot;: \u0026quot;$pythonPath -u $fullFileName\u0026quot;, \u0026quot;perl\u0026quot;: \u0026quot;perl\u0026quot;, \u0026quot;ruby\u0026quot;: \u0026quot;ruby\u0026quot;, \u0026quot;go\u0026quot;: \u0026quot;go run\u0026quot;, \u0026quot;html\u0026quot;: \u0026quot;\\\u0026quot;C:\\\\Program Files (x86)\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe\\\u0026quot;\u0026quot;, \u0026quot;java\u0026quot;: \u0026quot;cd $dir \u0026amp;\u0026amp; javac $fileName \u0026amp;\u0026amp; java $fileNameWithoutExt\u0026quot;, \u0026quot;c\u0026quot;: \u0026quot;cd $dir \u0026amp;\u0026amp; gcc $fileName -o $fileNameWithoutExt \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026quot;, \u0026quot;cpp\u0026quot;: \u0026quot;cd $dir \u0026amp;\u0026amp; g++ -std=c++14 $fileName -o $fileNameWithoutExt \u0026amp;\u0026amp; $dir$fileNameWithoutExt\u0026quot; }, CodeMap  탐색창에 파일 속 클래스나 함수구조를 보여줌  Excel Viewer  View Excel spreadsheets and CSV files within Visual Studio Code workspaces.  Git Graph  View a Git Graph of your repository, and perform Git actions from the graph.  indent-rainbow  This extension colorizes the indentation in front of your text alternating four different colors on each step. Some may find it helpful in writing code for Nim or Python.  Kotlin Language  Kotlin language support for VS Code  LaTeX Workshop  Boost LaTeX typesetting efficiency with preview, compile, autocomplete, colorize, and more.  Maintained Swift Development Environment  New home of Swift Development Environment for VS Code  Markdown All in One  All you need to write Markdown (keyboard shortcuts, table of contents, auto preview and more)  PlantUML  Rich PlantUML support for Visual Studio Code.  Path Autocomplete  Provides path completion for visual studio code.  Python  A Visual Studio Code extension with rich support for the Python language (for all actively supported versions of the language: 2.7, \u0026gt;=3.4), including features such as linting, debugging, IntelliSense, code navigation, code formatting, refactoring, unit tests, snippets, and more!  Settings Sync  Synchronize Settings, Snippets, Themes, File Icons, Launch, Keybindings, Workspaces and Extensions Across Multiple Machines Using GitHub Gist.  Todo Tree  Show TODO, FIXME, etc. comment tags in a tree view  Visual Studio IntelliCode  AI-assisted development  vscode-icons  Icons for Visual Studio Code ","description":"","id":16,"section":"posts","tags":["VS Code","extension","plugin"],"title":"내가 사용하는 VS Code Extensions","uri":"https://cliearl.github.io/posts/vscode-extensions/"},{"content":"도커로 Hexo 블로그를 만들고 github.io 주소로 접속하도록 해 보았다.\n개인적으로 사용하고 있는 텍큐 블로그가 있는데 기술관련 내용을 쓰기는 너무 불편하고 오래되기도 해서 마크다운으로 사용할 수 있는 블로그 툴을 찾아봤다.\n처음엔 입출력 속도만 개선해보려고 PHP 버전을 5.6에서 7.3으로 올려봤는데 텍큐가 너무 오래되다보니 패치를 해도 잘 안돌아가고 해서 v7로 올리는 건 포기.\n그 다음으로는 업뎃 잘되는 워드프레스에 텍스트큐브의 블로그 내용을 다 옮기고 기술내용도 거기서 다 같이 쓸려고 했다.\n그래서 TTXML Importer로 데이터를 옮겨봤는데 글만 옮겨지고 그외 카운터 정보같은건 옮길 수가 없었다.\n어차피 블로그를 깔끔하게 옮길 수 없다면 기술블로그 전용 툴을 쓰자 해서 찾은게 Ghost인데 얘는 카테고리나 사이드바 기능이 부족해서 탈락시켰다.\n그 다음으로 찾은 선택지는 정적 사이트 생성기를 이용하는 거였다. 마크다운 쓰기도 좋고, github.io 주소도 사용할 수 있으니 괜찮아보였다. 그래서 찾아보니 Jekyll에는 맘에 드는 스킨이 없어서 Hexo에 Icarus라는 테마를 붙여 써보기로 했다.\n근데 정적 사이트 생성기는 소스를 로컬에 보관하고 github.io로 퍼블리시하는 구조라, 모든 컴퓨터에 Hexo 소스를 보관할 필요가 있다. 이건 너무 바보같아서 Hexo 소스는 도커로 웹에 띄우고 이놈으로부터 github.io에 퍼블리싱하는 방법을 쓰기로 했다. 굳이 따지면 웹에 띄운 시점에서 바로 접속이 가능하니 굳이 퍼블리시를 할 필요는 없는거긴 한데 사이트를 매번 변환하는것보다는 당연히 변환된 저장소에 접속하는 편이 빠르고 무엇보다 github.io 주소를 쓰는 편이 더 geek하기 때문에 사용하기로 했다.\n그래서 이 포스트에서는 리눅스 서버에 도커로 Hexo를 띄우고, Hexo-admin 플러그인으로 퍼블리시한 파일을 github.io에 deploy하여 최종적으로는 유저명.github.io로 정적 블로그를 구축하는 법을 설명한다.\ngithub repository 생성  https://docs.github.com/en/free-pro-team@latest/github/working-with-github-pages/creating-a-github-pages-site 깃헙에 유저명.github.io라는 저장소 생성 이때 속성은 Public, Initialize this repository with a README를 선택 생성된 저장소의 settings → GitHub Pages → Theme Chooser 에서 테마를 아무거나 하나 골라주면 블로그가 가동됨 Your site is published at https://유저명.github.io/ 메시지가 뜨면 접속가능하게 된거임  도커 이미지 선정  https://github.com/spurin/docker-hexo Hexo와 관리용 Hexo-admin이 포함되어 있는 이미지  icarus 테마 셋업 1 2 3 4 5 6 7 8  # ssh로 접속 sudo su - docker ps # 현재 실행중인 컨테이너 확인 docker exec -it xxxxxxxxxxxx /bin/bash # 컨테이너에 접속 git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus # 테마 의존성 패키지 일괄설치 npm install --save bulma-stylus@0.8.0 hexo-renderer-inferno@^0.1.3 hexo-component-inferno@^0.10.1 inferno@^7.3.3 inferno-create-element@^7.3.3 # _config.yml의 theme가 landscape인데 icarus로 수정   hexo-admin에 패스워드 설정  Settings \u0026gt; Setup authentification에서 YAML을 생성 _config.yml의 admin: 밑에 붙여넣는다  hexo-admin에서 deploy 설정  https://github.com/jaredly/hexo-admin/issues/70 sh파일을 만들고 yml 파일을 수정한다  1 2 3 4 5 6 7 8 9 10 11 12  npm install --save hexo-deployer-git # git 배포용 플러그인 설치 touch hexo-deploy.sh; chmod a+x hexo-deploy.sh #!/usr/bin/env sh hexo clean hexo deploy # _config.yml을 수정 deploy: type: git repo: https://계정:패스워드@github.com/저장소.git admin: deployCommand: \u0026#39;./hexo-deploy.sh\u0026#39;   유용한 플러그인 hexo-deployer-git  git으로 배포하기 위한 플러그인  1 2  # 설치 npm install hexo-deployer-git --save   hexo-generator-feed  atom(url/atom.xml ) 혹은 rss2.0(url/rss2.xml)으로 피드 생성해 줌  1 2 3 4 5 6 7 8 9  # 설치 npm install hexo-generator-feed --save # _config.yml 파일 끝에 다음 행 추가 feed: enable: true type: rss2 path: rss2.xml limit: 20   hexo-generator-sitemap  sitemap.xml 파일을 자동생성  1 2 3 4 5 6  # 설치 npm install hexo-generator-sitemap --save # _config.yml 파일 맨 끝에 다음 행 추가 sitemap: path: sitemap.xml   hexo-math  KaTeX and MathJax를 활성화 시켜주는 플러그인 플러그인 설치  1 2  # 설치 npm install hexo-math --save    사용예  1 2 3  {% mathjax %} \\frac{1}{x^2-1} {% endmathjax %}   ","description":"","id":17,"section":"posts","tags":["docker","hexo","github.io","blog"],"title":"도커로 Hexo 블로그 만들고 github.io 주소로 접속하기","uri":"https://cliearl.github.io/posts/docker-hexo-blog/"},{"content":" 도연초 [제 150단]\n이제부터 예술을 익히려는 사람은 일단 \u0026ldquo;못하니까 다른 사람에게 보여주고 싶지 않다. 남몰래 연습해서, 어느정도 볼만하게 되면 보여주는게 멋있다\u0026quot;라고 말하게 되지만, 그런 말을 하는 사람이 최종적으로 성공한 예는 하나도 없다.\n아직 미숙하고 못할 때부터, 베테랑에다 잘하는 사람과 섞여서 바보 취급 당하고 비웃음을 받고 그래도 부끄러워하지 않고 열심히 하면, 특별한 재능이 없어도 잘 하게 된다. 길을 벗어나거나, 아류에 고집하는 일도 없을 것이다. 그대로 연습을 계속하면 그런 태도를 바보취급한 사람들을 아득히 뛰어넘어 달인이 되어간다. 인간적으로도 성장하게 되고, 주변으로부터 존경을 받게 된다.\n지금은 \u0026ldquo;천하에 비길 자 없다\u0026quot;라고 불리는 사람도 처음엔 비웃음당하고, 욕을 먹고, 굴욕을 맛보았다. 그래도 그 사람이 올바르게 배우고, 그 길을 한걸음 한걸음 계속 전진한 덕분에, 많은 사람들이 그 가르침을 받을 수 있게 되었다. 어떠한 세계든지, 똑같은 것이다.\n  \u0026ldquo;No pessimist ever discovered the secret of the stars, or sailed to an uncharted land, or opened a new doorway for the human spirit.\u0026rdquo; — Hellen Keller\n  \u0026ldquo;We are what we repeatedly do. Excellence, then, is not an act, but a habit.\u0026rdquo; — Will Durant\n  \u0026ldquo;Excellence is never an accident. It is always the result of high intention, sincere effort, and intelligent execution; it represents the wise choice of many alternatives - choice, not chance, determines your destiny.\u0026rdquo; ― Aristotle\n  \u0026ldquo;One must live the way one thinks or end up thinking the way one has lived.\u0026rdquo; ― Paul Bourget\n ","description":"About Page","id":18,"section":"","tags":null,"title":"About","uri":"https://cliearl.github.io/about/"}]