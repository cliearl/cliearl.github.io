<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>android on 냉동코더의 기술블로그</title>
    <link>https://cliearl.github.io/categories/android/</link>
    <description>Recent content in android on 냉동코더의 기술블로그</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 12 Feb 2022 10:24:38 +0900</lastBuildDate><atom:link href="https://cliearl.github.io/categories/android/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>내 앱의 MAD score 평가하기</title>
      <link>https://cliearl.github.io/posts/android/evaluate-mad-score/</link>
      <pubDate>Sat, 12 Feb 2022 10:24:38 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/evaluate-mad-score/</guid>
      <description>이번 포스팅에서는 내 앱의 MAD score를 평가하는 방법에 대해 알아보도록 하겠습니다.
MAD score란 구글에서는 안드로이드 앱의 안정성을 향상시키기 위해 여러가지 기술을 도입해 왔는데요, 대표적인 것이 Kotlin 언어와 Jetpack 라이브러리라고 할 수 있을 것 같습니다.
그 외에도 수많은 선진적인 기술을 도입하고 있습니다만, 그러한 기술을 단순히 도입하는데 그치지 않고 실제 개발자들이 기술을 더 잘 이해하고 사용할 수 있도록 Modern Android Development (MAD) Skills 라는 제목으로 블로그 포스팅도 하고, 유튜브에서 강의 영상도 제공하고 있습니다.</description>
    </item>
    
    <item>
      <title>Runtime Permission 이해하고 요청 구현하기</title>
      <link>https://cliearl.github.io/posts/android/request-runtime-permission/</link>
      <pubDate>Sat, 29 Jan 2022 15:10:31 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/request-runtime-permission/</guid>
      <description>이번 포스팅에서는 런타임 퍼미션에 대해 알아보도록 하겠습니다.
들어가기 안드로이드는 카메라나 저장소, 위치 이용와 같이 시스템에 큰 영향을 미칠 수 있는 기능에 대해서는 위험한 권한으로 분류하여 다음과 같이 관리하고 있습니다.
과거에는 앱 설치시 모든 권한을 부여했지만 Android 6.0(API 레벨 23) 이상에서는 앱이 이런 위험한 권한들을 필요로 할 경우 앱 실행중에 권한을 요청할 수 있도록 시스템에 Runtime Permission 을 도입하였습니다. 여기서는 위치 권한을 예로들어 권한을 획득하는 방법을 보여드리겠습니다.
필요한 권한 정의 우선은 AndroidManifest.</description>
    </item>
    
    <item>
      <title>View Binding 사용시 Fragment의 메모리 누수 대응하기</title>
      <link>https://cliearl.github.io/posts/android/prevent-fragment-memory-leak-during-viewbinding/</link>
      <pubDate>Sun, 05 Dec 2021 10:20:46 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/prevent-fragment-memory-leak-during-viewbinding/</guid>
      <description>들어가기 findViewById 대신 View Binding 사용하기 강의에서 View Binding에 대해 다루었습니다. View Binding을 도입하면 코드를 더 안전하게 작성할 수 있고 빌드도 빠르게 할 수 있습니다.
Fragment에서의 메모리 누수 그런데 Fragment에서 View Binding을 쓸 때는 메모리 누수가 일어날 수 있는 문제가 있습니다. 다음 그림을 보시면 Fragment 속의 View는 onDestroyView에서 파괴되고 생명주기가 종료되지만, 그 시점에서 Fragment는 여전히 유지되고 있는 것을 알 수 있습니다.
메모리 누수 대응법 _binding의 직접 해제 그래서 구글에서는 Fragment에서 View Binding을 적용할 때 다음과 같이 _binding 변수를 만들어 사용한 뒤 onDestroyView에서 해제해주는 구조를 공식 문서 에서 제안하고 있습니다.</description>
    </item>
    
    <item>
      <title>Retrofit으로 다운받은 Json 데이터를 RecyclerView에 표시하기</title>
      <link>https://cliearl.github.io/posts/android/download-json-data-using-retrofit/</link>
      <pubDate>Sun, 07 Nov 2021 08:32:11 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/download-json-data-using-retrofit/</guid>
      <description>이번 포스팅에서는 Retrofit 라이브러리로 HTTP 통신을 수행하는 법에 대해 알아보도록 하겠습니다.
안드로이드에서의 HTTP 통신에 대한 개괄적 설명과 Retrofit을 사용해야 하는 이유에 대해서는 안드로이드의 HTTP 통신 라이브러리 고찰에서 다루었으니 그것을 참조하시면 좋을 것 같습니다. 또한 Retrofit의 기술적 특징에 대해서는 라이브러리 제작자가 설명해 둔 Retrofit 2과 함께하는 정말 쉬운 HTTP 를 보는것이 가장 정확할 것 같습니다.
이 강의에서는 경기데이터드림에서 제공하는 코로나바이러스 감염증 선별진료소 운영 의료기관 현황 API를 통해 가져온 JSON 데이터를 Recyclerview에 표시해보면서 Retrofit을 어떻게 사용하는지 알아보도록 하겠습니다.</description>
    </item>
    
    <item>
      <title>안드로이드의 HTTP 통신 라이브러리 고찰</title>
      <link>https://cliearl.github.io/posts/android/android-http-library-review/</link>
      <pubDate>Sat, 23 Oct 2021 10:58:16 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/android-http-library-review/</guid>
      <description>이번 포스팅에서는 안드로이드의 HTTP 통신에 대해 알아보도록 하겠습니다.
안드로이드에서의 통신 앱에서 가장 많이 수행하는 처리중 하나는 서버에 데이터를 요청하고 받아온 데이터를 단말-다시말해 클라이언트의 화면에 표시하는 것입니다. 이 때 클라이언트와 서버가 통신하는 방식은 크게 소켓연결과 HTTP연결 두 가지로 나눌 수 있습니다.
소켓 연결 소켓은 네트워크 상의 두 프로그램 사이에서 일어나는 양방향 통신중 한 쪽의 엔드 포인트를 의미합니다. 여기서 엔드포인트란 IP와 포트의 조합을 뜻합니다.
소켓 연결방식에서는 클라이언트와 서버가 특정 포트를 통해 연결을 계속 유지하고 있기 때문에 실시간으로 양방향 통신을 할 수 있는데요, 주로 동영상 스트리밍이나, 온라인 게임등에서 사용되는 연결방식입니다.</description>
    </item>
    
    <item>
      <title>내가 Android Studio에서 사용하는 Plugins</title>
      <link>https://cliearl.github.io/posts/android/android-studio-plugins/</link>
      <pubDate>Sun, 10 Oct 2021 09:13:13 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/android-studio-plugins/</guid>
      <description>이번 포스팅에서는 제가 즐겨 사용하는 Android Studio의 플러그인을 소개해 보도록 하겠습니다.
ADB Wi-Fi  https://plugins.jetbrains.com/plugin/14969-adb-wi-fi 개발장비와 모바일기기는 Android Debug Bridge(ADB)를 통해 USB나 Wifi로 연결할 수 있는데요, ADB Wi-Fi는 Wifi를 통한 ADB연결을 간편하게 수행해줍니다  CodeGlance  https://plugins.jetbrains.com/plugin/7275-codeglance Sublime text처럼 에디터 오른쪽에 코드 미니맵을 표시해줍니다  CPU Usage Indicator  https://plugins.jetbrains.com/plugin/8580-cpu-usage-indicator 스테이터스바에 IDE와 전체 시스템의 CPU 사용량을 표시합니다  CSV  https://plugins.jetbrains.com/plugin/10037-csv CSV 파일을 테이블 형식으로 열람하고 편집할 수 있게 해 줍니다  GitToolBox  https://plugins.</description>
    </item>
    
    <item>
      <title>SQLite 이해하고 SQLiteOpenHelper로 CRUD 구현하기</title>
      <link>https://cliearl.github.io/posts/android/implement-crud-with-sqliteopenhelper/</link>
      <pubDate>Sat, 25 Sep 2021 17:33:35 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/implement-crud-with-sqliteopenhelper/</guid>
      <description>이번 포스팅에서는 두 파트에 걸쳐 안드로이드에서 SQLite를 다루는 법에 대해 알아보도록 하겠습니다.
Part A. 데이터베이스 관계형 데이터베이스 여러 사람들의 연락처 데이터는 다음과 같이 테이블 구조로 관리할 수 있습니다. 이런 식으로 통일된 규칙의 데이터를 관리할 수 있는 테이블을 데이터베이스라고 합니다.
   순서 이름 전화번호 이메일 주소     0 김철수 010-1111-1111 kim@abc.com 서울   1 이영희 010-2222-2222 lee@abc.com 서울   2 박모모 010-3333-3333 park@abc.com 인천    이 때 1행 2열의 이름을 Key라고 하고 2행 2열의 김철수를 Value라고 합니다.</description>
    </item>
    
    <item>
      <title>알기쉬운 Singleton Pattern</title>
      <link>https://cliearl.github.io/posts/android/understanding-singleton-pattern/</link>
      <pubDate>Sun, 05 Sep 2021 15:59:57 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/understanding-singleton-pattern/</guid>
      <description>이번 포스팅에서는 싱글톤 패턴에 대해 알아보도록 하겠습니다.
Singleton 이란 싱글톤(Singleton)은 소프트웨어 디자인패턴의 한 종류로, 프로그램 안에서 클래스의 인스턴스가 단 하나만 존재해야 할 때 사용합니다. 예를들어 데이터베이스를 변경할 수 있는 DBHandler 클래스의 인스턴스가 두개 있어서 동시에 데이터베이스에 접근한다면 문제가 생기겠죠.
자바에서는 일반적으로 다음과 같은 방식으로 싱글톤을 구현할 수 있습니다. private를 이용해 외부에서 생성자에 접근하지 못하도록 막고 getInstance를 통해야 인스턴스를 만들 수 있게 합니다. 이 때 static instance를 확인해서 인스턴스가 없으면 객체를 새로 만들고, 있다면 그대로 반환해주는 구조를 가집니다.</description>
    </item>
    
    <item>
      <title>Android Studio Arctic Fox와 JDK 11의 도입</title>
      <link>https://cliearl.github.io/posts/android/android-gradle-java-11/</link>
      <pubDate>Sun, 15 Aug 2021 14:23:23 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/android-gradle-java-11/</guid>
      <description>이번 포스팅에서는 Android Studio Arctic Fox와 JDK 11의 도입에 관한 내용을 다루어보도록 하겠습니다.
Android Gradle 7.0.0 도입 2021년 7월 말에 Android Studio의 버전이 Arctic Fox|2020.3.1 로 올라갔습니다. 그 과정에서 Android Gradle plugin의 버전도 4.2.0에서 7.0.0으로 올라갔는데요, Android Gradle 7.0.0의 사양은 다음과 같습니다.
    Default Version     Gradle 7.0.2   SDK Build Tools 30.0.2   NDK 21.4.7075529   JDK 11    이번 플러그인의 가장 큰 변화중 하나는 디폴트 JDK 버전을 1.</description>
    </item>
    
    <item>
      <title>jsoup으로 로또 홈페이지의 당첨번호 파싱하기</title>
      <link>https://cliearl.github.io/posts/android/jsoup-lotto-checker/</link>
      <pubDate>Sat, 14 Aug 2021 11:03:31 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/jsoup-lotto-checker/</guid>
      <description>이번 포스팅에서는 jsoup을 이용해서 html을 파싱하는 법에 대해 알아보도록 하겠습니다.
jsoup이란 jsoup은 html을 파싱하기 위해 만들어진 오픈소스 자바 라이브러리입니다. 웹페이지를 HTML5 DOM으로 변환하여 요소들을 간편하게 추출할 수 있습니다. 자바 라이브러리이니만큼 코틀린에서도 자유롭게 사용이 가능하지요.
jsoup에는 여러가지 클래스가 있는데 그 중 제 생각에 중요한 것들만 정리하면 다음과 같습니다.
   클래스 설명     Document jsoup로 얻어온 html 문서   Element 데이터를 추출할 수 있는 개별 html 요소   Elements Iterable한 Element 집합의 자료형   Connection http 접속에 관련한 메소드를 가지는 클래스    파싱할 html 구조 확인 그럼 코루틴으로 로또번호 당첨 확인하기 강의에서 만들었던 코루틴으로 로또번호 당첨을 확인하는 앱에 jsoup을 적용해보도록 하겠습니다.</description>
    </item>
    
    <item>
      <title>DiffUtil과 ListAdapter 이해하고 RecyclerView에 적용하기</title>
      <link>https://cliearl.github.io/posts/android/recyclerview-listadapter/</link>
      <pubDate>Sat, 31 Jul 2021 21:22:17 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/recyclerview-listadapter/</guid>
      <description>이번 포스팅에서는 RecyclerView에 ListAdapter를 적용하는 법에 대해 알아보도록 하겠습니다.
들어가기 Recyclerview의 데이터가 변하면 Recyclerview Adapter가 제공하는 notifyItem 메소드를 사용해서 ViewHolder 내용을 갱신할 수 있습니다.
notifyItemChanged(int) notifyItemInserted(int) notifyItemRemoved(int) notifyItemRangeChanged(int, int) notifyItemRangeInserted(int, int) notifyItemRangeRemoved(int, int) 그런데 데이터가 변경되는 방식을 확인하고 그때마다 이렇게 notify를 일일이 해 주는것은 번거롭기도 하고, 또 사용하기에 따라서는 갱신이 필요없는 ViewHolder를 같이 갱신하는 불필요한 작업이 생길수도 있습니다.
DiffUtil DiffUtil은 두 데이터셋을 받아서 그 차이를 계산해주는 클래스입니다. DiffUtil을 사용하면 두 데이터 셋을 비교한 뒤 그중 변한부분만을 파악하여 Recyclerview에 반영할 수 있습니다.</description>
    </item>
    
    <item>
      <title>2021년 7월 현재, minSdkVersion 몇으로 해야 할까?</title>
      <link>https://cliearl.github.io/posts/android/how-much-minsdkversion/</link>
      <pubDate>Mon, 19 Jul 2021 18:39:10 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/how-much-minsdkversion/</guid>
      <description>minSdkVersion 과연 몇으로 해야할지 정해드립니다.
다음 코드는 build.gradle의 코드 일부입니다. build.gradle의 minsdkversion은 내 앱을 설치할 수 있는 기기버전을 정하는 인자인데요, 낮으면 낮을수록 더 많은 기기에 앱을 설치할 수 있지만 그만큼 앱을 설계할 때 구형 API까지 고려해야 한다는 문제가 있습니다.
android { compileSdkVersion 30 buildToolsVersion &amp;#34;30.0.3&amp;#34; defaultConfig { applicationId &amp;#34;com.example.myapplication&amp;#34; minSdkVersion 16 targetSdkVersion 30 versionCode 1 versionName &amp;#34;1.0&amp;#34; testInstrumentationRunner &amp;#34;androidx.test.runner.AndroidJUnitRunner&amp;#34; } 그렇다면 2021년 7월 현재, 앱의 minSdkVersion은 몇으로 하는게 적당할까요?
API 버전별 특징 그걸 판단하기 위해서 API별로 어떤 기능이 추가되었는지를 확인하는게 좋을 것 같습니다.</description>
    </item>
    
    <item>
      <title>코루틴으로 로또번호 당첨 확인하기</title>
      <link>https://cliearl.github.io/posts/android/lotto-checker/</link>
      <pubDate>Sat, 17 Jul 2021 16:01:01 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/lotto-checker/</guid>
      <description>이번 포스팅에서는 코루틴을 사용해서 로또번호의 당첨을 확인하는 법에 대해 알아보도록 하겠습니다.
당첨번호 조회하기 이전에 로또번호 생성기 만들기강의에서 로또번호를 생성하는 앱을 만들어보았는데요, 여기서는 이 앱에 코루틴을 이용해서 당첨여부를 확인하는 기능을 추가하도록 하겠습니다. 코루틴에 대한 이론설명은 알기쉬운 코루틴 이론 강의를 참조하시기 바랍니다.
금주의 로또 당첨번호는 동행복권 홈페이지에서 확인할 수 있습니다. 다른 회차의 당첨번호는 홈페이지의 회차별 당첨번호 페이지에서 확인할 수 있게 되어 있습니다.
그런데 이렇게 홈페이지에 접속하지 않고도 당첨번호는 API로 조회할 수 있습니다. 다음 주소의 &amp;ldquo;회차&amp;quot;라고 되어 있는 부분에 확인하고 싶은 회차의 숫자를 넣으시면 됩니다.</description>
    </item>
    
    <item>
      <title>알기쉬운 코루틴 이론</title>
      <link>https://cliearl.github.io/posts/android/coroutine-principle/</link>
      <pubDate>Mon, 28 Jun 2021 22:01:50 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/coroutine-principle/</guid>
      <description>이번 포스팅에서는 코틀린의 코루틴(Coroutine)에 대해 알아보도록 하겠습니다.
코루틴의 개념 안드로이드에서는 AsyncTask를 이용해서 손쉽게 비동기 프로그래밍을 구현했었지만 구글이 다음과 같이 밝힌 것처럼 메모리 누수등 여러가지 문제가 있었습니다. 그래서 API 30부터는 AsyncTask를 deprecate 시키고 코루틴을 사용하도록 권장하고 있습니다.
 AsyncTask was intended to enable proper and easy use of the UI thread. However, the most common use case was for integrating into UI, and that would cause Context leaks, missed callbacks, or crashes on configuration changes.</description>
    </item>
    
    <item>
      <title>로또번호 생성기 만들기</title>
      <link>https://cliearl.github.io/posts/android/lotto-generator/</link>
      <pubDate>Sun, 20 Jun 2021 21:10:32 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/lotto-generator/</guid>
      <description>이번 포스팅에서는 로또번호를 생성하는 간단한 앱을 만들어보도록 하겠습니다.
사양 정의 버튼을 누르면 1~45 사이에서 랜덤하게 6개의 번호를 추출하고 번호에 대응하는 이미지를 화면에 표시하도록 합니다. 재미를 위해서 전체 번호의 합과, 홀짝 비율이 어떻게 되는지도 같이 화면에 표시해 주도록 하겠습니다.
화면 디자인 drawable 폴더에는 번호순서대로 숫자와 색깔을 반영시킨 로또 공 이미지를 저장합니다. 화면에 ImageView 그룹을 추가하여 로또 공 이미지를 표시하고, TextView에는 번호합과 홀짝비율을 표시하도록 하겠습니다.
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; xmlns:app=&amp;#34;http://schemas.android.com/apk/res-auto&amp;#34; xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34; android:layout_width=&amp;#34;match_parent&amp;#34; android:layout_height=&amp;#34;match_parent&amp;#34; tools:context=&amp;#34;.</description>
    </item>
    
    <item>
      <title>단말의 인터넷 연결상태 체크하기</title>
      <link>https://cliearl.github.io/posts/android/check-connection/</link>
      <pubDate>Sun, 13 Jun 2021 21:51:49 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/check-connection/</guid>
      <description>이번 포스팅에서는 단말의 인터넷 연결상태를 체크하는 법에 대해 알아보도록 하겠습니다.
앱을 만들다보면 WIFI를 사용할 수 있는 환경에서 대용량 데이터를 다운로드하도록 하는 등의 처리를 위해 단말의 인터넷 연결상태를 체크해야 할 일이 있습니다. 이때 ConnectivityManager를 사용하면 단말이 어떤 접속환경을 통해 인터넷에 연결되어 있는지 확인할 수 있습니다.
권한추가 인터넷에 접근하고 네트워크 상태를 가져오기 위해 AndroidManifest.xml에 다음 권한을 추가합니다.
&amp;lt;uses-permission android:name=&amp;#34;android.permission.ACCESS_NETWORK_STATE&amp;#34; /&amp;gt; &amp;lt;uses-permission android:name=&amp;#34;android.permission.INTERNET&amp;#34; /&amp;gt; 네트워크 타입 확인 우선은 단말이 연결된 네트워크가 와아파이인지 셀룰러인지 확인하는 코드를 써 보겠습니다.</description>
    </item>
    
    <item>
      <title>Assets 폴더에서 로딩한 json 파일 Recyclerview에 표시하기</title>
      <link>https://cliearl.github.io/posts/android/assets-json-recycler/</link>
      <pubDate>Wed, 05 May 2021 23:05:14 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/assets-json-recycler/</guid>
      <description>이번 포스팅에서는 Assets 폴더를 사용하는 법에 대해 알아보겠습니다.
안드로이드의 읽기전용 파일 저장폴더 앱을 만들다보면 읽기전용 파일을 앱에 저장하고 불러와서 사용해야 할 때가 있습니다. 이 때 파일은 다음 두 폴더에 저장할 수 있습니다.
 assets folder resources/raw folder  각 폴더의 특징은 다음과 같습니다.
   값 assets res/raw     파일명 자유롭게 설정 가능 a-z, 0-9, _ 만 사용가능   서브폴더 사용가능 사용불가   파일 리스팅 list()로 가능 불가능   컴파일타임 파일체크 없음 있음   XML에서 접근 불가능 가능   환경별 설정 분리 불가능 가능    간단히 정리하면 XML과 연계하여 다루어야 할 때는 res/raw 폴더를 사용하고, 그렇지 않을 경우 assets 폴더를 사용하면 될 것 같네요.</description>
    </item>
    
    <item>
      <title>ViewPager2와 TabLayout을 이용해 스와이프 되는 화면 구현하기</title>
      <link>https://cliearl.github.io/posts/android/viewpager2-tablayout/</link>
      <pubDate>Sun, 02 May 2021 22:44:04 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/viewpager2-tablayout/</guid>
      <description>이번 포스팅에서는 ViewPager2와 TabLayout을 이용해 스와이프 되는 화면을 구현해 보도록 하겠습니다.
ViewPager2를 사용하는 이유나 장점에 대해서는 ViewPager1 프로젝트를 ViewPager2 프로젝트로 변환하기 포스팅에서 다루었으니 그 내용을 참조해 주시기 바랍니다.
플러그인 추가 우선은 뷰바인딩 사용설정 및 ViewPager2 플러그인을 추가합니다.
// 뷰바인딩 사용준비 android { buildFeatures.viewBinding true } // ViewPager2 라이브러리 추가 dependencies { implementation &amp;#39;androidx.viewpager2:viewpager2:1.0.0&amp;#39; } Fragment의 레이아웃 작성 다음은 new -&amp;gt; fragment 를 선택하여 테스트용으로 사용할 프래그먼트를 만들어줍니다. 텍스트를 화면 중간에 표시하기 위해 코드를 약간 변경합니다.</description>
    </item>
    
    <item>
      <title>스플래쉬 스크린 설정하기</title>
      <link>https://cliearl.github.io/posts/android/splashscreen/</link>
      <pubDate>Wed, 28 Apr 2021 21:46:44 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/splashscreen/</guid>
      <description>이번 포스팅에서는 스플래시 스크린을 만드는 법에 대해 알아보도록 하겠습니다.
아이콘을 선택하고 앱이 구동되서 메인화면을 보여주기 전까지 로딩 시간이 필요한데 그 시간동안 보여주는 화면을 스플래시 스크린이라고 합니다. 이때 앱 아이콘과 동일한 이미지로 스플래시 스크린을 설정하면 아이콘이 튀어 나오는듯한 효과를 볼 수 있습니다.
코딩 타임 이번 앱은 앱 아이콘을 설정하는 강의에서 만들었던 프로젝트를 변경하여 만들어 보도록 하겠습니다.
우선은 스플래시 스크린에 표시할 이미지를 선정해야 하는데, 저는 이전에 앱 아이콘으로 사용했던 이미지를 그대로 사용하도록 하겠습니다.</description>
    </item>
    
    <item>
      <title>App Icon 설정하기</title>
      <link>https://cliearl.github.io/posts/android/appicon/</link>
      <pubDate>Wed, 28 Apr 2021 21:46:35 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/appicon/</guid>
      <description>이번 포스팅에서는 앱에 아이콘을 설정하는 방법에 대해 알아보도록 하겠습니다.
Legacy Icon과 Adaptive Icon 안드로이드 앱에서는 현재 두 가지 종류의 아이콘을 사용할 수 있습니다. 하나는 Legacy Icon이고 또 하나는 Adaptive Icon입니다.
Adaptive Icon은 다양화된 기기의 해상도와 UI 디자인에 대응하기 위해 제안된 규격으로, 안드로이드는 iOS와 달리 여러 제조사에서 여러 규격의 기기를 만들기 때문에 해상도에 많은 차이가 있고, 회사마다 고유의 UI 디자인을 사용하기 때문에 앱 아이콘의 형태도 조금씩 달라지게 됩니다.
그래서 구글에서는 Adaptive Icon이라는 규격을 제안했습니다.</description>
    </item>
    
    <item>
      <title>ProgressBar로 AsyncTask 이해하기</title>
      <link>https://cliearl.github.io/posts/android/progressbar-asynctask/</link>
      <pubDate>Sun, 25 Apr 2021 15:35:18 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/progressbar-asynctask/</guid>
      <description>이번 포스팅에서는 ProgressBar와 AsyncTask의 사용방법에 대해 알아보도록 하겠습니다.
들어가기 ProgressBar는 안드로이드가 어떤 작업을 진행할때 그 작업의 진행상황을 보여주는 모듈입니다. 시간이 걸리는 처리가 필요할 때 표시해주면 기다리는 유저의 거부감을 줄일 수 있습니다. 이 기능은 기존에는 ProgressDialog를 이용해서 구현했는데 다이얼로그가 표시될 때 유저의 조작을 제한한다는 문제가 있어 API level 26에서 deprecated 되고 ProgressBar로 대체되었습니다.
메인 스레드의 관점에서 보면 ProgressBar는 처리에 긴 시간이 걸리기 때문에 메인 스레드와는 별개의 스레드에서 처리를 수행해야 할 필요가 있습니다.</description>
    </item>
    
    <item>
      <title>Google Admob으로 보상형 광고 표시하기</title>
      <link>https://cliearl.github.io/posts/android/gadmob-rewarded/</link>
      <pubDate>Sat, 24 Apr 2021 21:48:55 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/gadmob-rewarded/</guid>
      <description>이번 포스팅에서는 보상형 광고를 표시하는 법에 대해 알아보도록 하겠습니다. 보상형 광고란 광고를 본 댓가로 어떤 아이템이나 보상을 주는 형태의 광고를 말합니다.
우선은 애드몹 디펜던시를 추가합니다. 현재 애드몹 라이브러리의 최신버전은 19.7.0인데요, 19.6.0과 사용법이 많이 다르기 때문에 두 방법 모두 설명하도록 하겠습니다.
Google Admob Version 19.6.0 이하에서의 구현 dependencies { implementation &amp;#39;com.google.android.gms:play-services-ads:19.6.0&amp;#39; } AndroidManifest.xml 안에 애드몹 사이트에서 부여받는 앱 ID를 입력합니다. 여기서는 구글에서 테스트용으로 제공하는 ID를 입력하였습니다.
&amp;lt;uses-permission android:name=&amp;#34;android.permission.INTERNET&amp;#34; /&amp;gt; &amp;lt;application &amp;lt;meta-data android:name=&amp;#34;com.</description>
    </item>
    
    <item>
      <title>Google Admob으로 전면광고 표시하기</title>
      <link>https://cliearl.github.io/posts/android/gadmob-interstitial/</link>
      <pubDate>Thu, 22 Apr 2021 20:36:18 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/gadmob-interstitial/</guid>
      <description>이번 포스팅에서는 구글 애드몹을 이용해서 전면광고를 표시하는 법에 대해 알아보도록 하겠습니다.
우선은 애드몹 디펜던시를 추가합니다. 현재 애드몹 라이브러리의 최신버전은 19.7.0인데요, 19.6.0 버전과는 사용법이 많이 다르기 때문에 두 방법 모두 설명하도록 하겠습니다.
Google Admob Version 19.6.0 이하에서의 구현 dependencies { implementation &amp;#39;com.google.android.gms:play-services-ads:19.6.0&amp;#39; } AndroidManifest.xml 안에 애드몹 사이트에서 부여받는 앱 ID를 입력합니다. 여기서는 구글에서 테스트용으로 제공하는 ID를 입력하였습니다.
&amp;lt;uses-permission android:name=&amp;#34;android.permission.INTERNET&amp;#34; /&amp;gt; &amp;lt;application &amp;lt;meta-data android:name=&amp;#34;com.google.android.gms.ads.APPLICATION_ID&amp;#34; android:value=&amp;#34;ca-app-pub-3940256099942544~3347511713&amp;#34; /&amp;gt; &amp;lt;/application&amp;gt; 다음은 화면에 광고를 표시하는 버튼을 추가합니다.</description>
    </item>
    
    <item>
      <title>SharedPreferences를 json 포맷으로 관리하기</title>
      <link>https://cliearl.github.io/posts/android/sharedpreferneces-gson/</link>
      <pubDate>Thu, 22 Apr 2021 20:33:39 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/sharedpreferneces-gson/</guid>
      <description>이번 포스팅에서는 SharedPreferences에 복잡한 형태의 데이터를 json 포맷으로 저장하고 불러오는 법에 대해 알아보도록 하겠습니다.
SharedPreferences는 Key-Value 형태로 이루어진 딕셔너리를 저장하도록 설계된 저장장소인데요, 이 Value 부분에 json으로 구성된 긴 형태의 데이터를 저장함으로써 복잡한 형태의 데이터도 저장할 수가 있습니다.
이 때 앱 안의 데이터를 json으로 Serialize하고 다시 복원하는 Deserialize를 편하게 실행하게 해 주는 Gson이라는 라이브러리가 있습니다. 이번 포스팅에서는 이 라이브러리를 활용하겠습니다.
여기서는 Data class 이해하고 RecyclerView에서 사용하기 강의에서 만들었던 프로젝트를 수정하면서 구현해보겠습니다.</description>
    </item>
    
    <item>
      <title>Google Admob으로 배너광고 표시하기</title>
      <link>https://cliearl.github.io/posts/android/gadmob-banner/</link>
      <pubDate>Wed, 21 Apr 2021 22:17:58 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/gadmob-banner/</guid>
      <description>이번 포스팅에서는 구글 애드몹 라이브러리를 이용해서 앱에 배너광고를 표시하는 법에 대해 알아보도록 하겠습니다.
우선은 build.gradle에 애드몹 라이브러를 추가해줍니다.
dependencies { implementation &amp;#39;com.google.android.gms:play-services-ads:19.7.0&amp;#39; } 다음은 AndroidManifest.xml에 인터넷 접근권한을 부여하고 애드몹 ID 정보를 추가합니다. 애드몹 ID는 구글 애드몹 사이트에 가입하고 자신의 앱을 등록하면 받을 수 있습니다. 여기서는 Mobile Ads SDK (Android)에서 테스트를 할때 사용하라고 주는 값을 사용하였습니다.
&amp;lt;uses-permission android:name=&amp;#34;android.permission.INTERNET&amp;#34;/&amp;gt; &amp;lt;application &amp;lt;meta-data android:name=&amp;#34;com.google.android.gms.ads.APPLICATION_ID&amp;#34; android:value=&amp;#34;ca-app-pub-3940256099942544~3347511713&amp;#34; /&amp;gt; &amp;lt;/application&amp;gt; 다음은 화면 xml에 광고를 표시하기 위한 AdView를 추가합니다.</description>
    </item>
    
    <item>
      <title>SharedPreferences로 앱 설정값 저장하고 불러오기</title>
      <link>https://cliearl.github.io/posts/android/sharedpreferences-basic/</link>
      <pubDate>Tue, 20 Apr 2021 21:35:43 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/sharedpreferences-basic/</guid>
      <description>이번 포스팅에서는 SharedPreferences를 사용하는 법에 대해 알아보도록 하겠습니다.
데이터를 앱에 저장하는 방법 데이터를 앱에 저장하는 방법에는 크게 세가지가 있습니다.
 파일 I/O (내부 또는 외부 저장소)  접근 권한을 획득하고 파일을 열었다 닫았다 하는 수고가 필요함   관계형 데이터베이스  SQLite 등을 이용해 복잡한 관계형 데이터를 저장할 수 있음 간단한 데이터를 저장할거라면 구축과 관리에 많은 시간과 노려이 요구됨   SharedPreference  Key/Value 형태로 이용함 내부적으로는 XML 파일로 저장됨 파일을 열고 닫을 필요 없이 핸들러를 만들어서 간편하게 사용가능함    SharedPreferences는 보통 복잡한 데이터를 기록하기보다는, 게임의 환경설정이라든지 그런 단순한 내용을 저장하는데 적절한 저장공간이라고 생각하면 됩니다.</description>
    </item>
    
    <item>
      <title>RecyclerView를 Swipe, Drag, Touch하기</title>
      <link>https://cliearl.github.io/posts/android/recyclerview-touch/</link>
      <pubDate>Sun, 18 Apr 2021 22:40:04 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/recyclerview-touch/</guid>
      <description>이번 포스팅에서는 RecyclerView에 Swipe, Drag, Touch 동작을 연결하는 법에 대해 알아보도록 하겠습니다.
이번에 만들어볼 앱에서는 ViewHolder를 스와이프하면 삭제가 되고, 잡고 끌면 위아래로 ViewHolder를 이동할 수 있으며, ViewHolder를 터치하면 그 내용이 변하는 동작을 수행하도록 하겠습니다.
여기서는 제가 RecyclerView에 View Binding 적용하기 강의에서 만들었던 Recyclerview 앱을 수정하는 방식으로 구현해보겠습니다.
리팩토링 우선 View Binding을 사용하도록 설정을 추가합니다.
android { buildFeatures.viewBinding true } 메인액티비티에서 만들어주던 dataSet은 초기화시 데이터를 바로 입력하도록 하고 Recyclerview 어댑터 안쪽으로 이동시켜서 받아오는 파라미터를 삭제합니다.</description>
    </item>
    
    <item>
      <title>앱에서 RecyclerView 사용하기</title>
      <link>https://cliearl.github.io/posts/android/recyclerview-implement/</link>
      <pubDate>Sat, 17 Apr 2021 22:43:43 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/recyclerview-implement/</guid>
      <description>이번 포스팅에서는 Recyclerview를 사용하는 법에 대해 알아보도록 하겠습니다.
Recyclerview의 특징 Recyclerview는 화면에 리스트 형식의 데이터를 표시하기 위해서 사용하는 모듈입니다. 보통 화면에 리스트뷰를 표시할수 있게 하는 ListView는 예를들어 데이터가 10개 있을 경우 데이터를 표시하기 위한 ViewHolder가 10개 필요합니다. 그러나 Recyclerview는 ViewHolder를 6개만 만들고 화면에는 5개를 표시한 후 화면 바깥으로 1번 ViewHolder가 빠져나가면 7번 ViewHolder로 변경해서 재사용합니다. 그래서 자원을 더 아낄 수 있게 되는 것이죠.
또 데이터는 Recyclerview Adapter를 통해 ViewHolder에 들어가게 되는데 ViewHolder에 데이터 1을 넣어서 표현했을 경우, ViewHolder는 그대로 놔두고 데이터 2를 넣는 식으로 ViewHolder를 재활용해서 사용할 수 있습니다.</description>
    </item>
    
    <item>
      <title>RecyclerView에 View Binding 적용하기</title>
      <link>https://cliearl.github.io/posts/android/viewbinding-recyclerview/</link>
      <pubDate>Sat, 17 Apr 2021 22:43:04 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/viewbinding-recyclerview/</guid>
      <description>이번 포스팅에서는 RecyclerView에 View Binding을 적용하는 법에 대해 알아보도록 하겠습니다.
View Binding을 사용해야 하는 이유나 그 장점에 대해서는 findViewById 대신 View Binding 사용하기 포스팅과 유튜브 강의를 참조하시고 이번 포스팅에선 변환하는 방법에 대해서만 설명하도록 하겠습니다.
이번 포스팅에서 변환에 사용한 프로젝트는 앱에서 RecyclerView 사용하기 포스팅에서 작성한 것을 사용하도록 하겠습니다.
코드 작성 View Binding 활성화 우선은 gradle에서 kotlin-android-extensions 플러그인을 삭제하고 View Binding을 활성화합니다.
plugins { - id &amp;#39;kotlin-android-extensions&amp;#39; } android { + buildFeatures.viewBinding true } 메인액티비티 수정 다음은 메인액티비티를 수정해줍니다.</description>
    </item>
    
    <item>
      <title>ViewPager1 프로젝트를 ViewPager2 프로젝트로 변환하기</title>
      <link>https://cliearl.github.io/posts/android/viewpager2-convert/</link>
      <pubDate>Sat, 17 Apr 2021 18:38:59 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/viewpager2-convert/</guid>
      <description>이번 포스팅에서는 프로젝트 안에 작성된 ViewPager1 모듈을 ViewPager2 모듈로 변환하는 법에 대해 알아보도록 하겠습니다.
안드로이드 라이브러리가 androidx로 바뀌는 과정에서 ViewPager 라이브러리도 업그레이드 해달라는 요구가 꽤 많았습니다. 그래서 구글에서는 ViewPager2 라이브러리를 개발했습니다.
ViewPager2의 특징 구글에서 설명하는 ViewPager2의 [장점]((https://developer.android.com/training/animation/vp2-migration)은 다음과 같습니다.
 Vertical scrolling : 세로스크롤 Right-to-left support : 페이지를 오른쪽에서 왼쪽으로 정렬 modifiable Fragment collenctions : 프래그먼트의 변화를 동적으로 반영 가능 DiffUtil : Recyclerview의 DiffUtil을 사용 가능 ViewPager1 라이브러리는 더이상 관리되지 않음  ViewPager2로 변환 여기서는 기존에 ViewPager를 써서 좌우로 스와이프되는 화면 만들기 강의에서 작성했던 ViewPager1 프로젝트를 변환하는 방식으로 구현해 보도록 하겠습니다.</description>
    </item>
    
    <item>
      <title>ViewPager를 써서 좌우로 스와이프되는 화면 만들기</title>
      <link>https://cliearl.github.io/posts/android/viewpager-swipe/</link>
      <pubDate>Sat, 17 Apr 2021 18:38:46 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/viewpager-swipe/</guid>
      <description>이번 포스팅에서는 ViewPager를 써서 화면을 좌우로 스와이프할 수 있는 앱을 만들어 보겠습니다.
ViewPager는 페이지를 만들어놓고 유저가 좌우로 스와이프 함으로써 각 페이지를 전환할 수 있게 하는 모듈입니다. 예를들어 페이지 1,2,3을 준비하고 이 페이지들을 ViewPager 어댑터에 전달합니다. 어댑터는 페이지를 순서대로 배열하고 페이지 2를 표시합니다. 페이지 1과 3은 화면 바깥의 좌우로 배치한 뒤 스와이프를 하면 현재 페이지를 밀어내고 화면 밖에서 대기하는 페이지가 ViewPager 화면으로 들어오게 됩니다.
화면 구성 우선은 화면을 구성하겠습니다. 화면에는 현재 어떤 페이지인지를 보여주는 인디케이터를 설치하고 나머지 영역을 ViewPager로 지정합니다.</description>
    </item>
    
    <item>
      <title>findViewById 대신 View Binding 사용하기</title>
      <link>https://cliearl.github.io/posts/android/apply-viewbinding/</link>
      <pubDate>Sat, 17 Apr 2021 18:38:23 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/apply-viewbinding/</guid>
      <description>&lt;p&gt;이번 포스팅에서는 View Binding을 사용하는 법에 대해 알아보도록 하겠습니다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>앱에서 ActionBar, StatusBar 감추기</title>
      <link>https://cliearl.github.io/posts/android/hide-titlebar/</link>
      <pubDate>Fri, 16 Apr 2021 20:05:22 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/hide-titlebar/</guid>
      <description>이번 포스팅에서는 앱에 표시되는 ActionBar와 StatusBar를 감추는 법에 대해 알아보도록 하겠습니다.
화면에 보시면 타이틀이 표시되는 창을 TitleBar 혹은 ActionBar라고 합니다. StatusBar는 화면 맨 위에 배터리나 와이파이 연결상태등을 보여주는 부분을 가리킵니다. 이 ActionBar와 StatusBar는 디자인적으로 필요가 없을 경우 표시되지 않게 할 수 있는데요, 그 방법을 알아보겠습니다.
ActionBar 삭제 ActionBar 표시를 없애는 방법은 몇가지가 있습니다. 우선은 테마를 이용하는 방법입니다. res-&amp;gt;value-&amp;gt;theme.xml 파일을 열어 상속받도록 parent에 설정한 테마 중 NoActionBar가 붙은 테마를 사용하면 액션바가 표시되지 않게 됩니다.</description>
    </item>
    
    <item>
      <title>안드로이드 앱에서 음악 재생하기</title>
      <link>https://cliearl.github.io/posts/android/use-mediaplayer/</link>
      <pubDate>Thu, 15 Apr 2021 18:37:51 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/use-mediaplayer/</guid>
      <description>이번 포스팅에서는 앱에서 음악을 재생하는 방법에 대해 알아보도록 하겠습니다.
여기서는 MediaPlayer 클래스를 이용하여 음악을 재생하는 앱을 만들어 볼 건데요, 플레이버튼을 누르면 음악이 재생되고, 포즈를 누르면 일시정지가 되며, 다시 누르면 음악이 시작이 되게 됩니다. 그리고 스탑버튼을 누르면 정지가 되고 플레이버튼을 누르면 음악이 처음부터 시작되게 됩니다.
음악파일 단순재생 프로젝트에서 실행할 음악파일은 res -&amp;gt; raw 폴더 안에 복사해줍니다. 저는 다음 사이트에서 다운받은 파일을 사용하겠습니다. https://maoudamashii.jokersounds.com/archives2/bgm_maoudamashii_orchestra02.html
그러면 메인 액티비티에서 재생을 해보겠습니다
class MainActivity : AppCompatActivity() { private var mediaPlayer: MediaPlayer?</description>
    </item>
    
    <item>
      <title>앱 빌드속도 빠르게 하기</title>
      <link>https://cliearl.github.io/posts/android/fast-build/</link>
      <pubDate>Mon, 12 Apr 2021 19:35:46 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/fast-build/</guid>
      <description>이번 포스팅에서는 안드로이드 스튜디오에서 앱의 빌드속도를 빠르게 할 수 있는 여러가지 설정들에 대해 알아보도록 하겠습니다.
구글에서는 빌드속도를 최적화하는 여러가지 방법들에 대해 정리하여 소개했고 유튜브에서도 공개하고 있습니다. 오늘은 이 내용을 정리해 보겠습니다.
최신버전의 Gradle 사용 우선은 최신버전의 Gradle을 사용하는게 중요합니다. 모듈에 대한 build.gradle 파일에서 사용하는 코틀린의 버전이나, 그래들 플러그인의 버전을 정할 수 있게 되어 있습니다. 버전내역을 보시면 플러그인이 업데이트 될 수록 빌드를 빠르게 하는 기술이 적용되기 때문에, 버전을 항상 최신버전으로 유지하는게 중요합니다.</description>
    </item>
    
    <item>
      <title>Glide로 앱에서 움직이는 GIF 표시하기</title>
      <link>https://cliearl.github.io/posts/android/imageplugin-glide/</link>
      <pubDate>Thu, 08 Apr 2021 20:40:50 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/imageplugin-glide/</guid>
      <description>이번 포스팅에서는 앱에서 움직이는 GIF를 표시하는 법에 대해 알아보도록 하겠습니다.
안드로이드에서 이미지를 보여줄때는 화면을 구성하는 xml파일에 ImageView를 올리고 그 이미지뷰에 그림파일을 삽입해주면 됩니다. 이 때 그림파일은 drawable 폴더에 넣어주며 파일이름은 영문소문자 + 언더바로만 구성합니다.
ImageView로 이미지 표시 이미지를 표시하기 위해서는 다음과 같이 imageView의 setImageResource 메소드를 사용합니다. 그런데 이 때 크기가 너무 큰 그림파일은 넣을 수 없고, 움직이는 GIF는 첫번째 프레임만 표시된다는 문제가 있습니다.
imageView.setImageResource(R.drawable.sample00) Glide 사용 하지만 Glide라는 외부 라이브러리를 사용하면 이런 문제를 해결할 수 있습니다.</description>
    </item>
    
    <item>
      <title>Date and Time 다루기</title>
      <link>https://cliearl.github.io/posts/android/date-and-time/</link>
      <pubDate>Wed, 07 Apr 2021 20:32:54 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/date-and-time/</guid>
      <description>이번 포스팅에서는 날짜와 시간을 다루는 법에 대해 알아보도록 하겠습니다.
안드로이드의 날짜 라이브러리 날짜를 다루기 위해서는 일반적으로 날짜객체를 만들고 그 날짜객체를 자기가 필요로 하는 양식에 맞춰서 표현하도록 하면 되는데요, 이때 사용할 수 있는 날짜 패턴은 다음 표와 같이 여러가지가 있습니다.
   Date and Time Pattern Result     &amp;ldquo;yyyy.MM.dd G &amp;lsquo;at&amp;rsquo; HH:mm:ss z&amp;rdquo; 2001.07.04 AD at 12:08:56 PDT   &amp;ldquo;EEE, MMM d, &amp;lsquo;&amp;lsquo;yy&amp;rdquo; Wed, Jul 4, &amp;lsquo;01   &amp;ldquo;h:mm a&amp;rdquo; 12:08 PM   &amp;ldquo;hh &amp;lsquo;o&#39;&amp;lsquo;clock&amp;rsquo; a, zzzz&amp;rdquo; 12 o&amp;rsquo;clock PM, Pacific Daylight Time   &amp;ldquo;K:mm a, z&amp;rdquo; 0:08 PM, PDT   &amp;ldquo;yyyyy.</description>
    </item>
    
    <item>
      <title>Data class 이해하고 RecyclerView에서 사용하기</title>
      <link>https://cliearl.github.io/posts/android/dataclass-recyclerview/</link>
      <pubDate>Tue, 06 Apr 2021 21:34:00 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/dataclass-recyclerview/</guid>
      <description>이번 포스팅에서는 Data class를 사용하는 법에 대해 알아보도록 하겠습니다.
Data class의 특징 toString 코틀린에서 클래스를 만들 때는 자바의 클래스 스펙에 따라서 toString, equals, hashCode라는 메소드를 구현해주어야 합니다. 우선 Person이라는 클래스를 만들고 그 인스턴스를 출력해 보겠습니다. 그러면 Person@랜덤 이라는 값이 출력이 되게 됩니다.
class Person(var name: String, var age: Int, var sex: String) val person1 = Person(&amp;#34;Alice&amp;#34;, 20, &amp;#34;Female&amp;#34;) println(person1) // 출력값 org.jetbrains.kotlin.idea.scratch.generated.ScratchFileRunnerGenerated$ScratchFileRunnerGenerated$Person@b6587368 이제 클래스의 toString을 다음과 같이 오버라이드 해주면 랜덤값이 아니라 클래스가 가진 프로퍼티값을 보여주게 됩니다.</description>
    </item>
    
    <item>
      <title>프로젝트의 빌드넘버 자동증가 시키기</title>
      <link>https://cliearl.github.io/posts/android/autoset-buildnumber/</link>
      <pubDate>Tue, 06 Apr 2021 19:24:59 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/autoset-buildnumber/</guid>
      <description>이번 포스팅에서는 프로젝트의 빌드넘버를 자동으로 증가시키는 법에 대해 알아보도록 하겠습니다.
버전넘버와 빌드넘버 버전넘버 소프트웨어의 기능이 변할때마다 그것을 구분하기 위해서 버전넘버를 사용하는데요, 일반적인 규칙은 1.0.0 과 같이 세자리로 결정을 합니다.
첫째자리는 뒤로 되돌릴 수 없는 수준의 큰 변경이 있을때, 둘째자리는 여러가지 새로운 기능이 추가되었을 때 증가를 시키고, 셋째자리는 기능이 추가되지는 않지만 버그가 수정되었을 때 증가를 시킵니다.
그래서 첫째자리는 메이저 버전, 둘째자리는 마이너 버전, 셋째자리는 패치버전이라고 하는 이름이 있습니다.
다만 이것은 꼭 지켜야 하는 규칙은 아니고, 날짜를 버전넘버로 사용하는 소프트웨어도 있습니다.</description>
    </item>
    
    <item>
      <title>ProgressDialog로 Thread와 Handler 이해하기</title>
      <link>https://cliearl.github.io/posts/android/progressdialog-thread/</link>
      <pubDate>Mon, 05 Apr 2021 22:20:49 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/progressdialog-thread/</guid>
      <description>이번 포스팅에서는 ProgressDialog와 Thread 사용법에 대해 알아보도록 하겠습니다.
ProgressDialog란 ProgressDialog는 안드로이드가 어떤 작업을 진행할때 그 작업의 진행상황과 부가적인 문장을 팝업창으로 보여주는 모듈입니다. 시간이 걸리는 파일 다운로드나 복사를 수행할 때 이런창을 띄워주면 기다리는데 유저의 거부감을 줄일 수 있습니다.
ProgressDialog는 다이얼로그가 표시되는 동안 유저가 다른 조작을 못하게 된다는 이유로 Android 8.0(API level 26)부터는 deprecated 되고 대신 ProgressBar를 사용하도록 권장하고 있습니다.
&amp;hellip;만, ProgressDialog는 Thread를 설명하는데 좋은 예제이기 때문에 여기서는 ProgressDialog를 구현하면서 Thread에 대해 이해해 보도록 하겠습니다</description>
    </item>
    
    <item>
      <title>ktlint로 코틀린 코딩 컨벤션 검토하기</title>
      <link>https://cliearl.github.io/posts/android/use-ktlint/</link>
      <pubDate>Sun, 21 Mar 2021 18:07:38 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/use-ktlint/</guid>
      <description>이번 포스트에서는 작성된 코드의 교열을 보는 방법에 대해 알아보도록 하겠습니다.
들어가기 우리가 작성하는 코드는 기본적으로는 컴퓨터에게 명령을 내리기 위한 것이고 그 명령은 각 언어의 문법에 따라 작성되어져야 합니다.
코틀린에서 상수 두 개를 만들고 그 상수를 더하는 명령은 다음과 같이 쓸 수 있습니다.
val a = 3 val b = 4 val c = a + b println(c) 자 그럼 이번엔 코드 안에서 띄어쓰기의 방식을 다르게 해보겠습니다.
val a= 3 val b = 4 val c= a+ b println(c) 각 줄마다 띄어쓰기의 방식이 다르다고 해도 컴퓨터는 코드를 문제없이 컴파일 할 수 있습니다.</description>
    </item>
    
  </channel>
</rss>
