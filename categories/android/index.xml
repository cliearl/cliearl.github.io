<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>android on 냉동코더의 기술블로그</title>
    <link>https://cliearl.github.io/categories/android/</link>
    <description>Recent content in android on 냉동코더의 기술블로그</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 23 Oct 2021 10:58:16 +0900</lastBuildDate><atom:link href="https://cliearl.github.io/categories/android/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>안드로이드의 HTTP 통신 라이브러리 고찰</title>
      <link>https://cliearl.github.io/posts/android/android-http-library-review/</link>
      <pubDate>Sat, 23 Oct 2021 10:58:16 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/android-http-library-review/</guid>
      <description>이번 포스팅에서는 안드로이드의 HTTP 통신에 대해 알아보도록 하겠습니다.
안드로이드에서의 통신 앱에서 가장 많이 수행하는 처리중 하나는 서버에 데이터를 요청하고 받아온 데이터를 단말-다시말해 클라이언트의 화면에 표시하는 것입니다. 이 때 클라이언트와 서버가 통신하는 방식은 크게 소켓연결과 HTTP연결 두 가지로 나눌 수 있습니다.
소켓 연결 소켓은 네트워크 상의 두 프로그램 사이에서 일어나는 양방향 통신중 한 쪽의 엔드 포인트를 의미합니다. 여기서 엔드포인트란 IP와 포트의 조합을 뜻합니다.
소켓 연결방식에서는 클라이언트와 서버가 특정 포트를 통해 연결을 계속 유지하고 있기 때문에 실시간으로 양방향 통신을 할 수 있는데요, 주로 동영상 스트리밍이나, 온라인 게임등에서 사용되는 연결방식입니다.</description>
    </item>
    
    <item>
      <title>내가 Android Studio에서 사용하는 Plugins</title>
      <link>https://cliearl.github.io/posts/android/android-studio-plugins/</link>
      <pubDate>Sun, 10 Oct 2021 09:13:13 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/android-studio-plugins/</guid>
      <description>이번 포스팅에서는 제가 즐겨 사용하는 Android Studio의 플러그인을 소개해 보도록 하겠습니다.
ADB Wi-Fi  https://plugins.jetbrains.com/plugin/14969-adb-wi-fi 개발장비와 모바일기기는 Android Debug Bridge(ADB)를 통해 USB나 Wifi로 연결할 수 있는데요, ADB Wi-Fi는 Wifi를 통한 ADB연결을 간편하게 수행해줍니다  CodeGlance  https://plugins.jetbrains.com/plugin/7275-codeglance Sublime text처럼 에디터 오른쪽에 코드 미니맵을 표시해줍니다  CPU Usage Indicator  https://plugins.jetbrains.com/plugin/8580-cpu-usage-indicator 스테이터스바에 IDE와 전체 시스템의 CPU 사용량을 표시합니다  CSV  https://plugins.jetbrains.com/plugin/10037-csv CSV 파일을 테이블 형식으로 열람하고 편집할 수 있게 해 줍니다  GitToolBox  https://plugins.</description>
    </item>
    
    <item>
      <title>SQLite 이해하고 SQLiteOpenHelper로 CRUD 구현하기</title>
      <link>https://cliearl.github.io/posts/android/implement-crud-with-sqliteopenhelper/</link>
      <pubDate>Sat, 25 Sep 2021 17:33:35 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/implement-crud-with-sqliteopenhelper/</guid>
      <description>이번 포스팅에서는 두 파트에 걸쳐 안드로이드에서 SQLite를 다루는 법에 대해 알아보도록 하겠습니다.
Part A. 데이터베이스 관계형 데이터베이스 여러 사람들의 연락처 데이터는 다음과 같이 테이블 구조로 관리할 수 있습니다. 이런 식으로 통일된 규칙의 데이터를 관리할 수 있는 테이블을 데이터베이스라고 합니다.
   순서 이름 전화번호 이메일 주소     0 김철수 010-1111-1111 kim@abc.com 서울   1 이영희 010-2222-2222 lee@abc.com 서울   2 박모모 010-3333-3333 park@abc.com 인천    이 때 1행 2열의 이름을 Key라고 하고 2행 2열의 김철수를 Value라고 합니다.</description>
    </item>
    
    <item>
      <title>알기쉬운 Singleton Pattern</title>
      <link>https://cliearl.github.io/posts/android/understanding-singleton-pattern/</link>
      <pubDate>Sun, 05 Sep 2021 15:59:57 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/understanding-singleton-pattern/</guid>
      <description>이번 포스팅에서는 싱글톤 패턴에 대해 알아보도록 하겠습니다.
Singleton 이란 싱글톤(Singleton)은 소프트웨어 디자인패턴의 한 종류로, 프로그램 안에서 클래스의 인스턴스가 단 하나만 존재해야 할 때 사용합니다. 예를들어 데이터베이스를 변경할 수 있는 DBHandler 클래스의 인스턴스가 두개 있어서 동시에 데이터베이스에 접근한다면 문제가 생기겠죠.
자바에서는 일반적으로 다음과 같은 방식으로 싱글톤을 구현할 수 있습니다. private를 이용해 외부에서 생성자에 접근하지 못하도록 막고 getInstance를 통해야 인스턴스를 만들 수 있게 합니다. 이 때 스태틱 instance를 확인해서 인스턴스가 없으면 객체를 새로 만들고, 있다면 그대로 반환해주는 구조를 가집니다.</description>
    </item>
    
    <item>
      <title>Android Studio Arctic Fox와 JDK 11의 도입</title>
      <link>https://cliearl.github.io/posts/android/android-gradle-java-11/</link>
      <pubDate>Sun, 15 Aug 2021 14:23:23 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/android-gradle-java-11/</guid>
      <description>이번 포스팅에서는 Android Studio Arctic Fox와 JDK 11의 도입에 관한 내용을 다루어보도록 하겠습니다.
Android Gradle 7.0.0 도입  
2021년 7월 말에 Android Studio의 버전이 Arctic Fox|2020.3.1 로 올라갔습니다. 그 과정에서 Android Gradle plugin의 버전도 4.2.0에서 7.0.0으로 올라갔는데요, Android Gradle 7.0.0의 사양은 다음과 같습니다.
    Default Version     Gradle 7.0.2   SDK Build Tools 30.0.2   NDK 21.4.7075529   JDK 11    이번 플러그인의 가장 큰 변화중 하나는 디폴트 JDK 버전을 1.</description>
    </item>
    
    <item>
      <title>jsoup으로 로또 홈페이지의 당첨번호 파싱하기</title>
      <link>https://cliearl.github.io/posts/android/jsoup-lotto-checker/</link>
      <pubDate>Sat, 14 Aug 2021 11:03:31 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/jsoup-lotto-checker/</guid>
      <description>이번 포스팅에서는 jsoup을 이용해서 html을 파싱하는 법에 대해 알아보도록 하겠습니다.
jsoup이란 jsoup은 html을 파싱하기 위해 만들어진 오픈소스 자바 라이브러리입니다. 웹페이지를 HTML5 DOM으로 변환하여 요소들을 간편하게 추출할 수 있습니다. 자바 라이브러리이니만큼 코틀린에서도 자유롭게 사용이 가능하지요.
jsoup에는 여러가지 클래스가 있는데 그 중 제 생각에 중요한 것들만 정리하면 다음과 같습니다.
   클래스 설명     Document jsoup로 얻어온 html 문서   Element 데이터를 추출할 수 있는 개별 html 요소   Elements Iterable한 Element 집합의 자료형   Connection http 접속에 관련한 메소드를 가지는 클래스    파싱할 html 구조 확인 그럼 코루틴으로 로또번호 당첨 확인하기 강의에서 만들었던 코루틴으로 로또번호 당첨을 확인하는 앱에 jsoup을 적용해보도록 하겠습니다.</description>
    </item>
    
    <item>
      <title>DiffUtil과 ListAdapter 이해하고 RecyclerView에 적용하기</title>
      <link>https://cliearl.github.io/posts/android/recyclerview-listadapter/</link>
      <pubDate>Sat, 31 Jul 2021 21:22:17 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/recyclerview-listadapter/</guid>
      <description>이번 포스팅에서는 RecyclerView에 ListAdapter를 적용하는 법에 대해 알아보도록 하겠습니다.
들어가기 리사이클러뷰의 데이터가 변하면 리사이클러뷰 어댑터가 제공하는 notifyItem 메소드를 사용해서 뷰홀더 내용을 갱신할 수 있습니다.
notifyItemChanged(int) notifyItemInserted(int) notifyItemRemoved(int) notifyItemRangeChanged(int, int) notifyItemRangeInserted(int, int) notifyItemRangeRemoved(int, int) 그런데 데이터가 변경되는 방식을 확인하고 그때마다 이렇게 notify를 일일이 해 주는것은 번거롭기도 하고, 또 사용하기에 따라서는 갱신이 필요없는 뷰홀더를 같이 갱신하는 불필요한 작업이 생길수도 있습니다.
DiffUtil DiffUtil은 두 데이터셋을 받아서 그 차이를 계산해주는 클래스입니다. DiffUtil을 사용하면 두 데이터 셋을 비교한 뒤 그중 변한부분만을 파악하여 리사이클러뷰에 반영할 수 있습니다.</description>
    </item>
    
    <item>
      <title>2021년 7월 현재, minSdkVersion 몇으로 해야 할까?</title>
      <link>https://cliearl.github.io/posts/android/how-much-minsdkversion/</link>
      <pubDate>Mon, 19 Jul 2021 18:39:10 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/how-much-minsdkversion/</guid>
      <description>&lt;p&gt;minSdkVersion 과연 몇으로 해야할지 정해드립니다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>코루틴으로 로또번호 당첨 확인하기</title>
      <link>https://cliearl.github.io/posts/android/lotto-checker/</link>
      <pubDate>Sat, 17 Jul 2021 16:01:01 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/lotto-checker/</guid>
      <description>이번 포스팅에서는 코루틴을 사용해서 로또번호의 당첨을 확인하는 법에 대해 알아보도록 하겠습니다.
당첨번호 조회하기 이전에 로또번호 생성기 만들기강의에서 로또번호를 생성하는 앱을 만들어보았는데요, 여기서는 이 앱에 코루틴을 이용해서 당첨여부를 확인하는 기능을 추가하도록 하겠습니다. 코루틴에 대한 이론설명은 알기쉬운 코루틴 이론 강의를 참조하시기 바랍니다.
금주의 로또 당첨번호는 동행복권 홈페이지에서 확인할 수 있습니다. 다른 회차의 당첨번호는 홈페이지의 회차별 당첨번호 페이지에서 확인할 수 있게 되어 있습니다.
그런데 이렇게 홈페이지에 접속하지 않고도 당첨번호는 API로 조회할 수 있습니다. 다음 주소의 &amp;ldquo;회차&amp;quot;라고 되어 있는 부분에 확인하고 싶은 회차의 숫자를 넣으시면 됩니다.</description>
    </item>
    
    <item>
      <title>알기쉬운 코루틴 이론</title>
      <link>https://cliearl.github.io/posts/android/coroutine-principle/</link>
      <pubDate>Mon, 28 Jun 2021 22:01:50 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/coroutine-principle/</guid>
      <description>&lt;p&gt;이번 포스팅에서는 코틀린의 코루틴(Coroutine)에 대해 알아보도록 하겠습니다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>로또번호 생성기 만들기</title>
      <link>https://cliearl.github.io/posts/android/lotto-generator/</link>
      <pubDate>Sun, 20 Jun 2021 21:10:32 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/lotto-generator/</guid>
      <description>&lt;p&gt;이번 포스팅에서는 로또번호를 생성하는 간단한 앱을 만들어보도록 하겠습니다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>단말의 인터넷 연결상태 체크하기</title>
      <link>https://cliearl.github.io/posts/android/check-connection/</link>
      <pubDate>Sun, 13 Jun 2021 21:51:49 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/check-connection/</guid>
      <description>&lt;p&gt;이번 포스팅에서는 단말의 인터넷 연결상태를 체크하는 법에 대해 알아보도록 하겠습니다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Assets 폴더에서 로딩한 json 파일 Recyclerview에 표시하기</title>
      <link>https://cliearl.github.io/posts/android/assets-json-recycler/</link>
      <pubDate>Wed, 05 May 2021 23:05:14 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/assets-json-recycler/</guid>
      <description>&lt;p&gt;이번 포스팅에서는 Assets 폴더를 사용하는 법에 대해 알아보겠습니다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ViewPager2와 TabLayout을 이용해 스와이프 되는 화면 구현하기</title>
      <link>https://cliearl.github.io/posts/android/viewpager2-tablayout/</link>
      <pubDate>Sun, 02 May 2021 22:44:04 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/viewpager2-tablayout/</guid>
      <description>이번 포스팅에서는 ViewPager2와 TabLayout을 이용한 디자인을 구현해 보도록 하겠습니다.
ViewPager2를 사용하는 이유나 장점에 대해서는 ViewPager1 프로젝트를 ViewPager2 프로젝트로 변환하기 포스팅에서 다루었으니 그 내용을 참조해 주시기 바랍니다.
플러그인 추가 우선은 뷰바인딩 사용설정 및 ViewPager2 플러그인을 추가합니다.
// 뷰바인딩 사용준비 android { buildFeatures.viewBinding true } // 뷰페이저2 라이브러리 추가 dependencies { implementation &amp;#39;androidx.viewpager2:viewpager2:1.0.0&amp;#39; } Fragment의 레이아웃 작성 다음은 new -&amp;gt; fragment 를 선택하여 테스트용으로 사용할 프래그먼트를 만들어줍니다. 텍스트를 화면 중간에 표시하기 위해 코드를 약간 변경합니다.</description>
    </item>
    
    <item>
      <title>스플래쉬 스크린 설정하기</title>
      <link>https://cliearl.github.io/posts/android/splashscreen/</link>
      <pubDate>Wed, 28 Apr 2021 21:46:44 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/splashscreen/</guid>
      <description>이번 포스팅에서는 스플래시 스크린을 만드는 법에 대해 알아보도록 하겠습니다.
아이콘을 선택하고 앱이 구동되서 메인화면을 보여주기 전까지 로딩 시간이 필요한데 그 시간동안 보여주는 화면을 스플래시 스크린이라고 합니다. 이때 앱 아이콘과 동일한 이미지로 스플래시 스크린을 설정하면 아이콘이 튀어 나오는듯한 효과를 볼 수 있습니다.
코딩 타임 이번 앱은 앱 아이콘을 설정하는 강의에서 만들었던 프로젝트를 변경하여 만들어 보도록 하겠습니다.
우선은 스플래시 스크린에 표시할 이미지를 선정해야 하는데, 저는 이전에 앱 아이콘으로 사용했던 이미지를 그대로 사용하도록 하겠습니다.</description>
    </item>
    
    <item>
      <title>App Icon 설정하기</title>
      <link>https://cliearl.github.io/posts/android/appicon/</link>
      <pubDate>Wed, 28 Apr 2021 21:46:35 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/appicon/</guid>
      <description>이번 포스팅에서는 앱에 아이콘을 설정하는 방법에 대해 알아보도록 하겠습니다.
Legacy Icon과 Adaptive Icon 안드로이드 앱에서는 현재 두 가지 종류의 아이콘을 사용할 수 있습니다. 하나는 Legacy Icon이고 또 하나는 Adaptive Icon입니다.
Adaptive Icon은 다양화된 기기의 해상도와 UI 디자인에 대응하기 위해 제안된 규격으로, 안드로이드는 iOS와 달리 여러 제조사에서 여러 규격의 기기를 만들기 때문에 해상도에 많은 차이가 있고, 회사마다 고유의 UI 디자인을 사용하기 때문에 앱 아이콘의 형태도 조금씩 달라지게 됩니다.
그래서 구글에서는 어댑티브 아이콘이라는 규격을 제안했습니다.</description>
    </item>
    
    <item>
      <title>ProgressBar로 AsyncTask 이해하기</title>
      <link>https://cliearl.github.io/posts/android/progressbar-asynctask/</link>
      <pubDate>Sun, 25 Apr 2021 15:35:18 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/progressbar-asynctask/</guid>
      <description>이번 포스팅에서는 ProgressBar와 AsyncTask의 사용방법에 대해 알아보도록 하겠습니다.
들어가기 ProgressBar는 안드로이드가 어떤 작업을 진행할때 그 작업의 진행상황을 보여주는 모듈입니다. 시간이 걸리는 처리가 필요할 때 표시해주면 기다리는 유저의 거부감을 줄일 수 있습니다. 이 기능은 기존에는 ProgressDialog를 이용해서 구현했는데 다이얼로그가 표시될 때 유저의 조작을 제한한다는 문제가 있어 deprecated 되고 ProgressBar로 대체되는 추세입니다.
메인 스레드의 관점에서 보면 ProgressBar는 처리에 긴 시간이 걸리기 때문에 메인 스레드와는 별개의 스레드에서 처리를 수행해야 할 필요가 있습니다. 별개의 스레드에서 처리를 수행하는데는 여러가지 방법이 있을 수 있는데 여기서는 AsyncTask 클래스를 이용해서 ProgressBar를 구현해 보도록 하겠습니다.</description>
    </item>
    
    <item>
      <title>Google Admob으로 보상형 광고 표시하기 </title>
      <link>https://cliearl.github.io/posts/android/gadmob-rewarded/</link>
      <pubDate>Sat, 24 Apr 2021 21:48:55 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/gadmob-rewarded/</guid>
      <description>&lt;p&gt;이번 포스팅에서는 보상형 광고를 표시하는 법에 대해 알아보도록 하겠습니다. 보상형 광고란 광고를 본 댓가로 어떤 아이템이나 보상을 주는 형태의 광고를 말합니다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Google Admob으로 전면광고 표시하기</title>
      <link>https://cliearl.github.io/posts/android/gadmob-interstitial/</link>
      <pubDate>Thu, 22 Apr 2021 20:36:18 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/gadmob-interstitial/</guid>
      <description>&lt;p&gt;이번 포스팅에서는 구글 애드몹을 이용해서 전면광고를 표시하는 법에 대해 알아보도록 하겠습니다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SharedPreferences를 json 포맷으로 관리하기</title>
      <link>https://cliearl.github.io/posts/android/sharedpreferneces-gson/</link>
      <pubDate>Thu, 22 Apr 2021 20:33:39 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/sharedpreferneces-gson/</guid>
      <description>이번 포스팅에서는 SharedPreferences에 복잡한 형태의 데이터를 json 포맷으로 저장하고 불러오는 법에 대해 알아보도록 하겠습니다.
SharedPreferences는 Key-Value 형태로 이루어진 딕셔너리를 저장하도록 설계된 저장장소인데요, 이 Value 부분에 json으로 구성된 긴 형태의 데이터를 저장함으로써 복잡한 형태의 데이터도 저장할 수가 있습니다.
이 때 앱 안의 데이터를 json으로 Serialize하고 다시 복원하는 Deserialize를 편하게 실행하게 해 주는 Gson이라는 라이브러리가 있습니다. 이번 포스팅에서는 이 라이브러리를 활용하겠습니다.
포스팅에서는 Data class 이해하고 RecyclerView에서 사용하기 강의에서 만들었던 RecyclerView 프로젝트를 수정하면서 구현해보겠습니다.</description>
    </item>
    
    <item>
      <title>Google Admob으로 배너광고 표시하기</title>
      <link>https://cliearl.github.io/posts/android/gadmob-banner/</link>
      <pubDate>Wed, 21 Apr 2021 22:17:58 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/gadmob-banner/</guid>
      <description>&lt;p&gt;이번 포스팅에서는 구글 애드몹 라이브러리를 이용해서 앱에 배너광고를 표시하는 법에 대해 알아보도록 하겠습니다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SharedPreferences로 앱 설정값 저장하고 불러오기</title>
      <link>https://cliearl.github.io/posts/android/sharedpreferences-basic/</link>
      <pubDate>Tue, 20 Apr 2021 21:35:43 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/sharedpreferences-basic/</guid>
      <description>이번 포스팅에서는 SharedPreferences를 사용하는 법에 대해 알아보도록 하겠습니다.
데이터를 앱에 저장하는 방법 데이터를 앱에 저장하는 방법에는 크게 세가지가 있습니다.
 파일 I/O (내부 또는 외부 저장소)  접근 권한을 획득하고 파일을 열었다 닫았다 하는 수고가 필요함   관계형 데이터베이스  SQLite 등을 이용해 복잡한 관계형 데이터를 저장할 수 있음 간단한 데이터를 저장할거라면 구축과 관리에 많은 시간과 노려이 요구됨   SharedPreference  Key/Value 형태로 이용함 내부적으로는 XML 파일로 저장됨 파일을 열고 닫을 필요 없이 핸들러를 만들어서 간편하게 사용가능함    SharedPreferences는 보통 복잡한 데이터를 기록하기보다는, 게임의 환경설정이라든지 그런 단순한 내용을 저장하는데 적절한 저장공간이라고 생각하면 됩니다.</description>
    </item>
    
    <item>
      <title>RecyclerView를 Swipe, Drag, Touch하기</title>
      <link>https://cliearl.github.io/posts/android/recyclerview-touch/</link>
      <pubDate>Sun, 18 Apr 2021 22:40:04 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/recyclerview-touch/</guid>
      <description>이번 포스팅에서는 RecyclerView에 Swipe, Drag, Touch 동작을 연결하는 법에 대해 알아보도록 하겠습니다.
이번에 만들어볼 앱에서는 뷰홀더를 스와이프하면 삭제가 되고, 잡고 끌면 위아래로 뷰홀더를 이동할 수 있으며, 뷰홀더를 터치하면 그 내용이 변하는 동작을 수행하도록 하겠습니다.
여기서는 제가 RecyclerView에 View Binding 적용하기 강의에서 만들었던 리사이클러뷰 앱을 수정하는 방식으로 구현해보겠습니다.
리팩토링 뷰바인딩은 다음과 같이 사용하도록 변경합니다.
android { buildFeatures.viewBinding true } 메인액티비티에서 만들어주던 dataSet은 초기화시 데이터를 바로 입력하도록 하고 리사이클러뷰 어댑터 안쪽으로 이동시키고 받아오는 파라미터를 삭제합니다.</description>
    </item>
    
    <item>
      <title>앱에서 RecyclerView 사용하기</title>
      <link>https://cliearl.github.io/posts/android/recyclerview-implement/</link>
      <pubDate>Sat, 17 Apr 2021 22:43:43 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/recyclerview-implement/</guid>
      <description>이번 포스팅에서는 리사이클러뷰를 사용하는 법에 대해 알아보도록 하겠습니다.
리사이클러뷰의 특징 리사이클러뷰는 화면에 리스트 형식의 데이터를 표시하기 위해서 사용하는 모듈입니다. 보통 화면에 리스트뷰를 표시할수 있게 하는 리스트뷰는 예를들어 데이터가 10개 있을 경우 데이터를 표시하기 위한 뷰홀더가 10개 필요합니다. 그러나 리사이클러뷰는 뷰홀더를 6개만 만들고 화면에는 5개를 표시한 후 화면 바깥으로 1번 뷰홀더가 빠져나가면 7번 뷰홀더로 변경해서 재사용합니다. 그래서 자원을 더 아낄 수 있게 되는 것이죠.
또 데이터는 리사이클러뷰 어댑터를 통해 뷰홀더에 들어가게 되는데 뷰홀더에 데이터 1을 넣어서 표현했을 경우, 뷰홀더는 그대로 놔두고 데이터 2를 넣는 식으로 뷰홀더를 재활용해서 사용할 수 있습니다.</description>
    </item>
    
    <item>
      <title>RecyclerView에 View Binding 적용하기</title>
      <link>https://cliearl.github.io/posts/android/viewbinding-recyclerview/</link>
      <pubDate>Sat, 17 Apr 2021 22:43:04 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/viewbinding-recyclerview/</guid>
      <description>이번 포스팅에서는 RecyclerView에 View Binding을 적용하는 법에 대해 알아보도록 하겠습니다.
View Binding을 사용해야 하는 이유나 그 장점에 대해서는 findViewById 대신 View Binding 사용하기 포스팅과 유튜브 강의를 참조하시고 이번 포스팅에선 변환하는 방법에 대해서만 설명하도록 하겠습니다. 이번 포스팅에서 변환에 사용한 프로젝트는 앱에서 RecyclerView 사용하기 포스팅에서 작성한 것을 사용하도록 하겠습니다.
코드 작성 View Binding 활성화 우선은 gradle에서 kotlin-android-extensions 플러그인을 삭제하고 View Binding을 활성화합니다.
plugins { // id &amp;#39;kotlin-android-extensions&amp;#39; } android { buildFeatures.viewBinding true } 메인액티비티 수정 다음은 메인액티비티를 수정해줍니다.</description>
    </item>
    
    <item>
      <title>ViewPager1 프로젝트를 ViewPager2 프로젝트로 변환하기</title>
      <link>https://cliearl.github.io/posts/android/viewpager2-convert/</link>
      <pubDate>Sat, 17 Apr 2021 18:38:59 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/viewpager2-convert/</guid>
      <description>이번 포스팅에서는 프로젝트 안에 작성된 ViewPager1 모듈을 ViewPager2 모듈로 변환하는 법에 대해 알아보도록 하겠습니다.
안드로이드 라이브러리가 androidx로 바뀌는 과정에서 뷰페이저 라이브러리도 업그레이드 해달라는 요구가 꽤 많았습니다. 그래서 구글에서는 ViewPager2 라이브러리를 개발했습니다.
ViewPager2의 특징 구글에서 설명하는 ViewPager2의 [장점]((https://developer.android.com/training/animation/vp2-migration)은 다음과 같습니다.
 Vertical scrolling : 세로스크롤 Right-to-left support : 페이지를 오른쪽에서 왼쪽으로 정렬 modifiable Fragment collenctions : 프래그먼트의 변화를 동적으로 반영 가능 DiffUtil : 리사이클러뷰의 DiffUtil을 사용 가능 ViewPager1 라이브러리는 더이상 관리되지 않음  ViewPager2로 변환 기존에 작성했던 ViewPager1 프로젝트를 변환하는 방법으로 보여드리도록 하겠습니다.</description>
    </item>
    
    <item>
      <title>ViewPager를 써서 좌우로 스와이프되는 화면 만들기</title>
      <link>https://cliearl.github.io/posts/android/viewpager-swipe/</link>
      <pubDate>Sat, 17 Apr 2021 18:38:46 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/viewpager-swipe/</guid>
      <description>이번 포스팅에서는 ViewPager를 써서 화면을 좌우로 스와이프할 수 있는 앱을 만들어 보겠습니다.
뷰페이저는 페이지를 만들어놓고 유저가 좌우로 스와이프 함으로써 각 페이지를 전환할 수 있게 하는 모듈입니다. 예를들어 페이지 1,2,3을 준비하고 이 페이지들을 뷰페이저 어댑터에 전달합니다. 어댑터는 페이지를 순서대로 배열하고 페이지 2를 표시합니다. 페이지 1과 3은 화면 바깥의 좌우로 배치한 뒤 스와이프를 하면 현재 페이지를 밀어내고 화면 밖에서 대기하는 페이지가 뷰페이저 화면으로 들어오게 됩니다.
화면 구성 우선은 화면을 구성하겠습니다. 화면에는 현재 어떤 페이지인지를 보여주는 인디케이터를 설치하고 나머지 영역을 뷰페이저로 지정합니다.</description>
    </item>
    
    <item>
      <title>findViewById 대신 View Binding 사용하기</title>
      <link>https://cliearl.github.io/posts/android/apply-viewbinding/</link>
      <pubDate>Sat, 17 Apr 2021 18:38:23 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/apply-viewbinding/</guid>
      <description>&lt;p&gt;이번 포스팅에서는 View Binding을 사용하는 법에 대해 알아보도록 하겠습니다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>앱에서 타이틀바, 상태바 감추기</title>
      <link>https://cliearl.github.io/posts/android/hide-titlebar/</link>
      <pubDate>Fri, 16 Apr 2021 20:05:22 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/hide-titlebar/</guid>
      <description>이번 포스팅에서는 앱에 표시되는 타이틀바와 상태바를 감추는 법에 대해 알아보도록 하겠습니다.
화면에 보시면 타이틀이 표시되는 창을 타이틀바 혹은 액션바라고 합니다. 상태바는 화면 맨 위에 배터리나 와이파이 연결상태등을 보여주는 부분을 가리킵니다. 이 타이틀바와 상태바는 디자인적으로 필요가 없을 경우 표시되지 않게 할 수 있는데요, 그 방법을 알아보겠습니다.
타이틀바 삭제 타이틀바 표시를 없애는 방법은 몇가지가 있습니다. 우선은 테마를 이용하는 방법입니다. res-&amp;gt;value-&amp;gt;theme.xml 파일을 열어 상속받도록 parent에 설정한 테마 중 NoActionBar가 붙은 테마를 사용하면 액션바가 표시되지 않게 됩니다.</description>
    </item>
    
    <item>
      <title>안드로이드 앱에서 음악 재생하기</title>
      <link>https://cliearl.github.io/posts/android/use-mediaplayer/</link>
      <pubDate>Thu, 15 Apr 2021 18:37:51 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/use-mediaplayer/</guid>
      <description>이번 포스팅에서는 앱에서 음악을 재생하는 방법에 대해 알아보도록 하겠습니다.
플레이버튼을 누르면 음악이 재생되고, 포즈를 누르면 일시정지가 되고, 다시 누르면 음악이 시작이 되게 됩니다. 그리고 스탑버튼을 누르면 정지가 되고 플레이버튼을 누르면 음악이 처음부터 시작되는 앱을 만들어 보겠습니다.
음악파일 단순재생 프로젝트에서 실행할 음악파일은 res -&amp;gt; raw 폴더 안에 복사해줍니다. 저는 다음 사이트에서 다운받은 파일을 사용하겠습니다. https://maoudamashii.jokersounds.com/archives2/bgm_maoudamashii_orchestra02.html
그러면 메인 액티비티에서 재생을 해보겠습니다
class MainActivity : AppCompatActivity() { private var mediaPlayer: MediaPlayer? = null override fun onCreate(savedInstanceState: Bundle?</description>
    </item>
    
    <item>
      <title>앱 빌드속도 빠르게 하기</title>
      <link>https://cliearl.github.io/posts/android/fast-build/</link>
      <pubDate>Mon, 12 Apr 2021 19:35:46 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/fast-build/</guid>
      <description>&lt;p&gt;이번 포스팅에서는 안드로이드 스튜디오에서 앱의 빌드속도를 빠르게 할 수 있는 여러가지 설정들에 대해 알아보도록 하겠습니다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Glide로 앱에서 움직이는 GIF 표시하기</title>
      <link>https://cliearl.github.io/posts/android/imageplugin-glide/</link>
      <pubDate>Thu, 08 Apr 2021 20:40:50 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/imageplugin-glide/</guid>
      <description>이번 포스팅에서는 앱에서 움직이는 GIF를 표시하는 법에 대해 알아보도록 하겠습니다.
안드로이드에서 이미지를 보여줄때는 화면을 구성하는 xml파일에 ImageView를 올리고 그 이미지뷰에 그림파일을 삽입해주면 됩니다. 이 때 그림파일은 drawable 폴더에 넣어주며 파일이름은 영문소문자 + 언더바로만 구성합니다.
ImageView로 이미지 표시 이미지를 표시하기 위해서는 다음과 같이 imageView의 setImageResource 메소드를 사용합니다.
그런데 이 때 크기가 너무 큰 그림파일은 넣을 수 없고, 움직이는 GIF는 첫번째 프레임만 표시된다는 문제가 있습니다.
imageView.setImageResource(R.drawable.sample00) Glide 사용 하지만 Glide라는 외부 라이브러리를 사용하면 이런 문제를 해결할 수 있습니다.</description>
    </item>
    
    <item>
      <title>Date and Time 다루기</title>
      <link>https://cliearl.github.io/posts/android/date-and-time/</link>
      <pubDate>Wed, 07 Apr 2021 20:32:54 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/date-and-time/</guid>
      <description>&lt;p&gt;이번 포스팅에서는 날짜와 시간을 다루는 법에 대해 알아보도록 하겠습니다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Data class 이해하고 RecyclerView에서 사용하기</title>
      <link>https://cliearl.github.io/posts/android/dataclass-recyclerview/</link>
      <pubDate>Tue, 06 Apr 2021 21:34:00 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/dataclass-recyclerview/</guid>
      <description>이번 포스팅에서는 Data class를 사용하는 법에 대해 알아보도록 하겠습니다.
Data class의 특징 toString 코틀린에서 클래스를 만들 때는 자바의 클래스 스펙에 따라서 toString, equals, hashCode라는 메소드를 구현해주어야 합니다. 우선 Person이라는 클래스를 만들고 그 인스턴스를 출력해 보겠습니다. 그러면 Person@랜덤 이라는 값이 출력이 되게 됩니다.
class Person(var name: String, var age: Int, var sex: String) val person1 = Person(&amp;#34;Alice&amp;#34;, 20, &amp;#34;Female&amp;#34;) println(person1) // 출력값 org.jetbrains.kotlin.idea.scratch.generated.ScratchFileRunnerGenerated$ScratchFileRunnerGenerated$Person@b6587368 이제 클래스의 toString을 다음과 같이 오버라이드 해주면 랜덤값이 아니라 클래스가 가진 프로퍼티값을 보여주게 됩니다.</description>
    </item>
    
    <item>
      <title>프로젝트의 빌드넘버 자동증가 시키기</title>
      <link>https://cliearl.github.io/posts/android/autoset-buildnumber/</link>
      <pubDate>Tue, 06 Apr 2021 19:24:59 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/autoset-buildnumber/</guid>
      <description>&lt;p&gt;이번 포스팅에서는 프로젝트의 빌드넘버를 자동으로 증가시키는 법에 대해 알아보도록 하겠습니다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ProgressDialog로 Thread와 Handler 이해하기</title>
      <link>https://cliearl.github.io/posts/android/progressdialog-thread/</link>
      <pubDate>Mon, 05 Apr 2021 22:20:49 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/progressdialog-thread/</guid>
      <description>이번 포스팅에서는 ProgressDialog와 Thread 사용법에 대해 알아보도록 하겠습니다.
ProgressDialog란 ProgressDialog는 안드로이드가 어떤 작업을 진행할때 그 작업의 진행상황과 부가적인 문장을 팝업창으로 보여주는 모듈입니다. 시간이 걸리는 파일 다운로드나 복사를 수행할 때 이런창을 띄워주면 기다리는데 유저의 거부감을 줄일 수 있습니다.
 
ProgressDialog는 다이얼로그가 표시되는 동안 유저가 다른 조작을 못하게 된다는 이유로 Android 8.0(API level 26)부터는 deprecated 되고 대신 ProgressBar를 사용하도록 권장하고 있습니다.
&amp;hellip;만, ProgressDialog는 쓰레드를 설명하는데 좋은 예제이기 때문에 여기서는 ProgressDialog를 구현하면서 쓰레드에 대해 이해해 보도록 하겠습니다</description>
    </item>
    
    <item>
      <title>ktlint로 코틀린 코딩 컨벤션 검토하기</title>
      <link>https://cliearl.github.io/posts/android/use-ktlint/</link>
      <pubDate>Sun, 21 Mar 2021 18:07:38 +0900</pubDate>
      
      <guid>https://cliearl.github.io/posts/android/use-ktlint/</guid>
      <description>이번 포스트에서는 작성된 코드의 교열을 보는 방법에 대해 알아보도록 하겠습니다.
들어가기 우리가 작성하는 코드는 기본적으로는 컴퓨터에게 명령을 내리기 위한 것이고 그 명령은 각 언어의 문법에 따라 작성되어져야 합니다.
코틀린에서 상수 두 개를 만들고 그 상수를 더하는 명령은 다음과 같이 쓸 수 있습니다.
val a = 3 val b = 4 val c = a + b println(c) 자 그럼 이번엔 코드 안에서 띄어쓰기의 방식을 다르게 해보겠습니다.
val a= 3 val b = 4 val c= a+ b println(c) 각 줄마다 띄어쓰기의 방식이 다르다고 해도 컴퓨터는 코드를 문제없이 컴파일 할 수 있습니다.</description>
    </item>
    
  </channel>
</rss>
