[{"content":"이번 포스팅에서는 jsoup을 이용해서 html을 파싱하는 법에 대해 알아보도록 하겠습니다.\njsoup jsoup 은 html을 파싱하기 위해 만들어진 오픈소스 자바 라이브러리 입니다. 웹페이지를 HTML5 DOM 으로 변환하여 요소들을 간편하게 추출할 수 있습니다. 자바 라이브러리이니만큼 코틀린에서도 자유롭게 사용이 가능하지요.\njsoup에는 여러가지 클래스 가 있는데 그 중 제 생각에 중요한 것들만 정리하면 다음과 같습니다.\n   클래스 설명     Document  jsoup로 얻어온 html 문서   Element  데이터를 추출할 수 있는 개별 html 요소   Elements  Iterable한 Element 집합의 자료형   Connection  http 접속에 관련한 메소드를 가지는 클래스    jsoup 적용하기 그럼 다른 강의에서 만들었던 코루틴으로 로또번호 당첨을 확인하는 앱에 jsoup을 적용해보도록 하겠습니다. 기존의 앱은 당첨번호를 가져오는데 API를 사용했지만 이번에는 웹페이지에서 가져와야 합니다. 동행복권 홈페이지 에 접속하면 메인화면에 금주의 당첨번호를 표시하고 있는데 이 내용을 가져오면 될 것 같습니다.\n이 화면을 브라우저의 개발자도구로 보면 html의 레이아웃을 확인할 수 있습니다. 우리가 원하는 정보는 containerWrap \u0026gt; article \u0026gt; wrap_box wrap1 \u0026gt; box win win645 \u0026gt; content 클래스 안에 위치하고 있네요. 여기서 회차와 당첨번호는 다음과 같은 요소로 정의되어 있습니다.\n1  \u0026lt;strong id=\u0026#34;lottoDrwNo\u0026#34;\u0026gt;968\u0026lt;/strong\u0026gt;   1 2 3 4 5 6 7 8 9  \u0026lt;span class=\u0026#34;accessibility\u0026#34;\u0026gt;당첨번호\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;drwtNo1\u0026#34; class=\u0026#34;ball_645 ball1\u0026#34;\u0026gt;2\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;drwtNo2\u0026#34; class=\u0026#34;ball_645 ball1\u0026#34;\u0026gt;5\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;drwtNo3\u0026#34; class=\u0026#34;ball_645 ball2\u0026#34;\u0026gt;12\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;drwtNo4\u0026#34; class=\u0026#34;ball_645 ball2\u0026#34;\u0026gt;14\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;drwtNo5\u0026#34; class=\u0026#34;ball_645 ball3\u0026#34;\u0026gt;24\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;drwtNo6\u0026#34; class=\u0026#34;ball_645 ball4\u0026#34;\u0026gt;39\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;bonus\u0026#34;\u0026gt;보너스번호\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;bnusNo\u0026#34; class=\u0026#34;ball_645 ball4\u0026#34;\u0026gt;33\u0026lt;/span\u0026gt;   우선은 dependency를 추가합니다.\n1  implementation \u0026#39;org.jsoup:jsoup:1.13.1\u0026#39;   다음은 당첨번호를 가져오는 crawlLottoNumbers함수를 작성합니다. API로 당첨번호를 가져오는 getLottoNumbers와 동일하게 반환값이 당첨번호, 보너스번호, 회차 정보를 가지도록 하겠습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  private suspend fun crawlLottoNumbers() : ArrayList\u0026lt;Int\u0026gt; { val lottoNumbers = ArrayList\u0026lt;Int\u0026gt;() // var doc: Document? = null  try { val doc = Jsoup.connect(\u0026#34;https://dhlottery.co.kr/common.do?method=main\u0026#34;).get() for (i in 1..6) { val drwtNo = doc.select(\u0026#34;#drwtNo$i\u0026#34;).text().toInt() lottoNumbers.add(drwtNo) } val bnusNo = doc.select(\u0026#34;#bnusNo\u0026#34;).text().toInt() lottoNumbers.add(bnusNo) val lottoDrwNo = doc.select(\u0026#34;#lottoDrwNo\u0026#34;).text().toInt() lottoNumbers.add(lottoDrwNo) } catch (e: IOException) { e.printStackTrace() } return lottoNumbers }   우선은 Jsoup.connect().get()으로 html을 받아 Document 객체로 만들어 줍니다. 이 객체에서 데이터를 뽑아낼때는 select명령을 사용하는데 괄호 안에는 CSS or jquery-like selector syntax를 넣습니다. 주요한 셀렉터 들은 다음과 같습니다.\n tagname: find elements by tag, e.g. a ns|tag: find elements by tag in a namespace, e.g. fb|name finds fb:name elements #id: find elements by ID, e.g. #logo .class: find elements by class name, e.g. .masthead [attribute]: elements with attribute, e.g. [href]  [attr=value]: elements with attribute value, e.g. [width=500] (also quotable, like [data-name=\u0026lsquo;launch sequence\u0026rsquo;]) [attr^=value], [attr$=value], [attr*=value]: elements with attributes that start with, end with, or contain the value, e.g. [href*=/path/] [attr~=regex]: elements with attribute values that match the regular expression; e.g. img[src~=(?i).(png|jpe?g)] *: all elements, e.g. *  당첨번호와 회차정보는 id로 정의되어 있기 때문에 select 함수에 #id 쿼리를 전달해주면 됩니다. 추출한 정보를 Int로 변환하여 lottoNumbers에 추가하면 끝입니다.\n이렇게 해서 jsoup으로 html을 다운받고 파싱하는 법에 대해 알아보았습니다.\n","description":"","id":0,"section":"posts","tags":["jsoup","coroutine","html","parsing"],"title":"jsoup으로 html 파싱하기","uri":"https://cliearl.github.io/en/posts/jsoup-lotto-checker/"},{"content":"이번 포스팅에서는 RecyclerView에 ListAdapter를 적용하는 법에 대해 알아보도록 하겠습니다.\n들어가기 리사이클러뷰의 데이터가 변하면 리사이클러뷰 어댑터가 제공하는 notifyItem 메소드 를 사용해서 뷰홀더 내용을 갱신할 수 있습니다.\nnotifyItemChanged(int) notifyItemInserted(int) notifyItemRemoved(int) notifyItemRangeChanged(int, int) notifyItemRangeInserted(int, int) notifyItemRangeRemoved(int, int) 그런데 데이터가 변경되는 방식을 확인하고 그때마다 이렇게 notify를 일일이 해 주는것은 번거롭기도 하고, 또 사용하기에 따라서는 갱신이 필요없는 뷰홀더를 같이 갱신하는 불필요한 작업이 생길수도 있습니다.\nDiffUtil DiffUtil 은 두 데이터셋을 받아서 그 차이를 계산해주는 클래스입니다. DiffUtil을 사용하면 두 데이터 셋을 비교한 뒤 그중 변한부분만을 파악하여 리사이클러뷰에 반영할 수 있습니다.\nDiffUtil은 Eugene W. Myers의 difference 알고리즘을 이용해서 O(N + D^2)시간 안에 리스트의 비교를 수행하는데 넥서스 5X에서 테스트를 수행한 결과는 다음과 같았다고 합니다. 이때 N은 추가 및 제거된 항목의 갯수이고, D는 스크립트의 길이입니다.\n100 items and 10 modifications: avg: 0.39 ms, median: 0.35 ms 100 items and 100 modifications: 3.82 ms, median: 3.75 ms 100 items and 100 modifications without moves: 2.09 ms, median: 2.06 ms 1000 items and 50 modifications: avg: 4.67 ms, median: 4.59 ms 1000 items and 50 modifications without moves: avg: 3.59 ms, median: 3.50 ms 1000 items and 200 modifications: 27.07 ms, median: 26.92 ms 1000 items and 200 modifications without moves: 13.54 ms, median: 13.36 ms DiffUtil을 사용하기 위해서는 DiffUtil.Callback() 을 상속받아 areItemsTheSame()으로 비교대상인 두 객체가 동일한지 확인하고, areContentsTheSame()으로 두 아이템이 동일한 데이터를 가지는지 확인하면 됩니다.\nAsyncListDiffer DiffUtil은 아이템 개수가 많을 경우 비교연산시간에 필요한 시간이 길어질 수 있기 때문에 백그라운드 스레드에서 처리되어야 합니다. AsyncListDiffer 는 DiffUtil을 편하게 쓰기 위해서 만들어진 클래스로, DiffUtil에 대해 자체적으로 스레드 처리를 해 줍니다.\n코드를 사용하기 위해서는 우선 어댑터 내부로 DiffUtil 콜백을 전달받은 AsyncListDiffer 객체를 만들어 줍니다. 그리고 currentList로 데이터를 참조하고 submitList()로 리스트 데이터를 갱신하면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // Google Developers에서 제공하는 코드  class UserAdapter extends RecyclerView.Adapter\u0026lt;UserViewHolder\u0026gt; { private final AsyncListDiffer\u0026lt;User\u0026gt; mDiffer = new AsyncListDiffer(this, DIFF_CALLBACK); @Override public int getItemCount() { return mDiffer.getCurrentList().size(); } public void submitList(List\u0026lt;User\u0026gt; list) { mDiffer.submitList(list); } @Override public void onBindViewHolder(UserViewHolder holder, int position) { User user = mDiffer.getCurrentList().get(position); holder.bindTo(user); } public static final DiffUtil.ItemCallback\u0026lt;User\u0026gt; DIFF_CALLBACK = new DiffUtil.ItemCallback\u0026lt;User\u0026gt;() { @Override public boolean areItemsTheSame( @NonNull User oldUser, @NonNull User newUser) { // User properties may have changed if reloaded from the DB, but ID is fixed  return oldUser.getId() == newUser.getId(); } @Override public boolean areContentsTheSame( @NonNull User oldUser, @NonNull User newUser) { // NOTE: if you use equals, your object must properly override Object#equals()  // Incorrectly returning false here will result in too many animations.  return oldUser.equals(newUser); } } }   ListAdapter ListAdapter 는 AsyncListDiffer를 더 쓰기 편하도록 랩핑한 클래스로 리사이클러뷰 어댑터를 만들때 ListAdapter를 상속하도록 하면 됩니다. 초기화할때 DiffUtil 콜백 객체를 받도록 하면 나머지는 AsyncListDiffer와 같이 currentList로 현재 데이터를 불러올 수 있고, submitList로 데이터를 갱신할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  // Google Developers에서 제공하는 코드  class UserAdapter extends ListAdapter\u0026lt;User, UserViewHolder\u0026gt; { public UserAdapter() { super(User.DIFF_CALLBACK); } @Override public void onBindViewHolder(UserViewHolder holder, int position) { holder.bindTo(getItem(position)); } public static final DiffUtil.ItemCallback\u0026lt;User\u0026gt; DIFF_CALLBACK = new DiffUtil.ItemCallback\u0026lt;User\u0026gt;() { @Override public boolean areItemsTheSame( @NonNull User oldUser, @NonNull User newUser) { // User properties may have changed if reloaded from the DB, but ID is fixed  return oldUser.getId() == newUser.getId(); } @Override public boolean areContentsTheSame( @NonNull User oldUser, @NonNull User newUser) { // NOTE: if you use equals, your object must properly override Object#equals()  // Incorrectly returning false here will result in too many animations.  return oldUser.equals(newUser); } } }   다시말해 리사이클러뷰 어댑터를 ListAdapter로 구현하면 데이터가 어떻게 바뀌든간에 submitList로 전체 리스트를 넘겨주기만 하면 어댑터가 알아서 백그라운드 스레드를 사용해 리스트 차이를 계산하여 화면을 갱신시켜주게 됩니다.\n앱 작성 기존에 다른 강의 에서 작성했던 프로젝트를 고치는 형태로 프로젝트를 만들어 보겠습니다.\nMonster.kt 우선 리사이클러뷰에 표시할 데이터를 데이터클래스형태로 준비합니다.\n1 2 3 4 5 6 7 8 9 10 11  data class Monster( val name: String, val race: Race, val level: Int, val stats: List\u0026lt;Int\u0026gt;, val encount: Boolean ) enum class Race { Zombie, Human, Goblin, Dragon }   view_itemlist.xml 리사이클러뷰의 뷰홀더 xml을 만들어줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/vhLayout\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;?attr/selectableItemBackground\u0026#34; android:baselineAligned=\u0026#34;false\u0026#34; android:gravity=\u0026#34;center_vertical\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:padding=\u0026#34;10dp\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;9\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_name\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:padding=\u0026#34;3dp\u0026#34; android:text=\u0026#34;Monster name\u0026#34; android:textSize=\u0026#34;24sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_race\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Race\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_level\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Level\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_stats\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Stats\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_encount\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Encount\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;30dp\u0026#34; android:layout_height=\u0026#34;30dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:src=\u0026#34;@drawable/ic_baseline_reorder_24\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt;   MyViewHolder.kt 리사이클러뷰의 뷰홀더 클래스를 만들어줍니다. 뷰바인딩을 사용하도록 세팅하고 나중에 투명도를 바꾸는데 사용하도록 setAlpha() 함수를 만들어줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class MyViewHolder(private val binding: ViewItemlistBinding) : RecyclerView.ViewHolder(binding.root) { fun bind(data: Monster) { with(binding) { tvName.text = \u0026#34;Name: ${data.name}\u0026#34; tvRace.text = \u0026#34;Race: ${data.race}\u0026#34; tvLevel.text = \u0026#34;Level: ${data.level}\u0026#34; tvStats.text = \u0026#34;HP: ${data.stats[0]}/ MP: ${data.stats[1]}/ Exp: ${data.stats[2]}\u0026#34; tvEncount.text = \u0026#34;Encounted: ${data.encount}\u0026#34; vhLayout.setOnClickListener { Snackbar.make(it, \u0026#34;Item $layoutPositiontouched!\u0026#34;, Snackbar.LENGTH_SHORT).show() } } } fun setAlpha(alpha: Float) { with(binding) { tvName.alpha = alpha tvRace.alpha = alpha tvLevel.alpha = alpha tvStats.alpha = alpha tvEncount.alpha = alpha } } }   MyDiffCallback.kt Monster 클래스가 데이터 클래스이므로 areItemsTheSame()은 자동으로 생성되는 hashCode()로 비교하도록 하였습니다. 데이터클래스의 정의에 따라 동일한 두 객체의 hashCode()는 동일한 값을 갖게 됩니다. 또한 equals()도 데이터클래스의 정의에 의해 자동으로 생성되므로 areContentsTheSame() 메소드는 equals를 이용해 구현합니다.\n1 2 3 4 5 6 7 8 9 10  class MyDiffCallback : DiffUtil.ItemCallback\u0026lt;Monster\u0026gt;() { override fun areItemsTheSame(oldItem: Monster, newItem: Monster): Boolean { return oldItem.hashCode() == newItem.hashCode() } override fun areContentsTheSame(oldItem: Monster, newItem: Monster): Boolean { return oldItem == newItem } }   MyListAdapter.kt ListAdapter를 상속받는 리사이클러뷰 어댑터를 작성합니다. onCreateViewHolder에서 뷰바인딩을 사용하도록 설정합니다. 데이터의 개수는 ListAdapter가 관리하므로 기존의 리사이클러뷰 어댑터에서 정의했던 getItemCount()는 오버라이드하지 않아도 됩니다.\n그리고 아이템을 이동했을때 실행할 moveItem(), 지울때 실행할 removeItem() 메소드를 작성해줍니다. 이 때 ListAdapter에서는 데이터를 직접 조작할 수 없고 비교만 할수 있기 때문에 변형된 데이터셋은 새로운 객체로 만들어 기존의 데이터셋과 비교도록 submitList()를 수행하게 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class MyListAdapter : ListAdapter\u0026lt;Monster, RecyclerView.ViewHolder\u0026gt;(MyDiffCallback()) { override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder { val viewHolder = MyViewHolder( ViewItemlistBinding.inflate( LayoutInflater.from(parent.context), parent, false ) ) return viewHolder } override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) { if (holder is MyViewHolder) { val monster = getItem(position) as Monster holder.bind(monster) } } fun moveItem(fromPosition: Int, toPosition: Int) { val newList = currentList.toMutableList() // val item = newList.removeAt(fromPosition)  // newList.add(toPosition, item)  Collections.swap(newList, fromPosition, toPosition) submitList(newList) } fun removeItem(position: Int) { val newList = currentList.toMutableList() newList.removeAt(position) submitList(newList) } }   MyItemTouchHelperCallback.kt 기존 프로젝트에서 터치 콜백을 받기 위해 MainActivity에서 사용했던 ItemTouchHelper.SimpleCallback 클래스는 코드의 가독성을 위해 개별 클래스로 분리시키겠습니다.\n그리고 추가로 홀딩중인 뷰홀더의 투명도를 변화시켜 더 인지하기 쉽게 만들겠습니다. 그럴려면 onSelectedChanged()에서 투명도를 50%로 낮추었다가 clearView()애서 다시 100%로 되돌리도록 하면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  class MyItemTouchHelperCallback(private val recyclerView: RecyclerView) : ItemTouchHelper.SimpleCallback( ItemTouchHelper.UP or ItemTouchHelper.DOWN, ItemTouchHelper.LEFT ) { override fun onMove( recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder, target: RecyclerView.ViewHolder ): Boolean { (recyclerView.adapter as MyListAdapter).moveItem( viewHolder.absoluteAdapterPosition, target.absoluteAdapterPosition ) return true } override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) { (recyclerView.adapter as MyListAdapter).removeItem(viewHolder.layoutPosition) } // 홀딩중인 뷰홀더 투명도를 변경  override fun onSelectedChanged(viewHolder: RecyclerView.ViewHolder?, actionState: Int) { super.onSelectedChanged(viewHolder, actionState) when (actionState) { ItemTouchHelper.ACTION_STATE_DRAG, ItemTouchHelper.ACTION_STATE_SWIPE -\u0026gt; { (viewHolder as MyViewHolder).setAlpha(0.5f) } } } // 홀딩중인 뷰홀더 투명도를 되돌림  override fun clearView( recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder ) { super.clearView(recyclerView, viewHolder) (viewHolder as MyViewHolder).setAlpha(1.0f) } }   activity_main.xml 리사이클러뷰와 플로팅버튼을 배치해줍니다. 기존의 터치조작에 더해 DiffUtil의 테스트를 위해 플로팅버튼을 누르면 데이터가 랜덤하게 뒤섞이는 기능이 수행되도록 하겠습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;androidx.recyclerview.widget.RecyclerView android:id=\u0026#34;@+id/recyclerview\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:scrollbars=\u0026#34;vertical\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; tools:listitem=\u0026#34;@layout/view_itemlist\u0026#34; /\u0026gt; \u0026lt;com.google.android.material.floatingactionbutton.FloatingActionButton android:id=\u0026#34;@+id/fab\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_margin=\u0026#34;20dp\u0026#34; android:src=\u0026#34;@drawable/ic_baseline_add_24\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;   MainActivity.kt 데이터셋에 초기값을 넣어주고, 어댑터 인스턴스를 생성하여 리사이클러뷰와 연동시킵니다. 그리고 터치헬퍼를 달아 스와이프와 드래그를 했을때 데이터가 잘 갱신되는지 확인합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  class MainActivity : AppCompatActivity() { private val binding: ActivityMainBinding by lazy { ActivityMainBinding.inflate(layoutInflater) } private val myListAdapter: MyListAdapter by lazy { MyListAdapter() } private val dataSet = arrayListOf\u0026lt;Monster\u0026gt;().apply { add(Monster(\u0026#34;타일런트\u0026#34;, Race.Zombie, 10, listOf(100, 10, 50), false)) add(Monster(\u0026#34;조커\u0026#34;, Race.Human, 23, listOf(200, 20, 100), false)) add(Monster(\u0026#34;그렘린\u0026#34;, Race.Goblin, 2, listOf(10, 1, 5), true)) add(Monster(\u0026#34;리오레우스\u0026#34;, Race.Dragon, 2500, listOf(10000, 1000, 50000), false)) add(Monster(\u0026#34;사우론\u0026#34;, Race.Human, 100, listOf(1000, 200, 1000), false)) add(Monster(\u0026#34;리바이어던\u0026#34;, Race.Dragon, 50, listOf(2000, 250, 10000), true)) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(binding.root) binding.recyclerview.apply { layoutManager = LinearLayoutManager(context, LinearLayoutManager.VERTICAL, false) addItemDecoration(DividerItemDecoration(context, DividerItemDecoration.VERTICAL)) adapter = myListAdapter } myListAdapter.submitList(dataSet) binding.fab.setOnClickListener { myListAdapter.submitList(dataSet.shuffled()) } val itemTouchHelper = ItemTouchHelper(MyItemTouchHelperCallback(binding.recyclerview)) itemTouchHelper.attachToRecyclerView(binding.recyclerview) } }   이렇게해서 ListAdapter를 RecyclerView에 적용하는 법에 대해 알아보았습니다.\n","description":"","id":1,"section":"posts","tags":["RecyclerView","ListAdapter"],"title":"RecyclerView에 ListAdapter 적용하기","uri":"https://cliearl.github.io/en/posts/recyclerview-listadapter/"}]