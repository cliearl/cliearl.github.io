[{"content":"이번 포스팅에서는 RecyclerView에 ListAdapter를 적용하는 법에 대해 알아보도록 하겠습니다.\n이론 리사이클러뷰의 데이터가 변하면 리사이클러뷰 어댑터가 제공하는 notifyItem 메소드를 사용해서 뷰홀더 내용을 갱신할 수 있습니다. 그런데 이렇게 notify를 일일이 해 주는것은 귀찮기도 하고 사용하기에 따라서는 갱신이 필요없는 뷰홀더를 갱신하는 일이 생기기도 한다.\nDiffUtil DiffUtil은 두 리스트의 차이를 계산하는 클래스입니다.\nEugene W. Myers의 difference 알고리즘을 이용해서 O(N + D^2)시간 안에 리스트의 비교를 수행하는데 넥서스 5X에서 테스트를 수행한 결과는 다음과 같았다고 합니다.\n 100 items and 10 modifications: avg: 0.39 ms, median: 0.35 ms 100 items and 100 modifications: 3.82 ms, median: 3.75 ms 100 items and 100 modifications without moves: 2.09 ms, median: 2.06 ms 1000 items and 50 modifications: avg: 4.67 ms, median: 4.59 ms 1000 items and 50 modifications without moves: avg: 3.59 ms, median: 3.50 ms 1000 items and 200 modifications: 27.07 ms, median: 26.92 ms 1000 items and 200 modifications without moves: 13.54 ms, median: 13.36 ms DiffUtil을 사용하기 위해서는 DiffUtil.Callback()을 상속받아 areItemsTheSame()과 areContentsTheSame()을 구현하면 되는데, 전자는 두 아이템이 동일한 아이템인지 체크하고 만약 동일하면 후자의 메소드로 내용물까지 동일한지 확인하게 됩니다.\nAsyncListDiffer DiffUtil은 아이템 개수가 많을 경우 비교연산시간이 길어질 수 있기 때문에 백그라운드 스레드에서 처리되어야 합니다. AsyncListDiffer는 DiffUtil을 편하게 쓰도록 만들어진 클래스로, 자체적으로 스레드 처리를 해 줍니다. 코드를 사용하기 위해서는 우선 어댑터 내부에 DiffUtil 콜백을 전달해 준 AsyncListDiffer 객체를 만들어 줍니다. 그리고 currentList로 데이터를 참조하고 submitList()로 리스트 데이터를 갱신하면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // Google Developer에서 제공하는 코드  class UserAdapter extends RecyclerView.Adapter\u0026lt;UserViewHolder\u0026gt; { private final AsyncListDiffer\u0026lt;User\u0026gt; mDiffer = new AsyncListDiffer(this, DIFF_CALLBACK); @Override public int getItemCount() { return mDiffer.getCurrentList().size(); } public void submitList(List\u0026lt;User\u0026gt; list) { mDiffer.submitList(list); } @Override public void onBindViewHolder(UserViewHolder holder, int position) { User user = mDiffer.getCurrentList().get(position); holder.bindTo(user); } public static final DiffUtil.ItemCallback\u0026lt;User\u0026gt; DIFF_CALLBACK = new DiffUtil.ItemCallback\u0026lt;User\u0026gt;() { @Override public boolean areItemsTheSame( @NonNull User oldUser, @NonNull User newUser) { // User properties may have changed if reloaded from the DB, but ID is fixed  return oldUser.getId() == newUser.getId(); } @Override public boolean areContentsTheSame( @NonNull User oldUser, @NonNull User newUser) { // NOTE: if you use equals, your object must properly override Object#equals()  // Incorrectly returning false here will result in too many animations.  return oldUser.equals(newUser); } } }   ListAdapter ListAdapter는 AsyncListDiffer를 더 쓰기 편하도록 랩핑한 클래스로 리사이클러뷰 어댑터를 만들때 ListAdapter를 상속하도록 하면 됩니다. 초기화할때 DiffUtil 콜백 객체를 받도록 하면 나머지는 AsyncListDiffer와 같이 currentList로 현재 데이터를 불러올 수 있고, submitList로 데이터를 갱신할 수 있습니다.\n다시말해 ListAdapter로 리사이클러뷰 어댑터를 구현하면 데이터를 어떻게 바뀌든간에 submitList로 전체 리스트를 넘겨주기만 하면 어댑터가 알아서 백그라운드 스레드를 사용해 리스트 차이를 계산하여 화면을 갱신시켜주게 됩니다.\n앱 작성 기존에 다른 강의에서 작성했던 프로젝트를 고치는 형태로 프로젝트를 만들어 보겠습니다.\nMonster.kt 우선 리사이클러뷰에 표시할 데이터를 데이터클래스형태로 준비합니다.\n1 2 3 4 5 6 7 8 9 10 11  data class Monster( val name: String, val race: Race, val level: Int, val stats: List\u0026lt;Int\u0026gt;, val encount: Boolean ) enum class Race { Zombie, Human, Goblin, Dragon }   view_itemlist.xml 리사이클러뷰의 뷰홀더 xml을 만들어줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/vhLayout\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;?attr/selectableItemBackground\u0026#34; android:gravity=\u0026#34;center_vertical\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:paddingStart=\u0026#34;20dp\u0026#34; android:paddingEnd=\u0026#34;20dp\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;9\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_name\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:padding=\u0026#34;3dp\u0026#34; android:text=\u0026#34;Monster name\u0026#34; android:textSize=\u0026#34;24sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_race\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Race\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_level\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Level\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_stats\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Stats\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_encount\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Encount\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;FrameLayout android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;30dp\u0026#34; android:layout_height=\u0026#34;30dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:src=\u0026#34;@drawable/ic_baseline_reorder_24\u0026#34; /\u0026gt; \u0026lt;/FrameLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt;   MyViewHolder.kt 리사이클러뷰의 뷰홀더 클래스를 만들어줍니다. 뷰바인딩을 사용하도록 세팅하고 나중에 사용하도록 setAlpha() 함수를 만들어줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class MyViewHolder(private val binding: ViewItemlistBinding) : RecyclerView.ViewHolder(binding.root) { fun bind(data: Monster) { with(binding) { tvName.text = \u0026#34;Name: ${data.name}\u0026#34; tvRace.text = \u0026#34;Race: ${data.race}\u0026#34; tvLevel.text = \u0026#34;Level: ${data.level}\u0026#34; tvStats.text = \u0026#34;HP: ${data.stats[0]}/ MP: ${data.stats[1]}/ Exp: ${data.stats[2]}\u0026#34; tvEncount.text = \u0026#34;Encounted: ${data.encount}\u0026#34; vhLayout.setOnClickListener { Snackbar.make(it, \u0026#34;Item $layoutPositiontouched!\u0026#34;, Snackbar.LENGTH_SHORT).show() } } } fun setAlpha(alpha: Float) { with(binding) { tvName.alpha = alpha tvRace.alpha = alpha tvLevel.alpha = alpha tvStats.alpha = alpha tvEncount.alpha = alpha } } }   MyDiffCallback.kt Monster 클래스가 데이터 클래스이므로 areItemsTheSame()은 자동으로 정의되는 hashCode()로 비교하도록 하였습니다. equals()도 자동으로 정의되므로 areContentsTheSame() 메소드는 equals를 이용해 구현합니다.\n1 2 3 4 5 6 7 8 9  class MyDiffCallback : DiffUtil.ItemCallback\u0026lt;Monster\u0026gt;() { override fun areItemsTheSame(oldItem: Monster, newItem: Monster): Boolean { return oldItem.hashCode() == newItem.hashCode() } override fun areContentsTheSame(oldItem: Monster, newItem: Monster): Boolean { return oldItem == newItem } }   MyListAdapter.kt ListAdapter를 상속받는 리사이클러뷰 어댑터를 작성합니다. onCreateViewHolder에서 뷰바인딩을 사용하도록 설정합니다. 데이터의 개수는 ListAdapter가 관리하므로 getItemCount()는 오버라이드하지 않아도 됩니다.\n그리고 아이템을 이동 및 지우기 위해 moveItem(), removeItem() 메소드를 작성해줍니다. ListAdapter에서는 데이터를 직접 조작할 수 없고 비교만 할수 있기 때문에 새로운 데이터셋을 만들어 submitList()를 수행하는 방법으로 데이터를 갱신합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  class MyListAdapter : ListAdapter\u0026lt;Monster, RecyclerView.ViewHolder\u0026gt;(MyDiffCallback()) { override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder { val viewHolder = MyViewHolder( ViewItemlistBinding.inflate( LayoutInflater.from(parent.context), parent, false ) ) return viewHolder } override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) { if (holder is MyViewHolder) { val monster = getItem(position) as Monster holder.bind(monster) } } fun moveItem(fromPosition: Int, toPosition: Int) { val newList = currentList.toMutableList() val item = newList.removeAt(fromPosition) newList.add(toPosition, item) submitList(newList) } fun removeItem(position: Int) { val newList = currentList.toMutableList() newList.removeAt(position) submitList(newList) } }   MyItemTouchHelperCallback.kt 기존에 MainActivity에서 수행했던 ItemTouchHelper.SimpleCallback은 코드의 가독성을 위해 개별 클래스로 분리시킵니다.\n이때 홀딩중인 뷰홀더의 투명도를 변화시켜 더 인지하기 쉽게 만들겠습니다. 그를 위해 onSelectedChanged()에서 투명도를 50%로 낮추었다가 clearView()애서 다시 100%로 되돌리도록 하였습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  class MyItemTouchHelperCallback(private val recyclerView: RecyclerView) : ItemTouchHelper.SimpleCallback( ItemTouchHelper.UP or ItemTouchHelper.DOWN, ItemTouchHelper.LEFT ) { override fun onMove( recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder, target: RecyclerView.ViewHolder ): Boolean { (recyclerView.adapter as MyListAdapter).moveItem( viewHolder.absoluteAdapterPosition, target.absoluteAdapterPosition ) return true } override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) { (recyclerView.adapter as MyListAdapter).removeItem(viewHolder.layoutPosition) } // 홀딩중인 뷰홀더 투명도를 변경  override fun onSelectedChanged(viewHolder: RecyclerView.ViewHolder?, actionState: Int) { super.onSelectedChanged(viewHolder, actionState) when (actionState) { ItemTouchHelper.ACTION_STATE_DRAG, ItemTouchHelper.ACTION_STATE_SWIPE -\u0026gt; { (viewHolder as MyViewHolder).setAlpha(0.5f) } } } // 홀딩중인 뷰홀더 투명도를 되돌림  override fun clearView( recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder ) { super.clearView(recyclerView, viewHolder) (viewHolder as MyViewHolder).setAlpha(1.0f) } }   activity_main.xml 리사이클러뷰와 플로팅버튼을 배치해줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;androidx.recyclerview.widget.RecyclerView android:id=\u0026#34;@+id/recyclerview\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:scrollbars=\u0026#34;vertical\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; tools:listitem=\u0026#34;@layout/view_itemlist\u0026#34; /\u0026gt; \u0026lt;com.google.android.material.floatingactionbutton.FloatingActionButton android:id=\u0026#34;@+id/fab\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginEnd=\u0026#34;20dp\u0026#34; android:layout_marginBottom=\u0026#34;20dp\u0026#34; android:src=\u0026#34;@drawable/ic_baseline_add_24\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;   MainActivity.kt 데이터셋을 초기화한뒤 어댑터를 만들어 리사이클러뷰와 연동시킵니다. 플로팅버튼을 누르면 데이터가 랜덤하게 뒤섞이도록 합니다. 그리고 터치헬퍼를 달아 스와이프와 드래그를 했을때 데이터가 잘 갱신되는지 확인합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  class MainActivity : AppCompatActivity() { private val binding: ActivityMainBinding by lazy { ActivityMainBinding.inflate(layoutInflater) } private lateinit var adapter: MyListAdapter private val dataSet = arrayListOf\u0026lt;Monster\u0026gt;().apply { add(Monster(\u0026#34;타일런트\u0026#34;, Race.Zombie, 10, listOf(100, 10, 50), false)) add(Monster(\u0026#34;조커\u0026#34;, Race.Human, 23, listOf(200, 20, 100), false)) add(Monster(\u0026#34;그렘린\u0026#34;, Race.Goblin, 2, listOf(10, 1, 5), true)) add(Monster(\u0026#34;리오레우스\u0026#34;, Race.Dragon, 2500, listOf(10000, 1000, 50000), false)) add(Monster(\u0026#34;사우론\u0026#34;, Race.Human, 100, listOf(1000, 200, 1000), false)) add(Monster(\u0026#34;리바이어던\u0026#34;, Race.Dragon, 50, listOf(2000, 250, 10000), true)) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(binding.root) adapter = MyListAdapter() adapter.submitList(dataSet) binding.recyclerview.layoutManager = LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false) binding.recyclerview.adapter = adapter binding.recyclerview.addItemDecoration( DividerItemDecoration( applicationContext, DividerItemDecoration.VERTICAL ) ) binding.fab.setOnClickListener { adapter.submitList(dataSet.shuffled()) } val itemTouchHelper = ItemTouchHelper(MyItemTouchHelperCallback(binding.recyclerview)) itemTouchHelper.attachToRecyclerView(binding.recyclerview) } }   ","description":"","id":0,"section":"posts","tags":["RecyclerView","ListAdapter"],"title":"RecyclerView에 ListAdapter 적용하기","uri":"https://cliearl.github.io/en/posts/recyclerview-listadapter/"},{"content":"이번 포스팅에서는 단말의 인터넷 연결상태를 체크하는 법에 대해 알아보도록 하겠습니다.\n앱을 만들다보면 WIFI를 사용할 수 있을 때 대용량 데이터를 다운로드하도록 하는 등의 처리를 위해 단말의 인터넷 연결상태를 체크해야 할 일이 있습니다.\n이때 ConnectivityManager를 사용하면 단말이 어떤 접속환경을 통해 인터넷에 연결되어 있는지 확인할 수 있습니다.\n권한추가 인터넷에 접근하고 네트워크 상태를 가져오기 위해 AndroidManifest.xml에 다음 권한을 추가합니다.\n1 2  \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_NETWORK_STATE\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34; /\u0026gt;   네트워크 타입 확인 우선은 단말이 연결된 네트워크가 와아파이인지 셀룰러인지 확인하는 코드를 써 보겠습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  private fun getNetworkType(context: Context): String { val connMgr = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.M) { val nw = connMgr.activeNetwork ?: return \u0026#34;NO_CONNECTION\u0026#34; val actNw = connMgr.getNetworkCapabilities(nw) ?: return \u0026#34;NO_CONNECTION\u0026#34; return when { actNw.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) -\u0026gt; \u0026#34;WIFI_STATE\u0026#34; actNw.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) -\u0026gt; \u0026#34;CELLULAR_STATE\u0026#34; actNw.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET) -\u0026gt; \u0026#34;ETHERNET_STATE\u0026#34; else -\u0026gt; \u0026#34;NO_CONNECTION\u0026#34; } } else { val nwInfo = connMgr.activeNetworkInfo ?: return \u0026#34;NO_CONNECTION\u0026#34; return nwInfo.typeName } }   기본은 ConnectivityManager 인스턴스를 만들고 그 인스턴스로부터 네트워크 타입을 가져오는 방식입니다. API Level 23 마시멜로우까지는 connMgr.activeNetworkInfo 인스턴스를 만든 뒤 typeName 프로퍼티로 네트워크 타입을 문자열 형태로 확인할 수 있었습니다.\n그러나 마시멜로우 이상에서는 ConnectivityManager의 activeNetwork 프로퍼티로 우선 기본 데이터 네트워크를 받아옵니다. 그리고 TransportInfo로 네트워크 타입을 가져오기 위해 getNetworkCapabilities 인스턴스를 만들어줍니다. 이 시점에서 접속이 확인되지 않을 경우 네트워크에 접속되지 않은 것입니다.\n네트워크 접속여부 확인 NetworkInfo 인스턴스의 isConnected() 메소드를 사용하면 현재 인터넷에 접속되어있는지를 확인할 수 있습니다. 그런데 이 메소드로는 버스나 공항에서 접속할 수 있는 인증이 필요한 와이파이에 대해서는 인증이 되지 않아서 실제로는 와아파이를 사용할 수 없어도 true를 반환하게 됩니다.\n따라서 실제로 임의의 주소에 핑을 날려보는게 더 확실합니다. 구글에서는 이렇게 네트워크 접속을 확인할 때 쓰라고 Network Portal Detection 사이트를 준비해 놓았습니다. 그 주소는 다음과 같습니다.\nhttp://clients3.google.com/generate_204\n이 주소로 접속에 성공하면 \u0026lsquo;HTTP 204 No Content\u0026rsquo; 를 반환합니다. 204 응답이 돌아오면 단말이 인터넷을 사용할 수 있는 상태라는 거지요.\n우선은 http://clients3.google.com/generate_204에 접속하여 response code를 받아오는 함수를 작성합니다. 네트워크에 접속해야 하므로 비동기로 처리하기 위해 Thread 클래스를 상속받도록 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  private class CheckConnection(private val host: String) : Thread() { var isSuccess = false override fun run() { var urlConnection: HttpURLConnection? = null try { urlConnection = URL(host).openConnection() as HttpURLConnection urlConnection.setRequestProperty(\u0026#34;User-Agent\u0026#34;, System.getProperty(\u0026#34;http.agent\u0026#34;)) urlConnection.connectTimeout = 1000 urlConnection.connect() val responseCode = urlConnection.responseCode if (responseCode == 204) { isSuccess = true } } catch (e: Exception) { e.printStackTrace() } urlConnection?.disconnect() } }   다음은 CheckConnection을 실행시켜주면 되겠죠. 스레드를 시작하고 204 응답이 돌아왔다면 true를 반환하는 함수를 만들어줍니다.메인스레드에서 작업이 끝날때까지 대기하도록 하기 위해 join()을 추가로 실행시켜 줍니다.\n1 2 3 4 5 6 7 8 9 10 11  private fun isOnline(): Boolean { val cc = CheckConnection(\u0026#34;http://clients3.google.com/generate_204\u0026#34;) cc.start() try { cc.join() return cc.isSuccess } catch (e: Exception) { e.printStackTrace() } return false }   이렇게 해서 단말의 네트워크 상태를 체크하는 법에 대해 알아보았습니다.\n","description":"","id":1,"section":"posts","tags":["WIFI","ConnectivityManager"],"title":"단말의 인터넷 연결상태 체크하기","uri":"https://cliearl.github.io/en/posts/check-connection/"},{"content":"이번 포스팅에서는 Assets 폴더를 사용하는 법에 대해 알아보겠습니다.\n안드로이드의 읽기전용 파일 저장폴더 앱을 만들다보면 읽기전용 로우파일을 앱에 저장하고 불러와서 사용해야 할 때가 있습니다. 이 때 파일은 다음 두 폴더에 저장할 수 있습니다.\n assets folder res/raw folder  각 폴더의 특징은 다음과 같습니다. 간단히 정리하면 XML과 연계하여 다루어야 할 때는 res/raw를 사용하고, 그렇지 않을 경우 assets 폴더를 사용하면 될 것 같네요.\n   값 assets res/raw     파일명 자유롭게 설정 가능 a-z, 0-9, _ 만 사용가능   서브폴더 사용가능 사용불가   컴파일타임 파일체크 없음 파일체크 있음   파일 리스팅 list()로 가능 불가능   XML에서 접근 불가능 가능    앱 만들어보기 그럼 assets 폴더에서 json 파일을 불러와서 리사이클러뷰에 표시하는 간단한 앱을 만들어 보겠습니다. 리사이클러뷰는 기존에 다른강의에서 작성했던 프로젝트를 수정해서 사용하겠습니다. Json 포맷을 다룰 것이므로 Gson 라이브러리를 추가합니다. Gson에 대한 구체적인 설명에 대해서는 역시 다른강의에서 설명한 내용을 참조하시기 바랍니다.\n데이터 준비 New \u0026gt; Folder \u0026gt; Asset Folder로 assets 폴더를 추가합니다.\n데이터는 경기데이터드림에서 제공하는 \u0026ldquo;코로나바이러스 감염증 선별진료소 운영 의료기관 현황\u0026rdquo; 데이터를 사용하겠습니다. sheet 탭에서 json을 클릭하여 데이터를 다운받습니다. 다운받아보면 내용이 한줄에 모여있어 보기 불편합니다. 사용하는데는 관계 없지만 이쁘게 정렬해보겠습니다.\nJson Formatter 에서 파일을 정렬하고 data.json으로 assets 폴더에 저장합니다.\n데이터클래스 준비 데이터 파일에는 데이터기준일자, 시군명,\t의료기관명,\t의료기관 구분,\t의료기관 전화번호1,\t의료기관 전화번호2,\t소재지지번주소,\t소재지도로명주소,\tWGS84위도,\tWGS84경도 등 여러가지 탭이 있습니다.\n각 데이터는 배열 속의 데이터클래스로 관리하기 위해 데이터클래스를 만들어줍니다. 데이터클래스의 특징에 대해서는 다른 강의에서 설명한 내용을 참고하시기 바랍니다.\nNew \u0026gt; Kotlin data class File from JSON을 선택하여 위에서 만든 json 데이터를 넣어주면 자동으로 데이터클래스와 배열 클래스가 생성됩니다.\n새로 만들어진 데이터클래스의 형식에 맞게 리사이클러뷰 어댑터와 xml의 내용을 수정해줍니다.\nassets 폴더속 파일 불러오기 그리고 메인액티비티에서 assets 폴더속 파일을 불러오기 위한 함수를 만들어줍니다. assets 폴더에 접근하기 위해 Asset Manager 인스턴스를 생성하고 bufferedReader()를 이용해 InputStream을 텍스트로 변환합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13  private fun getJsonData(filename: String): CoronaMed? { val assetManager = resources.assets var result: CoronaMed? = null try { val inputStream = assetManager.open(filename) val reader = inputStream.bufferedReader() val gson = Gson() result = gson.fromJson(reader, CoronaMed::class.java) } catch (e:IOException) { e.printStackTrace() } return result }   나머지는 이렇게 얻어온 CoronaMed 객체를 리사이클러뷰 어댑터에 전달해주면 됩니다. 이렇게 해서 assets 폴더에서 json 파일을 불러오는 법에 대해 알아보았습니다.\n","description":"","id":2,"section":"posts","tags":["assets","json","recyclerview"],"title":"Assets 폴더에서 로딩한 json 파일 Recyclerview에 표시하기","uri":"https://cliearl.github.io/en/posts/assets-json-recycler/"},{"content":"이번 포스팅에서는 ViewPager2와 TabLayout을 이용하여 다음과 같은 디자인을 구현해 보도록 하겠습니다.\n들어가기 ViewPager2를 사용하는 이유나 장점에 대해서는 다른 강의에서 다루었으니 그 내용을 참조해 주시기 바랍니다.\n프로젝트 작성 gradle 설정 우선은 뷰바인딩 사용설정 및 ViewPager2 플러그인을 추가합니다.\n1 2 3 4 5 6 7 8 9 10  // 뷰바인딩 사용준비 android { buildFeatures.viewBinding true } // 뷰페이저2 라이브러리 추가 dependencies { implementation \u0026#39;androidx.viewpager2:viewpager2:1.0.0\u0026#39; }   Fragment의 화면 준비 다음은 new -\u0026gt; fragment를 선택하여 테스트용으로 사용할 프래그먼트를 만들어줍니다. 텍스트를 화면 중간에 표시하기 위해 코드를 약간 변경합니다.\n1 2 3 4 5 6 7  \u0026lt;TextView android:id=\u0026#34;@+id/textview\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;@string/hello_blank_fragment\u0026#34; android:textAppearance=\u0026#34;@style/TextAppearance.AppCompat.Large\u0026#34; /\u0026gt;   Fragment 클래스 작성 기본 프래그먼트에 뷰 바인딩을 적용하고 텍스트를 표시하도록 변경합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class BlankFragment : Fragment() { private var _binding: FragmentBlankBinding? = null private val binding get() = _binding!! override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?, ): View? { // Inflate the layout for this fragment  _binding = FragmentBlankBinding.inflate(inflater, container, false) return binding.root } override fun onDestroyView() { super.onDestroyView() _binding = null } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { binding.textview.text = param1 } }   ViewPager2의 PagerAdapter 작성 방금 작성한 프래그먼트에 텍스트를 전해주는 뷰페이저2 어댑터를 작성합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13  class MyPagerAdapter(fa: FragmentActivity): FragmentStateAdapter(fa) { private val NUM_PAGES = 3 override fun getItemCount(): Int = NUM_PAGES override fun createFragment(position: Int): Fragment { return when (position) { 0 -\u0026gt; { BlankFragment.newInstance(\u0026#34;Page 1\u0026#34;,\u0026#34;\u0026#34;)} 1 -\u0026gt; { BlankFragment.newInstance(\u0026#34;Page 2\u0026#34;,\u0026#34;\u0026#34;)} else -\u0026gt; { BlankFragment.newInstance(\u0026#34;Page 3\u0026#34;,\u0026#34;\u0026#34;)} } } }   activity_main.xml 메인 액티비티의 화면을 구성합니다. 화면 위쪽에 뷰페이저를 배치하고 나머지 공간에 AppBarLayout을 배치한 뒤 그 내부에 TabLayout을 배치합니다. 그리고 TabLayout의 속성을 사용해서 색을 지정합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;androidx.viewpager2.widget.ViewPager2 android:id=\u0026#34;@+id/viewpager\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; app:layout_constraintBottom_toTopOf=\u0026#34;@+id/appBarLayout\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;com.google.android.material.appbar.AppBarLayout android:id=\u0026#34;@+id/appBarLayout\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:theme=\u0026#34;@style/Theme.AppCompat.Light.DarkActionBar\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;com.google.android.material.tabs.TabLayout android:id=\u0026#34;@+id/tabs\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34; android:background=\u0026#34;@color/white\u0026#34; app:tabIndicatorColor=\u0026#34;@color/design_default_color_primary\u0026#34; app:tabRippleColor=\u0026#34;@color/design_default_color_primary\u0026#34; app:tabSelectedTextColor=\u0026#34;@color/design_default_color_primary\u0026#34; app:tabTextColor=\u0026#34;@color/black\u0026#34; /\u0026gt; \u0026lt;/com.google.android.material.appbar.AppBarLayout\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;   Mainactivity 설정 뷰페이저 어댑터 클래스의 인스턴스를 만들어 뷰페이저 어댑터 속성에 연결시킵니다. 그리고 TabLayoutMediator를 이용해서 탭레이아웃과 뷰페이저를 연결합니다. 각 탭의 타이틀과 아이콘은 블럭내부에서 지정할 수 있습니다. 탭의 이름은 Title 0 형식으로 지정하고 아이콘은 벡터 이미지를 추가한 뒤 setIcon에서 불러오도록 하였습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class MainActivity : AppCompatActivity() { private lateinit var binding: ActivityMainBinding override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) binding = ActivityMainBinding.inflate(layoutInflater) setContentView(binding.root) binding.viewpager.apply { adapter = MyPagerAdapter(context as FragmentActivity) } TabLayoutMediator(binding.tabs, binding.viewpager) { tab, position -\u0026gt; tab.text = \u0026#34;Title $position\u0026#34; when (position) { 0 -\u0026gt; tab.setIcon(R.drawable.ic_baseline_format_list_bulleted_24) 1 -\u0026gt; tab.setIcon(R.drawable.ic_baseline_map_24) 2 -\u0026gt; tab.setIcon(R.drawable.ic_baseline_info_24) } }.attach() } }   PageTransformer 설정 뷰페이저2는 페이지를 변경할때 여러가지 효과를 줄 수 있습니다. 구글에서 공개하는 ZoomOutPageTransformer를 사용한다면 스크롤할때 페이지가 축소되면서 페이드아웃되고, 페이지가 중앙에 가까워지면 원래 크기로 다시 커지면서 페이드인 되는 효과를 낼 수 있습니다.\n그 외에도 여러가지 페이지 전환효과를 사용하고 싶다면 다음 블로그를 참고하세요.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  private const val MIN_SCALE = 0.85f private const val MIN_ALPHA = 0.5f class ZoomOutPageTransformer : ViewPager2.PageTransformer { override fun transformPage(view: View, position: Float) { view.apply { val pageWidth = width val pageHeight = height when { position \u0026lt; -1 -\u0026gt; { // [-Infinity,-1)  // This page is way off-screen to the left.  alpha = 0f } position \u0026lt;= 1 -\u0026gt; { // [-1,1]  // Modify the default slide transition to shrink the page as well  val scaleFactor = max(MIN_SCALE, 1 - abs(position)) val vertMargin = pageHeight * (1 - scaleFactor) / 2 val horzMargin = pageWidth * (1 - scaleFactor) / 2 translationX = if (position \u0026lt; 0) { horzMargin - vertMargin / 2 } else { horzMargin + vertMargin / 2 } // Scale the page down (between MIN_SCALE and 1)  scaleX = scaleFactor scaleY = scaleFactor // Fade the page relative to its size.  alpha = (MIN_ALPHA + (((scaleFactor - MIN_SCALE) / (1 - MIN_SCALE)) * (1 - MIN_ALPHA))) } else -\u0026gt; { // (1,+Infinity]  // This page is way off-screen to the right.  alpha = 0f } } } } } // MainActivity binding.viewpager.apply { setPageTransformer(ZoomOutPageTransformer()) }   이렇게 해서 ViewPager2와 TabLayout을 조합한 디자인을 구축하는 법에 대해 알아보았습니다.\n","description":"","id":3,"section":"posts","tags":[],"title":"ViewPager2로 TabLayout 구현하기","uri":"https://cliearl.github.io/en/posts/viewpager2-tablayout/"}]