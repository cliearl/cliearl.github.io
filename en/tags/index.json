[{"content":"이번 포스팅에서는 jsoup을 이용해서 html을 파싱하는 법에 대해 알아보도록 하겠습니다.\njsoup jsoup은 html을 파싱하기 위해 만들어진 오픈소스 자바 라이브러리입니다. 웹페이지를 HTML5 DOM으로 변환하여 요소들을 간편하게 추출할 수 있습니다. 자바 라이브러리이니만큼 코틀린에서도 자유롭게 사용이 가능하지요.\njsoup에는 여러가지 클래스가 있는데 그 중 제 생각에 중요한 것들만 정리하면 다음과 같습니다.\n   클래스 설명     Document jsoup로 얻어온 html 문서   Element 데이터를 추출할 수 있는 개별 html 요소   Elements Iterable한 Element 집합의 자료형   Connection http 접속에 관련한 메소드를 가지는 클래스    jsoup 적용하기 그럼 다른 강의에서 만들었던 코루틴으로 로또번호 당첨을 확인하는 앱에 jsoup을 적용해보도록 하겠습니다. 기존의 앱은 당첨번호를 가져오는데 API를 사용했지만 이번에는 웹페이지에서 가져와야 합니다. 동행복권 홈페이지에 접속하면 메인화면에 금주의 당첨번호를 표시하고 있는데 이 내용을 가져오면 될 것 같습니다.\n이 화면을 브라우저의 개발자도구로 보면 html의 레이아웃을 확인할 수 있습니다. 우리가 원하는 정보는 containerWrap \u0026gt; article \u0026gt; wrap_box wrap1 \u0026gt; box win win645 \u0026gt; content 클래스 안에 위치하고 있네요. 여기서 회차와 당첨번호는 다음과 같은 요소로 정의되어 있습니다.\n1  \u0026lt;strong id=\u0026#34;lottoDrwNo\u0026#34;\u0026gt;968\u0026lt;/strong\u0026gt;   1 2 3 4 5 6 7 8 9  \u0026lt;span class=\u0026#34;accessibility\u0026#34;\u0026gt;당첨번호\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;drwtNo1\u0026#34; class=\u0026#34;ball_645 ball1\u0026#34;\u0026gt;2\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;drwtNo2\u0026#34; class=\u0026#34;ball_645 ball1\u0026#34;\u0026gt;5\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;drwtNo3\u0026#34; class=\u0026#34;ball_645 ball2\u0026#34;\u0026gt;12\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;drwtNo4\u0026#34; class=\u0026#34;ball_645 ball2\u0026#34;\u0026gt;14\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;drwtNo5\u0026#34; class=\u0026#34;ball_645 ball3\u0026#34;\u0026gt;24\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;drwtNo6\u0026#34; class=\u0026#34;ball_645 ball4\u0026#34;\u0026gt;39\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;bonus\u0026#34;\u0026gt;보너스번호\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;bnusNo\u0026#34; class=\u0026#34;ball_645 ball4\u0026#34;\u0026gt;33\u0026lt;/span\u0026gt;   우선은 dependency를 추가합니다.\n1  implementation \u0026#39;org.jsoup:jsoup:1.13.1\u0026#39;   다음은 당첨번호를 가져오는 crawlLottoNumbers함수를 작성합니다. API로 당첨번호를 가져오는 getLottoNumbers와 동일하게 반환값이 당첨번호, 보너스번호, 회차 정보를 가지도록 하겠습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  private suspend fun crawlLottoNumbers() : ArrayList\u0026lt;Int\u0026gt; { val lottoNumbers = ArrayList\u0026lt;Int\u0026gt;() // var doc: Document? = null  try { val doc = Jsoup.connect(\u0026#34;https://dhlottery.co.kr/common.do?method=main\u0026#34;).get() for (i in 1..6) { val drwtNo = doc.select(\u0026#34;#drwtNo$i\u0026#34;).text().toInt() lottoNumbers.add(drwtNo) } val bnusNo = doc.select(\u0026#34;#bnusNo\u0026#34;).text().toInt() lottoNumbers.add(bnusNo) val lottoDrwNo = doc.select(\u0026#34;#lottoDrwNo\u0026#34;).text().toInt() lottoNumbers.add(lottoDrwNo) } catch (e: IOException) { e.printStackTrace() } return lottoNumbers }   우선은 Jsoup.connect().get()으로 html을 받아 Document 객체로 만들어 줍니다. 이 객체에서 데이터를 뽑아낼때는 select명령을 사용하는데 괄호 안에는 CSS or jquery-like selector syntax를 넣습니다. 주요한 셀렉터들은 다음과 같습니다.\n tagname: find elements by tag, e.g. a ns|tag: find elements by tag in a namespace, e.g. fb|name finds fb:name elements #id: find elements by ID, e.g. #logo .class: find elements by class name, e.g. .masthead [attribute]: elements with attribute, e.g. [href]  [attr=value]: elements with attribute value, e.g. [width=500] (also quotable, like [data-name=\u0026lsquo;launch sequence\u0026rsquo;]) [attr^=value], [attr$=value], [attr*=value]: elements with attributes that start with, end with, or contain the value, e.g. [href*=/path/] [attr~=regex]: elements with attribute values that match the regular expression; e.g. img[src~=(?i).(png|jpe?g)] *: all elements, e.g. *  당첨번호와 회차정보는 id로 정의되어 있기 때문에 select 함수에 #id 쿼리를 전달해주면 됩니다. 추출한 정보를 Int로 변환하여 lottoNumbers에 추가하면 끝입니다.\n이렇게 해서 jsoup으로 html을 다운받고 파싱하는 법에 대해 알아보았습니다.\n","description":"","id":0,"section":"posts","tags":["jsoup","coroutine","html","parsing"],"title":"jsoup으로 html 파싱하기","uri":"https://cliearl.github.io/en/posts/jsoup-lotto-checker/"},{"content":"이번 포스팅에서는 코루틴을 사용해서 로또번호의 당첨을 확인하는 법에 대해 알아보도록 하겠습니다.\n당첨번호 조회하기 이전에 다른 강의에서 로또번호를 생성하는 앱을 만들어보았는데요, 여기서는 이 앱에 코루틴을 이용해서 당첨여부를 확인하는 기능을 추가하도록 하겠습니다. 코루틴에 대한 이론설명도 다른 강의를 참조하시기 바랍니다.\n금주의 로또 당첨번호는 동행복권 홈페이지에서 확인할 수 있습니다. 다른 회차의 당첨번호는 홈페이지의 회차별 당첨번호 페이지에서 확인할 수 있게 되어 있습니다.\n그런데 이렇게 홈페이지에 접속하지 않고도 당첨번호는 API로 조회할 수 있습니다. 다음 주소의 \u0026ldquo;회차\u0026quot;라고 되어 있는 부분에 확인하고 싶은 회차의 숫자를 넣으시면 됩니다.\n1  https://dhlottery.co.kr/common.do?method=getLottoNumber\u0026amp;drwNo=\u0026#34;회차\u0026#34;   예를 들면 968회차의 응답은 다음과 같은 json 형식으로 돌아옵니다. totSellamnt는 총 판매액, returnValue는 API응답 성공여부, drwNoDate는 추첨일, firstWinamnt는 1등상금, drwNo는 회차, drwtNo1~6이 당첨번호이고, bnusNo가 보너스번호입니다.\n1  {\u0026#34;totSellamnt\u0026#34;:95924229000,\u0026#34;returnValue\u0026#34;:\u0026#34;success\u0026#34;,\u0026#34;drwNoDate\u0026#34;:\u0026#34;2021-06-19\u0026#34;,\u0026#34;firstWinamnt\u0026#34;:1667729683,\u0026#34;drwtNo6\u0026#34;:39,\u0026#34;drwtNo4\u0026#34;:14,\u0026#34;firstPrzwnerCo\u0026#34;:13,\u0026#34;drwtNo5\u0026#34;:24,\u0026#34;bnusNo\u0026#34;:33,\u0026#34;firstAccumamnt\u0026#34;:21680485879,\u0026#34;drwNo\u0026#34;:968,\u0026#34;drwtNo2\u0026#34;:5,\u0026#34;drwtNo3\u0026#34;:12,\u0026#34;drwtNo1\u0026#34;:2}   Dependency 확인 자 그러면 drwtNo1~6, bnusNo의 값을 추출해서 나의 값과 비교하면 되겠네요. 당첨번호는 네트워크에서 백그라운드로 받아와야 하기 때문에 코루틴으로 처리하도록 하면 되겠고, 받아온 json으로부터 값을 추출하는데에는 gson 라이브러리를 사용하면 될 것 같습니다. 코루틴의 이론과 gson에 대해서는 각각 다른 강의에서 다루었으니 그것을 참고하시면 되겠습니다.\n1 2  implementation \u0026#39;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.1\u0026#39; implementation \u0026#39;com.google.code.gson:gson:2.8.6\u0026#39;   네트워크로 당첨번호 받아오기 그럼 네트워크로 당첨번호를 받아오는 getLottoNumbers 함수와, 두 값을 비교하는 whatIsRank 함수를 만들도록 하겠습니다.\ngetLottoNumbers는 전달받은 API 주소에 조회를 요청하고 반환값을 처리합니다. 이 함수는 네트워크를 사용해야 하므로 코루틴 안에서 사용하기 위해 suspend 키워드를 붙여줍니다. API는 단순한 GET 요청이므로 소켓을 만들지 않고 간단하게 URL과 readText로 값을 읽어오도록 하였습니다.\nAPI 주소와 결합할 round에는 내 번호와 비교할 당첨번호의 회차를 넣습니다. 읽어온 값의 returnValue가 success이면 drwtNo1~6, bnusNo 값을 추출하여 배열에 모으도록 하였습니다. 마지막에는 당첨번호를 확인할 회차를 추가하였습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  private suspend fun getLottoNumbers(): ArrayList\u0026lt;Int\u0026gt; { val round = \u0026#34;968\u0026#34; val url = \u0026#34;https://dhlottery.co.kr/common.do?method=getLottoNumber\u0026amp;drwNo=$round\u0026#34; val lottoNumbers = ArrayList\u0026lt;Int\u0026gt;() try { val response = URL(url).readText() val jsonObject = JsonParser.parseString(response).asJsonObject val returnValue = jsonObject.get(\u0026#34;returnValue\u0026#34;).asString if (returnValue == \u0026#34;success\u0026#34;) { for (i in 1..6) { val lottoNumber = jsonObject.get(\u0026#34;drwtNo$i\u0026#34;).asInt lottoNumbers.add(lottoNumber) } val bonusNumber = jsonObject.get(\u0026#34;bnusNo\u0026#34;).asInt lottoNumbers.add(bonusNumber) lottoNumbers.add(round.toInt()) } } catch (e: Exception) { e.printStackTrace() } return lottoNumbers }   내 번호와 당첨번호 비교하기 다음은 내 번호와 당첨번호를 비교하는 함수를 만듭니다. 로또의 규칙은 표의 내용과 같이 되어 있습니다. 그래서 whatIsRank에서는 내 로또번호와 당첨번호를 전달받아 처음 6개까지의 숫자를 비교해 일치한 갯수를 세고, 일치한 번호의 갯수가 5개이면 추가로 보너스번호인 7번째 번호가 일치하는지 확인하도록 하면 됩니다.\n   순위 당첨내용     1 6개 번호 모두 일치   2 5개 번호 일치 + 나머지 1개가 보너스 번호와 일치   3 5개 번호 일치   4 4개 번호 일치   5 3개 번호 일치    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  private suspend fun whatIsRank(lottoNumbers: ArrayList\u0026lt;Int\u0026gt;, winningNumbers: ArrayList\u0026lt;Int\u0026gt;): String { // https://namu.wiki/w/%EB%A1%9C%EB%98%90%206/45#s-4  var matchCount = 0 for (i in 0..5) { if (lottoNumbers.contains(winningNumbers[i])) { matchCount += 1 } } return if (matchCount == 6) { \u0026#34;1등\u0026#34; } else if (matchCount == 5) { if (lottoNumbers.contains(winningNumbers[6])) { \u0026#34;2등\u0026#34; } else { \u0026#34;3등\u0026#34; } } else if (matchCount == 4) { \u0026#34;4등\u0026#34; } else if (matchCount == 3) { \u0026#34;5등\u0026#34; } else { \u0026#34;낙첨\u0026#34; } }   xml에는 비교결과를 보여주는 텍스트뷰 하나를 추가하도록 하겠습니다.\n1 2 3 4 5 6 7 8  \u0026lt;TextView android:id=\u0026#34;@+id/tv_winning\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;20dp\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;당첨결과\u0026#34; android:textAppearance=\u0026#34;@style/TextAppearance.AppCompat.Large\u0026#34; /\u0026gt;   코루틴으로 작업 처리하기 그러면 번호생성버튼을 눌렀을 때 생성된 번호를 당첨번호와 비교하는 코루틴을 추가하겠습니다. CoroutineScope로 스코프를 정의하고, 네트워크에서 값을 가져올 것이기 때문에 Dispatchers는 IO로 설정합니다. 그리고 작업 후에 값을 반환할 필요가 없기 때문에 빌더는 launch를 사용합니다.\n작업은 getLottoNumbers에서 얻어진 결과값를 whatIsRank에 사용해야 하기 때문에 winningNumbers는 async로 자식 코루틴을 만듭니다. whatIsRank에 전달할때는 Deferred 반환값을 끝까지 처리하여 ArrayList를 전해주기 위해 await를 사용합니다. 최종적으로 텍스트뷰에 표시할 텍스트를 만들때도 await를 사용해서 처리가 모두 종료될 때까지 기다리도록 합니다.\n마지막으로 text를 텍스트뷰에 표시해야 하는데 이 부분은 UI를 건드리는 부분이라 메인스레드에서 작업이 이루어져야 하기 때문에 작업할 스레드를 withContext로 전환한 뒤 당첨결과를 표시하면 되겠죠.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  binding.generateButton.setOnClickListener { val lottoNumbers = createLottoNumbers() Log.d(\u0026#34;TAG\u0026#34;, lottoNumbers.toString()) updateLottoBallImage(lottoNumbers) CoroutineScope(Dispatchers.IO + job).launch { val winningNumbers = async { getLottoNumbers() } val rank = whatIsRank(lottoNumbers, winningNumbers.await()) val text = \u0026#34;${winningNumbers.await()}: $rank\u0026#34; withContext(Dispatchers.Main) { binding.tvWinning.text = text } } }   코루틴 취소하기 액티비티가 종료되었을 때 실행중인 코루틴이 살아남는것을 방지하기 위해 취소하는 기능을 추가해 보도록 하겠습니다. 코루틴 강의에서 설명했던 것처럼 코루틴을 취소하기 위해서는 job에 대해 cancel을 수행하면 됩니다. 그런데 generateButton 안에서 수행된 CoroutineScope에 대해서는 반환되는 job을 오브젝트로 만들지 않았습니다.\n이런 경우에는 Job 전역변수를 하나 만들어 주고 디스패처와 결합합니다. 코틀린의 코루틴은 자식 코루틴이 취소되면 연결된 부모 코루틴이 모두 취소되는 특징을 가지고 있으므로 onDestroy에서 job에 대해 cancel을 수행하면 연결시킨 코루틴을 취소할 수 있습니다.\n실제 예제에서는 뷰모델을 이용하게 되므로 lifecycle 모듈과 결합하여 사용하면 좀 더 앱의 라이프사이클과 연동된 생명주기를 가지게 할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class MainActivity : AppCompatActivity() { ... private val job = Job() override fun onCreate(savedInstanceState: Bundle?) { ... binding.generateButton.setOnClickListener { ... CoroutineScope(Dispatchers.IO + job).launch { ... } } } override fun onDestroy() { job.cancel() super.onDestroy() } }   이렇게 코루틴을 이용해서 나의 로또번호를 인터넷의 당첨결과와 비교하는 법에 대해 알아보았습니다.\n","description":"","id":1,"section":"posts","tags":["coroutine","lotto"],"title":"코루틴으로 로또번호 당첨 확인하기","uri":"https://cliearl.github.io/en/posts/lotto-checker/"},{"content":"이번 포스팅에서는 RecyclerView에 ListAdapter를 적용하는 법에 대해 알아보도록 하겠습니다.\n들어가기 리사이클러뷰의 데이터가 변하면 리사이클러뷰 어댑터가 제공하는 notifyItem 메소드를 사용해서 뷰홀더 내용을 갱신할 수 있습니다.\nnotifyItemChanged(int) notifyItemInserted(int) notifyItemRemoved(int) notifyItemRangeChanged(int, int) notifyItemRangeInserted(int, int) notifyItemRangeRemoved(int, int) 그런데 데이터가 변경되는 방식을 확인하고 그때마다 이렇게 notify를 일일이 해 주는것은 번거롭기도 하고, 또 사용하기에 따라서는 갱신이 필요없는 뷰홀더를 같이 갱신하는 불필요한 작업이 생길수도 있습니다.\nDiffUtil DiffUtil은 두 데이터셋을 받아서 그 차이를 계산해주는 클래스입니다. DiffUtil을 사용하면 두 데이터 셋을 비교한 뒤 그중 변한부분만을 파악하여 리사이클러뷰에 반영할 수 있습니다.\nDiffUtil은 Eugene W. Myers의 difference 알고리즘을 이용해서 O(N + D^2)시간 안에 리스트의 비교를 수행하는데 넥서스 5X에서 테스트를 수행한 결과는 다음과 같았다고 합니다.\n100 items and 10 modifications: avg: 0.39 ms, median: 0.35 ms 100 items and 100 modifications: 3.82 ms, median: 3.75 ms 100 items and 100 modifications without moves: 2.09 ms, median: 2.06 ms 1000 items and 50 modifications: avg: 4.67 ms, median: 4.59 ms 1000 items and 50 modifications without moves: avg: 3.59 ms, median: 3.50 ms 1000 items and 200 modifications: 27.07 ms, median: 26.92 ms 1000 items and 200 modifications without moves: 13.54 ms, median: 13.36 ms DiffUtil을 사용하기 위해서는 DiffUtil.Callback()을 상속받아 areItemsTheSame()과 areContentsTheSame()을 구현하면 되는데, 전자는 두 아이템이 동일한 아이템인지 체크하고 결과가 만약 동일하다면 후자의 메소드로 아이템의 내용물까지 동일한지 확인하게 됩니다.\nAsyncListDiffer DiffUtil은 아이템 개수가 많을 경우 비교연산시간에 필요한 시간이 길어질 수 있기 때문에 백그라운드 스레드에서 처리되어야 합니다. AsyncListDiffer는 DiffUtil을 편하게 쓰기 위해서 만들어진 클래스로, DiffUtil에 대해 자체적으로 스레드 처리를 해 줍니다.\n코드를 사용하기 위해서는 우선 어댑터 내부로 DiffUtil 콜백을 전달받은 AsyncListDiffer 객체를 만들어 줍니다. 그리고 currentList로 데이터를 참조하고 submitList()로 리스트 데이터를 갱신하면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  // Google Developer에서 제공하는 코드  class UserAdapter extends RecyclerView.Adapter\u0026lt;UserViewHolder\u0026gt; { private final AsyncListDiffer\u0026lt;User\u0026gt; mDiffer = new AsyncListDiffer(this, DIFF_CALLBACK); @Override public int getItemCount() { return mDiffer.getCurrentList().size(); } public void submitList(List\u0026lt;User\u0026gt; list) { mDiffer.submitList(list); } @Override public void onBindViewHolder(UserViewHolder holder, int position) { User user = mDiffer.getCurrentList().get(position); holder.bindTo(user); } public static final DiffUtil.ItemCallback\u0026lt;User\u0026gt; DIFF_CALLBACK = new DiffUtil.ItemCallback\u0026lt;User\u0026gt;() { @Override public boolean areItemsTheSame( @NonNull User oldUser, @NonNull User newUser) { // User properties may have changed if reloaded from the DB, but ID is fixed  return oldUser.getId() == newUser.getId(); } @Override public boolean areContentsTheSame( @NonNull User oldUser, @NonNull User newUser) { // NOTE: if you use equals, your object must properly override Object#equals()  // Incorrectly returning false here will result in too many animations.  return oldUser.equals(newUser); } } }   ListAdapter ListAdapter는 AsyncListDiffer를 더 쓰기 편하도록 랩핑한 클래스로 리사이클러뷰 어댑터를 만들때 ListAdapter를 상속하도록 하면 됩니다. 초기화할때 DiffUtil 콜백 객체를 받도록 하면 나머지는 AsyncListDiffer와 같이 currentList로 현재 데이터를 불러올 수 있고, submitList로 데이터를 갱신할 수 있습니다.\n다시말해 리사이클러뷰 어댑터를 ListAdapter로 구현하면 데이터가 어떻게 바뀌든간에 submitList로 전체 리스트를 넘겨주기만 하면 어댑터가 알아서 백그라운드 스레드를 사용해 리스트 차이를 계산하여 화면을 갱신시켜주게 됩니다.\n앱 작성 기존에 다른 강의에서 작성했던 프로젝트를 고치는 형태로 프로젝트를 만들어 보겠습니다.\nMonster.kt 우선 리사이클러뷰에 표시할 데이터를 데이터클래스형태로 준비합니다.\n1 2 3 4 5 6 7 8 9 10 11  data class Monster( val name: String, val race: Race, val level: Int, val stats: List\u0026lt;Int\u0026gt;, val encount: Boolean ) enum class Race { Zombie, Human, Goblin, Dragon }   view_itemlist.xml 리사이클러뷰의 뷰홀더 xml을 만들어줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/vhLayout\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;?attr/selectableItemBackground\u0026#34; android:gravity=\u0026#34;center_vertical\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:paddingStart=\u0026#34;20dp\u0026#34; android:paddingEnd=\u0026#34;20dp\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;9\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_name\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:padding=\u0026#34;3dp\u0026#34; android:text=\u0026#34;Monster name\u0026#34; android:textSize=\u0026#34;24sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_race\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Race\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_level\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Level\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_stats\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Stats\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_encount\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Encount\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;FrameLayout android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;30dp\u0026#34; android:layout_height=\u0026#34;30dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:src=\u0026#34;@drawable/ic_baseline_reorder_24\u0026#34; /\u0026gt; \u0026lt;/FrameLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt;   MyViewHolder.kt 리사이클러뷰의 뷰홀더 클래스를 만들어줍니다. 뷰바인딩을 사용하도록 세팅하고 나중에 투명도를 바꾸는데 사용하도록 setAlpha() 함수를 만들어줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class MyViewHolder(private val binding: ViewItemlistBinding) : RecyclerView.ViewHolder(binding.root) { fun bind(data: Monster) { with(binding) { tvName.text = \u0026#34;Name: ${data.name}\u0026#34; tvRace.text = \u0026#34;Race: ${data.race}\u0026#34; tvLevel.text = \u0026#34;Level: ${data.level}\u0026#34; tvStats.text = \u0026#34;HP: ${data.stats[0]}/ MP: ${data.stats[1]}/ Exp: ${data.stats[2]}\u0026#34; tvEncount.text = \u0026#34;Encounted: ${data.encount}\u0026#34; vhLayout.setOnClickListener { Snackbar.make(it, \u0026#34;Item $layoutPositiontouched!\u0026#34;, Snackbar.LENGTH_SHORT).show() } } } fun setAlpha(alpha: Float) { with(binding) { tvName.alpha = alpha tvRace.alpha = alpha tvLevel.alpha = alpha tvStats.alpha = alpha tvEncount.alpha = alpha } } }   MyDiffCallback.kt Monster 클래스가 데이터 클래스이므로 areItemsTheSame()은 자동으로 정의되는 hashCode()로 비교하도록 하였습니다. 데이터클래스의 정의에 따라 동일한 두 객체의 hashCode()는 동일한 값을 갖게 됩니다. 또한 equals()도 자동으로 정의되므로 areContentsTheSame() 메소드는 equals를 이용해 구현합니다.\n1 2 3 4 5 6 7 8 9  class MyDiffCallback : DiffUtil.ItemCallback\u0026lt;Monster\u0026gt;() { override fun areItemsTheSame(oldItem: Monster, newItem: Monster): Boolean { return oldItem.hashCode() == newItem.hashCode() } override fun areContentsTheSame(oldItem: Monster, newItem: Monster): Boolean { return oldItem == newItem } }   MyListAdapter.kt ListAdapter를 상속받는 리사이클러뷰 어댑터를 작성합니다. onCreateViewHolder에서 뷰바인딩을 사용하도록 설정합니다. 데이터의 개수는 ListAdapter가 관리하므로 기존의 리사이클러뷰 어댑터에서 정의했던 getItemCount()는 오버라이드하지 않아도 됩니다.\n그리고 아이템을 이동했을때 실행할 moveItem(), 지울때 실행할 removeItem() 메소드를 작성해줍니다. 이 때 ListAdapter에서는 데이터를 직접 조작할 수 없고 비교만 할수 있기 때문에 변형된 데이터셋은 새로운 객체로 만들어 기존의 데이터셋과 비교도록 submitList()를 수행하게 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class MyListAdapter : ListAdapter\u0026lt;Monster, RecyclerView.ViewHolder\u0026gt;(MyDiffCallback()) { override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder { val viewHolder = MyViewHolder( ViewItemlistBinding.inflate( LayoutInflater.from(parent.context), parent, false ) ) return viewHolder } override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) { if (holder is MyViewHolder) { val monster = getItem(position) as Monster holder.bind(monster) } } fun moveItem(fromPosition: Int, toPosition: Int) { val newList = currentList.toMutableList() // val item = newList.removeAt(fromPosition)  // newList.add(toPosition, item)  Collections.swap(newList, fromPosition, toPosition) submitList(newList) } fun removeItem(position: Int) { val newList = currentList.toMutableList() newList.removeAt(position) submitList(newList) } }   MyItemTouchHelperCallback.kt 기존 프로젝트에서 터치 콜백을 받기 위해 MainActivity에서 사용했던 ItemTouchHelper.SimpleCallback 클래스는 코드의 가독성을 위해 개별 클래스로 분리시키겠습니다.\n그리고 추가로 홀딩중인 뷰홀더의 투명도를 변화시켜 더 인지하기 쉽게 만들겠습니다. 그럴려면 onSelectedChanged()에서 투명도를 50%로 낮추었다가 clearView()애서 다시 100%로 되돌리도록 하면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  class MyItemTouchHelperCallback(private val recyclerView: RecyclerView) : ItemTouchHelper.SimpleCallback( ItemTouchHelper.UP or ItemTouchHelper.DOWN, ItemTouchHelper.LEFT ) { override fun onMove( recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder, target: RecyclerView.ViewHolder ): Boolean { (recyclerView.adapter as MyListAdapter).moveItem( viewHolder.absoluteAdapterPosition, target.absoluteAdapterPosition ) return true } override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) { (recyclerView.adapter as MyListAdapter).removeItem(viewHolder.layoutPosition) } // 홀딩중인 뷰홀더 투명도를 변경  override fun onSelectedChanged(viewHolder: RecyclerView.ViewHolder?, actionState: Int) { super.onSelectedChanged(viewHolder, actionState) when (actionState) { ItemTouchHelper.ACTION_STATE_DRAG, ItemTouchHelper.ACTION_STATE_SWIPE -\u0026gt; { (viewHolder as MyViewHolder).setAlpha(0.5f) } } } // 홀딩중인 뷰홀더 투명도를 되돌림  override fun clearView( recyclerView: RecyclerView, viewHolder: RecyclerView.ViewHolder ) { super.clearView(recyclerView, viewHolder) (viewHolder as MyViewHolder).setAlpha(1.0f) } }   activity_main.xml 리사이클러뷰와 플로팅버튼을 배치해줍니다. 기존의 터치조작에 더해 DiffUtil의 테스트를 위해 플로팅버튼을 누르면 데이터가 랜덤하게 뒤섞이는 기능이 수행되도록 하겠습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;androidx.recyclerview.widget.RecyclerView android:id=\u0026#34;@+id/recyclerview\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:scrollbars=\u0026#34;vertical\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; tools:listitem=\u0026#34;@layout/view_itemlist\u0026#34; /\u0026gt; \u0026lt;com.google.android.material.floatingactionbutton.FloatingActionButton android:id=\u0026#34;@+id/fab\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginEnd=\u0026#34;20dp\u0026#34; android:layout_marginBottom=\u0026#34;20dp\u0026#34; android:src=\u0026#34;@drawable/ic_baseline_add_24\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;   MainActivity.kt 데이터셋에 초기값을 넣어주고, 어댑터 인스턴스를 생성하여 리사이클러뷰와 연동시킵니다. 그리고 터치헬퍼를 달아 스와이프와 드래그를 했을때 데이터가 잘 갱신되는지 확인합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  class MainActivity : AppCompatActivity() { private val binding: ActivityMainBinding by lazy { ActivityMainBinding.inflate(layoutInflater) } private val myListAdapter: MyListAdapter by lazy { MyListAdapter() } private val dataSet = arrayListOf\u0026lt;Monster\u0026gt;().apply { add(Monster(\u0026#34;타일런트\u0026#34;, Race.Zombie, 10, listOf(100, 10, 50), false)) add(Monster(\u0026#34;조커\u0026#34;, Race.Human, 23, listOf(200, 20, 100), false)) add(Monster(\u0026#34;그렘린\u0026#34;, Race.Goblin, 2, listOf(10, 1, 5), true)) add(Monster(\u0026#34;리오레우스\u0026#34;, Race.Dragon, 2500, listOf(10000, 1000, 50000), false)) add(Monster(\u0026#34;사우론\u0026#34;, Race.Human, 100, listOf(1000, 200, 1000), false)) add(Monster(\u0026#34;리바이어던\u0026#34;, Race.Dragon, 50, listOf(2000, 250, 10000), true)) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(binding.root) myListAdapter.submitList(dataSet) binding.recyclerview.apply { layoutManager = LinearLayoutManager(context, LinearLayoutManager.VERTICAL, false) addItemDecoration(DividerItemDecoration(context, DividerItemDecoration.VERTICAL)) adapter = myListAdapter } binding.fab.setOnClickListener { myListAdapter.submitList(dataSet.shuffled()) } val itemTouchHelper = ItemTouchHelper(MyItemTouchHelperCallback(binding.recyclerview)) itemTouchHelper.attachToRecyclerView(binding.recyclerview) } }   이렇게해서 ListAdapter를 RecyclerView에 적용하는 법에 대해 알아보았습니다.\n","description":"","id":2,"section":"posts","tags":["RecyclerView","ListAdapter"],"title":"RecyclerView에 ListAdapter 적용하기","uri":"https://cliearl.github.io/en/posts/recyclerview-listadapter/"}]